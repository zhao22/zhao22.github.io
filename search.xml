<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>java基础(八)循环结构</title>
      <link href="/2018/09/05/java%E5%9F%BA%E7%A1%80-%E5%85%AB-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/"/>
      <url>/2018/09/05/java%E5%9F%BA%E7%A1%80-%E5%85%AB-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="循环介绍"><a href="#循环介绍" class="headerlink" title="循环介绍"></a>循环介绍</h2><p>打印一个HelloWorld,我们输入下面这串代码就可以解决:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">```  </span><br><span class="line">那如果要打印<span class="number">200</span>条HelloWorld呢?粗暴地粘贴<span class="number">200</span>份代码当然可以解决。不过，学了本节后，你就可以高效地用三种循环来打印了。   </span><br><span class="line"></span><br><span class="line">## while循环</span><br><span class="line"><span class="keyword">while</span>循环放到最前面，主要是因为最简单。  </span><br><span class="line">使用<span class="keyword">while</span>循环的语法如下:  </span><br><span class="line">```java</span><br><span class="line"><span class="comment">// 以下代码仅供讲解</span></span><br><span class="line"><span class="keyword">while</span>(<span class="comment">/*条件*/</span>)&#123;</span><br><span class="line"><span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序运行到<strong>while</strong>的时候,会判断<strong>条件</strong>是否成立，<br><strong>条件成立</strong>，执行括号内的<strong>循环体</strong>。<br><strong>循环体</strong>执行完毕，<strong>再次</strong>判断<strong>条件</strong>是否成立。<br><strong>条件成立</strong>, 则继续执行括号内的<strong>循环体</strong>。<br>…<br>直到条件<strong>不成立</strong>时，才会退出循环。  </p><p>下面我们试试用<strong>while</strong>循环输出200条HelloWorld, 为了验证输出了多少条HelloWorld，我们同时把i也输出出来:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">200</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"HelloWorld:"</span>+i);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">上面的代码可以翻译成:  </span><br><span class="line">当**i**小于**<span class="number">200</span>**时，**i**加**<span class="number">1</span>**，打印**HelloWorld**.然后再判断是否小于**<span class="number">200</span>**...</span><br></pre></td></tr></table></figure></p><p>TIPS: 我们发现，打印出来的不是1-100，而是0-199，这是因为在程序中，我们一般习惯以0作为第一个数字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果打掉了**i++**，就会变成下面这段代码:  </span><br><span class="line">```java</span><br><span class="line">int i = 0;</span><br><span class="line">while(i &lt; 200)&#123;</span><br><span class="line">System.out.println(&quot;HelloWorld:&quot;+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码由于无论进行多少次循环，<strong>i</strong>的值始终小于200。所以循环会一直进行下去。请及时点击控制台上方的红色方块停止程序。<br>这种无法跳出的循环一般被称作死循环，死循环在实际生产环境中并不是不存在的。它通常存在一个独立的<strong>线程</strong>中，用于<strong>监听</strong>某件事情的发生。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIPS: 一般来讲，我们的软件是一个进程，进程内可以创建多个线程。这些线程可以看做是同一时间做不同的工作的，之后会在线程章节单独讲解。</span><br></pre></td></tr></table></figure></p><h2 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do..while..循环"></a>do..while..循环</h2><p>如果<strong>while</strong>可以翻译成：当满足一定条件的话，循环执行循环体中的代码。<br>那么<strong>do…while</strong>就可以翻译成: 执行循环体中的代码，当满足一定条件的时候进行循环。<br>它和while循环的区别是：<br>如果不满足条件，<strong>while</strong>循环内的循环体<strong>一次都不会执行</strong>。<br>而<strong>do…while</strong>循环<strong>无论条件满不满足，都会执行一遍循环体</strong>。<br>do…while的语法如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码仅供讲解</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="comment">// 循环体</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="comment">/*条件*/</span>);</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">我们来实际看一下<span class="keyword">while</span>和<span class="keyword">do</span>...<span class="keyword">while</span>的区别:</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">boolean</span> alwaysFalse = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(alwaysFalse)&#123;</span><br><span class="line">System.out.println(<span class="string">"while 执行了"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"do...while 执行了"</span>); <span class="comment">// do...while 执行了</span></span><br><span class="line">&#125;<span class="keyword">while</span>(alwaysFalse);</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">下面，我们来试试用<span class="keyword">do</span>...<span class="keyword">while</span>打印<span class="number">200</span>个HelloWorld:</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"HelloWorld:"</span>+i);</span><br><span class="line">i++;</span><br><span class="line">&#125;<span class="keyword">while</span>(i &lt; <span class="number">200</span>);</span><br><span class="line">```  </span><br><span class="line">可以看出，和<span class="keyword">while</span>用起来是很像的。</span><br><span class="line"></span><br><span class="line">## for循环</span><br><span class="line"><span class="keyword">for</span>循环在实际工作中使用次数是最多的。也是初学者学起来略微复杂的一种循环。  </span><br><span class="line">它的基本语法如下:  </span><br><span class="line">```java</span><br><span class="line"><span class="comment">// 以下代码仅供讲解</span></span><br><span class="line"><span class="keyword">for</span>(<span class="comment">/*循环准备*/</span>;<span class="comment">/*判断条件*/</span>;<span class="comment">/*单次循环后工作*/</span>)&#123;</span><br><span class="line"><span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">它的执行顺序是:</span><br></pre></td></tr></table></figure></p><p>循环准备 → 判断条件（成立）→ 循环体 → 单次循环后工作 → 判断条件（成立）→ 循环体 → 单次循环后工作 …<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们来试试用for循环打印200次HelloWorld：  </span><br><span class="line">```java</span><br><span class="line">for(int i = 0; i &lt; 200; i++)&#123;</span><br><span class="line">System.out.println(&quot;HelloWorld:&quot;+i);</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">我们会发现，其实它是while的一种变形，只要牢记for循环的执行顺序，用起来会非常方便。  </span><br><span class="line"></span><br><span class="line">## break 和 continue</span><br><span class="line">**break**意为跳出整个循环。  </span><br><span class="line">**continue**意为跳出本次循环。  </span><br><span class="line">这是初学者容易搞不清楚的。下面我们把它应用在for循环结合实际效果讲解:  </span><br><span class="line">```java</span><br><span class="line">for(int i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">if(i == 2)&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;程序执行完毕&quot;);</span><br><span class="line">```  </span><br><span class="line">以上是break的测试代码,输出结果为:0 1 程序执行完毕。  </span><br><span class="line">程序执行过程为:  </span><br><span class="line">i = 0时,i小于5,进入循环体,i不等于2,不执行break.打印0.  </span><br><span class="line">i = 1时,i小于5,进入循环体,i不等于2,不执行break.打印1.  </span><br><span class="line">i = 2是,i小于5,进入循环体,i等于2,执行break.  </span><br><span class="line">循环结束, 打印**程序执行完毕**.  </span><br><span class="line">  </span><br><span class="line">下面来看**continue**的测试代码:  </span><br><span class="line">```java</span><br><span class="line">for(int i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">if(i == 2)&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;程序执行完毕&quot;);</span><br></pre></td></tr></table></figure></p><p>输出结果为: 0 1 3 4 程序执行完毕.<br>程序执行过程为:<br>i = 0时,i小于5,进入循环体,i不等于2,不执行continue.打印<strong>0</strong>.<br>i = 1时,i小于5,进入循环体,i不等于2,不执行continue.打印<strong>1</strong>.<br>i = 2是,i小于5,进入循环体,i等于2,执行continue，跳过打印<strong>2</strong>。<br>i = 3时,i小于5,进入循环体,i不等于2,不执行continue.打印<strong>3</strong>.<br>i = 4时,i小于5,进入循环体,i不等于2,不执行continue.打印<strong>4</strong>.<br>循环结束, 打印<strong>程序执行完毕</strong>.  </p>]]></content>
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java基础(七)分支结构</title>
      <link href="/2018/09/05/java%E5%9F%BA%E7%A1%80-%E4%B8%83-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/"/>
      <url>/2018/09/05/java%E5%9F%BA%E7%A1%80-%E4%B8%83-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><p>分支结构指的是，根据判断条件不同，导致系统选择性地执行部分代码。<br>比如明天下雨，执行打伞的代码，明天天晴，执行戴太阳眼镜的代码。<br>java中的分支结构主要有 <strong>if…else if…else</strong>, <strong>switch…case..</strong>, <strong>三目运算符</strong></p><a id="more"></a><h2 id="和-amp-amp"><a href="#和-amp-amp" class="headerlink" title="|| 和 &amp;&amp;"></a>|| 和 &amp;&amp;</h2><p>在讲分支结构之前，需要补充讲解 ||（或者）和 &amp;&amp;（并且）两个判断连接符。<br>|| 和 &amp;&amp; 用于连接两个boolean型参数。<br>|| 在 两边任意一个为true时，返回true，否则为false。<br>&amp;&amp; 在 两边都为true时，返回true，否则为false。<br>真值表:  </p><table><thead><tr><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">a或者b</th><th style="text-align:center">a并且b</th></tr></thead><tbody><tr><td style="text-align:center">true</td><td style="text-align:center">true</td><td style="text-align:center">true</td><td style="text-align:center">true</td></tr><tr><td style="text-align:center">true</td><td style="text-align:center">false</td><td style="text-align:center">true</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">false</td><td style="text-align:center">true</td><td style="text-align:center">true</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">false</td><td style="text-align:center">false</td><td style="text-align:center">false</td><td style="text-align:center">false</td></tr></tbody></table><h2 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a>if…else</h2><p>这种类型的分支结构比较常见。<br>结构为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码仅供展示，不能运行</span></span><br><span class="line"><span class="keyword">if</span>(<span class="comment">/*成立条件*/</span>)&#123;</span><br><span class="line"><span class="comment">// 分支内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>成立条件里是一个boolean值，如果boolean值为true,则执行分支内容，否则不执行。我们可以扩展为<strong>if…else…</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码仅供展示，不能运行</span></span><br><span class="line"><span class="keyword">if</span>(<span class="comment">/*成立条件*/</span>)&#123;</span><br><span class="line"><span class="comment">// 分支内容1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 分支内容2</span></span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">这里的意思是，如果成立条件是<span class="keyword">true</span>,执行分支内容<span class="number">1</span>，不执行分支内容<span class="number">2</span>。否则执行分支内容<span class="number">2</span>，不执行分支内容<span class="number">1</span>。我们还可以扩展为**<span class="keyword">if</span>...<span class="keyword">else</span> <span class="keyword">if</span>...<span class="keyword">else</span>**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="comment">// 以下代码仅供展示，不能运行</span></span><br><span class="line"><span class="keyword">if</span>(<span class="comment">/*成立条件1*/</span>)&#123;</span><br><span class="line"><span class="comment">// 分支内容1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="comment">/*成立条件2*/</span>)&#123;</span><br><span class="line"><span class="comment">// 分支内容2</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 分支内容3</span></span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">这里的意思是，  </span><br><span class="line">如果成立条件<span class="number">1</span>是**<span class="keyword">true</span>**,执行分支内容<span class="number">1</span>，不执行分支内容<span class="number">2</span>,<span class="number">3</span>.  </span><br><span class="line">如果成立条件<span class="number">1</span>是**<span class="keyword">false</span>**,判断成立条件<span class="number">2</span>是**<span class="keyword">true</span>**，执行分支内容<span class="number">2</span>  </span><br><span class="line">如果成立条件<span class="number">1</span>,<span class="number">2</span>都是**<span class="keyword">false</span>**，执行分支内容<span class="number">3</span>.  </span><br><span class="line">  </span><br><span class="line">**这里的<span class="keyword">else</span> <span class="keyword">if</span>可以写多个，只有当上面的<span class="keyword">if</span>和<span class="keyword">else</span> <span class="keyword">if</span>都不成立，才会判断下面的<span class="keyword">else</span> <span class="keyword">if</span>。**  </span><br><span class="line">也就是说，上面的成立条件<span class="number">1</span>和<span class="number">2</span>同时满足，只会执行分支内容<span class="number">1</span>.  </span><br><span class="line">我们来写一段真正的代码:  </span><br><span class="line">```java</span><br><span class="line"><span class="keyword">int</span> score = <span class="number">59</span>;</span><br><span class="line"><span class="keyword">if</span>(score &lt; <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"奇怪的分数"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &lt; <span class="number">60</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"没及格"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &lt; <span class="number">80</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"及格了"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"优秀"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"输入不合法"</span>);</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">现在，改变参数来试试吧。  </span><br><span class="line"></span><br><span class="line">## switch...case</span><br><span class="line">这种分支结构的写法一般是:  </span><br><span class="line">```java</span><br><span class="line"><span class="comment">// 以下代码仅供展示，不能运行</span></span><br><span class="line"><span class="keyword">switch</span>(<span class="comment">/*参数*/</span>)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="comment">/*值1*/</span>:</span><br><span class="line"><span class="comment">/*内容1*/</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="comment">/*值2*/</span>:</span><br><span class="line"><span class="comment">/*内容2*/</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">/*内容3*/</span></span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">意思是在参数等于值<span class="number">1</span>时，执行内容<span class="number">1</span>，等于值<span class="number">2</span>时，执行内容<span class="number">2</span>，都不等于则执行内容<span class="number">3</span>.  </span><br><span class="line">在JDK <span class="number">1.7</span>之前，参数只能是<span class="keyword">byte</span>,<span class="keyword">short</span>,<span class="keyword">char</span>,<span class="keyword">int</span> <span class="number">4</span>种类型，</span><br><span class="line">而在JDK <span class="number">1.7</span>之后，String类型也可以用于<span class="keyword">switch</span>...<span class="keyword">case</span>...的参数。  </span><br><span class="line"></span><br><span class="line">在打<span class="number">10086</span>的时候，我们经常会听到:查询话费请按<span class="number">1</span>，流量套餐请按<span class="number">2</span>，人工服务请按<span class="number">0</span>.这种情况使用<span class="keyword">switch</span>...<span class="keyword">case</span>...就比较清晰了。试着动手写一下:  </span><br><span class="line">```java</span><br><span class="line"><span class="keyword">int</span> code = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(code)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">System.out.println(<span class="string">"查询话费"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">System.out.println(<span class="string">"流量套餐"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">System.out.println(<span class="string">"人工服务"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">"您的输入有误"</span>);</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">现在，修改**code**的值试一试吧。</span><br></pre></td></tr></table></figure></p><p>TIPS: break意为跳出的意思，我们下一节将会讲到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以试一下，如果代码去掉break，会发生什么情况:  </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">int code = 1;</span><br><span class="line">switch(code)&#123;</span><br><span class="line">case 1:</span><br><span class="line">System.out.println(&quot;查询话费&quot;);</span><br><span class="line">case 2:</span><br><span class="line">System.out.println(&quot;流量套餐&quot;);</span><br><span class="line">case 0:</span><br><span class="line">System.out.println(&quot;人工服务&quot;);</span><br><span class="line">default:</span><br><span class="line">System.out.println(&quot;您的输入有误&quot;);</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">结果发现，在上面的执行后，如果**case**内没有加**break**，将会顺延执行接下来的**case**。直到遇到**break**为止。</span><br><span class="line"></span><br><span class="line">## 三目运算符</span><br><span class="line">三目运算符是编程中唯一同时操作三个变量的运算符。它的格式如下:  </span><br><span class="line">```java</span><br><span class="line">/*条件*/ ? /*内容1*/ : /*内容2*/</span><br><span class="line">```  </span><br><span class="line">在上面的式子中，条件如果**成立**,则返回**内容1**,否则返回**内容2**.  </span><br><span class="line">我们可以看成是一个问句:</span><br></pre></td></tr></table></figure></p><p>条件成立吗?<br>成立 返回内容1 : 不成立 返回内容2  </p><pre><code>我们一起来看我开头举的那个例子:  ```javaboolean tomorrowRain = true;String carry =  tomorrowRain ? &quot;雨伞&quot; : &quot;墨镜&quot;;System.out.println(&quot;明天我要带上&quot; + carry);</code></pre><p>如果明天下雨(tomorrowRain = <strong>true</strong>),那么三目运算符会将<strong>雨伞</strong>返回给carry。下方输出<strong>明天我要带上雨伞</strong>.  </p>]]></content>
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java基础(六)基础运算符</title>
      <link href="/2018/09/05/java%E5%9F%BA%E7%A1%80-%E5%85%AD-%E5%9F%BA%E7%A1%80%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2018/09/05/java%E5%9F%BA%E7%A1%80-%E5%85%AD-%E5%9F%BA%E7%A1%80%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h2 id="基础运算符概览"><a href="#基础运算符概览" class="headerlink" title="基础运算符概览"></a>基础运算符概览</h2><p>本节主要讲解 <strong>+ - * / % = == &gt; &gt;= &lt; &lt;= !=</strong> 这几个基本的运算符。</p><a id="more"></a><h2 id="基础运算符详解"><a href="#基础运算符详解" class="headerlink" title="基础运算符详解"></a>基础运算符详解</h2><h3 id=""><a href="#" class="headerlink" title="+"></a>+</h3><p><strong>+</strong> 在等式两边都是基础类型时得到的是两边的和:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">1</span> + <span class="number">5</span>);<span class="comment">// 6</span></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">但是在等式两边有字符串的时候，**+**就会变成字符串连接符，将左右两边不是字符串的变量转换成字符串连接起来,得到一个字符串:</span><br><span class="line">  </span><br><span class="line">```java</span><br><span class="line">System.out.println(<span class="number">1</span> + <span class="string">"5"</span>);<span class="comment">// 15</span></span><br><span class="line">System.out.println(<span class="string">'1'</span> + <span class="string">"5"</span>);<span class="comment">// 15</span></span><br><span class="line">System.out.println(<span class="number">0.06</span> + <span class="string">"5"</span>);<span class="comment">// 0.065</span></span><br></pre></td></tr></table></figure></p><p>下面来看复杂一点的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">1</span> + <span class="number">2</span> + <span class="string">"3"</span>);<span class="comment">// 33</span></span><br><span class="line">System.out.println(<span class="number">1</span> + <span class="string">"2"</span> + <span class="number">3</span>);<span class="comment">// 123</span></span><br><span class="line">System.out.println(<span class="string">"1"</span> + <span class="number">2</span> + <span class="number">3</span>);<span class="comment">// 123</span></span><br><span class="line">System.out.println(<span class="string">""</span> + <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>);<span class="comment">// 123</span></span><br></pre></td></tr></table></figure></p><p>第一个算式中，<strong>1</strong>和<strong>2</strong>相加得到<strong>3</strong>,<strong>3</strong>与字符串<strong>“3”</strong>发生连接，得到字符串<strong>“33”</strong>。<br>第二个算式中，<strong>1</strong>和字符串<strong>“2”</strong>发生连接，得到字符串<strong>“12”</strong>，然后又和<strong>3</strong>发生连接，得到字符串<strong>“123”</strong>。<br>第三个算式中，字符串<strong>“1”</strong>和<strong>2</strong>发生连接，得到字符串<strong>“12”</strong>，然后又和<strong>3</strong>发生连接，得到字符串<strong>“123”</strong>。<br>第四个算式中，字符串<strong>“”</strong>和<strong>1</strong>发生连接，得到字符串<strong>“1”</strong>，然后又和<strong>2</strong>发生连接，得到字符串<strong>“12”</strong>，然后又和<strong>3</strong>发生连接，得到字符串<strong>“123”</strong>。  </p><h3 id="-1"><a href="#-1" class="headerlink" title="- * /"></a>- * /</h3><p><strong>- * /</strong> 的用法就是四则运算中的用法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">1</span> - <span class="number">2</span>); <span class="comment">// -1</span></span><br><span class="line">System.out.println(<span class="number">6</span> * <span class="number">6</span>); <span class="comment">// 36</span></span><br><span class="line">System.out.println(<span class="number">8</span> / <span class="number">4</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>但注意 <strong>/</strong> 在整型运算时，得到的是截掉小数位的整型:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">5</span> / <span class="number">3</span>); <span class="comment">// 1</span></span><br><span class="line">System.out.println(<span class="number">5</span>D / <span class="number">3</span>); <span class="comment">// 1.6666666666666667</span></span><br></pre></td></tr></table></figure></p><h3 id="-2"><a href="#-2" class="headerlink" title="%"></a>%</h3><p><strong>%</strong> 不仅在java，在许多语言都是<strong>取余</strong>的意思。意思就是被除数的整数位除以除数，除不尽的部分加上小数位的值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">9</span> % <span class="number">3</span>);<span class="comment">// 0</span></span><br><span class="line">System.out.println(<span class="number">5</span> % <span class="number">3</span>);<span class="comment">// 2</span></span><br><span class="line">System.out.println(<span class="number">5.5</span> % <span class="number">3</span>);<span class="comment">// 2.5</span></span><br></pre></td></tr></table></figure></p><h3 id="-3"><a href="#-3" class="headerlink" title="="></a>=</h3><p><strong>=</strong> 在语言中不是等于的意思，而是赋值的意思。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">a = b;</span><br><span class="line">System.out.println(a);<span class="comment">// 5</span></span><br><span class="line">System.out.println(b);<span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p><p>这句话的意思是，让a等于3，b等于5。然后让a等于b。所以最后a和b都为5。  </p><h3 id="-4"><a href="#-4" class="headerlink" title="=="></a>==</h3><p><strong>==</strong> 在语言中是判断等于的意思,返回一个boolean类型，相等是true,不相等是false<br><strong>但一定要注意，这个运算符只能判断基本类型是否相等</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">1</span> == <span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="number">1</span> == <span class="number">1.00</span>); <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">'1'</span> == <span class="number">1</span>); <span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="string">'a'</span> == <span class="number">97</span>);<span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">"a"</span> == <span class="string">"a"</span>);<span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><ul><li><p>第一个由于等式两边相等，所以返回true。  </p></li><li><p>第二个会自动转换成相同类型<strong>比较大小是否相等</strong>，此处返回true.  </p></li><li><p>第三个第四个我们在前一节说过，<strong>char</strong>类型是由<strong>Unicode</strong>编码构成的。<br>此处是将<strong>char</strong>类型转换成了自己对应的<strong>Unicode</strong>编码，由于<strong>‘1’</strong>的编码是<strong>49</strong>，所以不等于<strong>1</strong>；而<strong>‘a’</strong>的编码是<strong>97</strong>，所以返回相等。  </p></li><li><p>第五个是我们前面说过的，<strong>不是基本类型不能用==判断相等</strong>。<br>原因：不是基本类型的变量，里面存的并不是真正的值，而是指向值的地址。此处前面的<strong>“a”</strong>指向的是某个地址，而后面的<strong>“a”</strong>指向的是另一个地址。虽然地址里的值相等，但地址本身不相等。</p></li></ul><h3 id="gt-gt-lt-lt"><a href="#gt-gt-lt-lt" class="headerlink" title="&gt; &gt;= &lt; &lt;= !="></a>&gt; &gt;= &lt; &lt;= !=</h3><p>> >= &lt; &lt;= 和数学运算一致，表示大于，大于或等于，小于，小于或等于。<br>!= 表示不等于。<br>同样，这些操作符只能用于基本类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">5</span> &gt; <span class="number">4</span>);<span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="number">5</span> &gt;= <span class="number">4</span>);<span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="number">5</span> &lt; <span class="number">4</span>);<span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="number">5</span> &lt;= <span class="number">4</span>);<span class="comment">// false</span></span><br><span class="line">System.out.println(<span class="number">5</span> != <span class="number">4</span>);<span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h3 id="扩展阅读-舍入误差"><a href="#扩展阅读-舍入误差" class="headerlink" title="扩展阅读:舍入误差"></a>扩展阅读:舍入误差</h3><p>计算机语言在计算四则运算的时候，有的时候会丢失精度:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">0.05</span>+<span class="number">0.01</span>);<span class="comment">// 0.060000000000000005</span></span><br><span class="line">System.out.println(<span class="number">2.0</span>-<span class="number">1.1</span>);<span class="comment">// 0.8999999999999999</span></span><br></pre></td></tr></table></figure></p><p>这是由于计算机在处理四则运算的时候，都是将十进制数字转换成二进制来进行加减。而有的浮点数在转换为二进制时存在除不尽的现象。</p>]]></content>
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java基础(三)用eclipse写java</title>
      <link href="/2018/09/05/java%E5%9F%BA%E7%A1%80-%E4%B8%89-%E7%94%A8eclipse%E5%86%99java/"/>
      <url>/2018/09/05/java%E5%9F%BA%E7%A1%80-%E4%B8%89-%E7%94%A8eclipse%E5%86%99java/</url>
      <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>本节主要介绍如何在eclipse新建项目，包，类。<br>最后解释java项目结构如此复杂的原因。<br><a id="more"></a></p><h2 id="eclipse中新建项目"><a href="#eclipse中新建项目" class="headerlink" title="eclipse中新建项目"></a>eclipse中新建项目</h2><p>如果没有安装eclipse, 可以点击下面链接下载eclipse:<br><a href="https://www.eclipse.org/downloads/download.php?file=/oomph/epp/photon/R/eclipse-inst-win64.exe&mirror_id=105" target="blank">下载eclipse</a><br>安装好eclipse之后，进入到默认的工作空间。新建一个项目的流程是:  </p><ol><li>左上角  <strong>File –&gt; New –&gt; Project</strong>.  </li><li>弹框后选择  <strong>Java Project</strong>  ,点击<strong>next</strong>  </li><li>输入  <strong>您的项目名(此处全小写)</strong>  后项目新建成功。</li></ol><h2 id="eclipse新建包"><a href="#eclipse新建包" class="headerlink" title="eclipse新建包"></a>eclipse新建包</h2><ol><li>点击<strong>之前创建的项目</strong>, 发现项目下自动生成了<strong>JRE System Library</strong> 和 <strong>src</strong>.</li><li>右键点击 <strong>src</strong>，<strong>new –&gt; Package</strong>  </li><li>在Name处填写<strong>包名(此处全小写)</strong> 后包创建成功。</li></ol><h2 id="eclipse新建类"><a href="#eclipse新建类" class="headerlink" title="eclipse新建类"></a>eclipse新建类</h2><ol><li>右键点击<strong>之前创建的包</strong>,<strong>new –&gt; Class</strong></li><li>在Name处填写<strong>类名（此处所有单词首字母大写）</strong>后，类创建成功。</li></ol><h2 id="项目结构浅析"><a href="#项目结构浅析" class="headerlink" title="项目结构浅析"></a>项目结构浅析</h2><h3 id="为何有如此复杂的项目结构"><a href="#为何有如此复杂的项目结构" class="headerlink" title="为何有如此复杂的项目结构"></a>为何有如此复杂的项目结构</h3><p>初学java的同学可能对java复杂的层次感觉比较棘手。又是project，又是package，又是class，才能在里面写函数。<br>不过，这样的项目层次非常适用于现在的大型项目的开发。<br>试想，一个文件夹里，装着许多类似的文件，里面写着一个接一个的函数，这样要想梳理函数间的引用关系几乎是不可能的。  </p><h3 id="java的项目结构"><a href="#java的项目结构" class="headerlink" title="java的项目结构"></a>java的项目结构</h3><p>java的项目结构不同编辑器的梳理是不一样的：<br>eclipse的展示规则是 namespace –&gt; project –&gt; package –&gt; class<br>intellij的展示规则是 project –&gt; module –&gt; package –&gt; class<br>以eclipse中写一个聊天软件为例:  </p><ol><li>我们应该把整个聊天软件的文件存放在一个独立的工作空间(<strong>namespace</strong>)中，这样更有利于我们对项目整体进行把握。  </li><li>比如<strong>登录注册</strong>模块,<strong>数据存放</strong>模块,<strong>通信</strong>模块,<strong>界面展示</strong>模块等等，我们可以为他们分别单独创建一个项目(project)，这样，擅长界面展示的员工就可以只做界面展示，擅长通信模块的员工就可以只做通信。并且，如果以后做了微服务拆分，这些模块可以分别部署在服务器上，数据模块做了更新，只用重新编译数据模块，不会影响到其他模块。  </li><li>java一般以包(<strong>Package</strong>)为单位进行管理.在编译过后，java一般会将package的内容压缩成<strong>jar</strong>文件，要引用其他jar包中的内容，需要将jar包拷到相应位置，并在文件中注明。现在常见的也用Maven，Gradle等管理。</li><li>类(<strong>Class</strong>)是面向对象的基本单位。变量和函数是属于类的。这个在面向对象的介绍中详细介绍。</li></ol>]]></content>
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java基础(五)认识基本变量</title>
      <link href="/2018/09/05/java%E5%9F%BA%E7%A1%80-%E4%BA%94-%E8%AE%A4%E8%AF%86%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F/"/>
      <url>/2018/09/05/java%E5%9F%BA%E7%A1%80-%E4%BA%94-%E8%AE%A4%E8%AF%86%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>java 中一共有<strong>8</strong>种基本类型，分别是byte,short,int,long,float,double,char,boolean。</p><table><thead><tr><th style="text-align:center">关键字</th><th style="text-align:center">类型</th><th style="text-align:center">长度</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">字节型</td><td style="text-align:center">1个字节</td><td style="text-align:center">-128~127</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">短整型</td><td style="text-align:center">2个字节</td><td style="text-align:center">-2^15~2^15-1</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">整型</td><td style="text-align:center">4个字节</td><td style="text-align:center">-2^31~2^31-1</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">长整型</td><td style="text-align:center">8个字节</td><td style="text-align:center">-2^63~2^63-1</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">单精度浮点型</td><td style="text-align:center">4个字节</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">双精度浮点型</td><td style="text-align:center">8个字节</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">字符型</td><td style="text-align:center">2个字节</td><td style="text-align:center">0~65535</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">布尔型</td><td style="text-align:center">1个字节</td><td style="text-align:center">true false</td></tr></tbody></table><a id="more"></a><h2 id="直接量"><a href="#直接量" class="headerlink" title="直接量"></a>直接量</h2><p>声明一个基本类型变量和String 对象的时候，可以不用使用<strong>new</strong>,而采取直接量的方式。</p><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">直接量描述</th><th style="text-align:center">例子</th></tr></thead><tbody><tr><td style="text-align:center">byte/short/int</td><td style="text-align:center">整数直接量(可八,十,十六进制)</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">整数后加字母L</td><td style="text-align:center">12L</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">数字后加F</td><td style="text-align:center">3.5F</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">浮点型直接量，或在数字后加D</td><td style="text-align:center">0.12</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">布尔直接量</td><td style="text-align:center">true false</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">单引号包含的单个字符</td><td style="text-align:center">‘中’</td></tr><tr><td style="text-align:center">String</td><td style="text-align:center">双引号包含</td><td style="text-align:center">“中国”</td></tr><tr><td style="text-align:center">null</td><td style="text-align:center">引用类型的空指向</td><td style="text-align:center">null</td></tr></tbody></table><p>在方法中敲入下列代码试一下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> v1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">short</span> v2 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> v3 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> v4 = <span class="number">1L</span>;</span><br><span class="line"><span class="keyword">float</span> v5 = <span class="number">2.5F</span>;</span><br><span class="line"><span class="keyword">double</span> v6 = <span class="number">3.46</span>;</span><br><span class="line"><span class="keyword">boolean</span> v7 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">char</span> v8 = <span class="string">'中'</span>;</span><br><span class="line">String v9 = <span class="string">"中国"</span>;</span><br><span class="line">String v10 = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p><p>浮点型变量默认使用<strong>double</strong>存储，而不选用精度不够的<strong>float</strong>存储，所以在声明float的浮点直接量时要在后面接上<strong>F</strong>.<br>现在试试将上面的<strong>F</strong>去掉，编译应该会报错的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIPS：这类语法错误是无法通过编译的，所以叫编译错误。与之对应的是由参数引起的，在运行时才会产生的错误，叫做运行期错误。</span><br></pre></td></tr></table></figure></p><p>当然，L,F,D使用小写字母也是可以的，但是由于小写的l和1比较类似，所以一般采用大写。  </p><h2 id="基本类型间的强转"><a href="#基本类型间的强转" class="headerlink" title="基本类型间的强转"></a>基本类型间的强转</h2><p>除了boolean类型，其他7个类型都可以相互强转。语法如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> longValue = <span class="number">100L</span>;</span><br><span class="line"><span class="keyword">int</span> intValue = (<span class="keyword">int</span>) longValue;</span><br><span class="line">System.out.println(intValue);<span class="comment">// 100</span></span><br></pre></td></tr></table></figure></p><p>但有几点需要注意的地方:</p><h4 id="浮点型强转为整型时，会将小数点后的位数强制截掉。"><a href="#浮点型强转为整型时，会将小数点后的位数强制截掉。" class="headerlink" title="浮点型强转为整型时，会将小数点后的位数强制截掉。"></a>浮点型强转为整型时，会将小数点后的位数强制截掉。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> doubleValue = <span class="number">12.5</span>;</span><br><span class="line"><span class="keyword">int</span> intValue = (<span class="keyword">int</span>) doubleValue;</span><br><span class="line">System.out.println(intValue);<span class="comment">// 12</span></span><br></pre></td></tr></table></figure><h4 id="要转换的值大于当前类型最大-小值时，多出的部分会从另一个极端进行循环。"><a href="#要转换的值大于当前类型最大-小值时，多出的部分会从另一个极端进行循环。" class="headerlink" title="要转换的值大于当前类型最大/小值时，多出的部分会从另一个极端进行循环。"></a>要转换的值大于当前类型最大/小值时，多出的部分会从另一个极端进行循环。</h4><p>例如 2147483647 是 int的最大值:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> longValue = <span class="number">2147483647L</span>;</span><br><span class="line"><span class="keyword">int</span> intValue = (<span class="keyword">int</span>) longValue;</span><br><span class="line">System.out.println(intValue);<span class="comment">// 2147483647</span></span><br></pre></td></tr></table></figure></p><p>以上输出的是正常的。但是下面就不一样了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> longValue = <span class="number">2147483648L</span>;</span><br><span class="line"><span class="keyword">int</span> intValue = (<span class="keyword">int</span>) longValue;</span><br><span class="line">System.out.println(intValue); <span class="comment">//-2147483648</span></span><br></pre></td></tr></table></figure></p><p>byte/short在java中范围和int等同。所以不会出现小范围不停循环的问题。</p><h4 id="char字符默认用Unicode编码，如果将char强转为int，会得到它对应的unicode编码"><a href="#char字符默认用Unicode编码，如果将char强转为int，会得到它对应的unicode编码" class="headerlink" title="char字符默认用Unicode编码，如果将char强转为int，会得到它对应的unicode编码:"></a>char字符默认用Unicode编码，如果将char强转为int，会得到它对应的unicode编码:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> charValue = <span class="string">'中'</span>;</span><br><span class="line"><span class="keyword">int</span> intValue = (<span class="keyword">int</span>)charValue;</span><br><span class="line">System.out.println(intValue);<span class="comment">// 20013</span></span><br></pre></td></tr></table></figure><p>关于编码的更多知识可以看我的另一篇文章 编码的那些事儿。</p>]]></content>
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java基础(四)java的命名规范</title>
      <link href="/2018/09/05/java%E5%9F%BA%E7%A1%80-%E5%9B%9B-java%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
      <url>/2018/09/05/java%E5%9F%BA%E7%A1%80-%E5%9B%9B-java%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
      <content type="html"><![CDATA[<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>大到项目，小到变量，JAVA必须严格遵守命名规范，才能达到易读易用的的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、 项目名全部小写</span><br><span class="line">2、 包名全部小写</span><br><span class="line">3、 类名(大驼峰命名)</span><br><span class="line">如：public class MyFirstClass&#123;&#125;</span><br><span class="line">4、 变量名、方法名(小驼峰命名)</span><br><span class="line">如：int index=0;</span><br><span class="line">      public void toString()&#123;&#125;</span><br><span class="line">5、 静态常量命名(全大写,以下划线分割)</span><br><span class="line">如： public static String SOME_STATIC_VARIABLE = &quot;1&quot;;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="驼峰命名法"><a href="#驼峰命名法" class="headerlink" title="驼峰命名法"></a>驼峰命名法</h2><p><strong>大驼峰</strong>是指首字母<strong>大</strong>写，如果名称由多个单词组成，每个单词的<strong>首字母都要大写</strong>。<br><strong>小驼峰</strong>是指首字母<strong>小</strong>写，如果名称由多个单词组成，每个单词的<strong>首字母都要大写</strong>。<br>就像驼峰一样，中间重要的部分凸起，以区分冗长的句子。</p><h2 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h2><p>变量除了应遵循小驼峰命名规范外，还应该遵循以下几点规则：  </p><ol><li>不可以<strong>数字开头</strong>。(编译会报错)  </li><li>不可以使用除下划线<strong>_</strong>和美元符<strong>$</strong>以外的符号。(编译会报错)  </li><li>不可以使用<strong>JAVA关键字</strong>。(编译会报错)  </li><li>避免使用<strong>中文</strong>。  </li><li>避免使用<strong>不知义</strong>的变量（如 a,b,c）。  </li><li>避免使用<strong>15字以上</strong>的变量。  </li></ol><h2 id="JAVA关键字一览"><a href="#JAVA关键字一览" class="headerlink" title="JAVA关键字一览"></a>JAVA关键字一览</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">访问控制</span><br><span class="line">private    protected    public</span><br><span class="line"></span><br><span class="line">类,方法和变量修饰符</span><br><span class="line">abstract    class    extends    final    implements    interface    native    new</span><br><span class="line">static    strictfp    synchronized    transient    volatile</span><br><span class="line">    </span><br><span class="line">程序控制</span><br><span class="line">break    continue    return    do    while    if    else    for    instanceof    switch</span><br><span class="line">case    default</span><br><span class="line">    </span><br><span class="line">异常处理</span><br><span class="line">try    cathc    throw    throws</span><br><span class="line"></span><br><span class="line">包相关</span><br><span class="line">import    package</span><br><span class="line">    </span><br><span class="line">基本类型</span><br><span class="line">boolean    byte    char    double    float    int    long    short    null    true    false</span><br><span class="line"></span><br><span class="line">变量引用</span><br><span class="line">super    this    void</span><br><span class="line">    </span><br><span class="line">保留字</span><br><span class="line">goto    const</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java基础(二)手动编译运行一个java文件</title>
      <link href="/2018/09/05/java%E5%9F%BA%E7%A1%80-%E4%BA%8C-%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AAjava%E6%96%87%E4%BB%B6/"/>
      <url>/2018/09/05/java%E5%9F%BA%E7%A1%80-%E4%BA%8C-%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AAjava%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h2 id="java运行原理"><a href="#java运行原理" class="headerlink" title="java运行原理"></a>java运行原理</h2><p>我们在编辑C语言等编译语言时,编译文件在不同的系统是不能互通的。比如，在Windows编译后的文件，在Linux上是不能直接使用的。这对于编译需要大量时间的大型项目是比较麻烦的。<br>而java会先有JDK的编译器将.java源码文件编译成.class文件。而在不同系统上由对应的JRE运行，这样只要系统内装有JRE，不管是什么系统，都可以运行同一份.class文件了。<br><img src="http://www.ashasean.cn/blog-image/JAVAcompile1.png" alt="JAVA一次编译示意图"><br>我们来试一下手动编译运行一个java文件。<br><a id="more"></a></p><h2 id="编译运行JAVA文件"><a href="#编译运行JAVA文件" class="headerlink" title="编译运行JAVA文件"></a>编译运行JAVA文件</h2><ol><li>在桌面上新建HelloWorld.java. 这是java的源文件:<br><img src="http://www.ashasean.cn/blog-image/JAVAcompile2.png" alt="JAVA一次编译示意图">    </li><li><p>用文本编辑器打开文件，填写内容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>保存后,打开cmd窗口: （前面是当前路径。默认是在当前用户的文件夹下.）<br><img src="http://www.ashasean.cn/blog-image/JAVAcompile3.png" alt="JAVA一次编译示意图">    </p></li><li>输入dir可以查看当前文件夹下的文件：<br><img src="http://www.ashasean.cn/blog-image/JAVAcompile4.png" alt="JAVA一次编译示意图">  </li><li>我们可以看到，里面有个Desktop的文件夹。进入该文件夹，使用cd 命令:<br><img src="http://www.ashasean.cn/blog-image/JAVAcompile5.png" alt="JAVA一次编译示意图">    </li><li>此时我们调用javac命令，使用JDK的编译器将.java文件编译成.class文件:<br><img src="http://www.ashasean.cn/blog-image/JAVAcompile6.png" alt="JAVA一次编译示意图">    </li><li>编译完成后，桌面多了.class文件:<br><img src="http://www.ashasean.cn/blog-image/JAVAcompile7.png" alt="JAVA一次编译示意图">  </li><li>使用java命令，就可以输出Hello World了:<br><img src="http://www.ashasean.cn/blog-image/JAVAcompile8.png" alt="JAVA一次编译示意图">  </li></ol><h2 id="java运行环境探索"><a href="#java运行环境探索" class="headerlink" title="java运行环境探索"></a>java运行环境探索</h2><p>我们之前安装的JDK大抵结构如下:<br><img src="http://www.ashasean.cn/blog-image/JAVAcompile9.png" alt="JAVA一次编译示意图">  </p><table><thead><tr><th style="text-align:center">模块</th><th style="text-align:center">全称</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">JVM</td><td style="text-align:center">Java virtual machine (java虚拟机)</td><td style="text-align:center">每个系统的虚拟机不同。负责将.class文件转换成系统可识别的文件。</td></tr><tr><td style="text-align:center">JRE</td><td style="text-align:center">Java Runtime Environment (java 运行环境)</td><td style="text-align:center">java运行环境，包括核心库等。</td></tr><tr><td style="text-align:center">JDK</td><td style="text-align:center">Java Develop Kit（java 开发包）</td><td style="text-align:center">包含编译器，调试器。</td></tr></tbody></table><p><strong>JRE</strong>已经提供了完整的java运行环境.客户的电脑上或者服务器上只用安装JRE来运行开发人员打包的.class文件即可。<br>而<strong>JDK</strong>提供了编译器等开发工具，使用javac命令可以将源码编译成.class文件。</p>]]></content>
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java基础(一)环境变量配置</title>
      <link href="/2018/09/05/java%E5%9F%BA%E7%A1%80-%E4%B8%80-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/09/05/java%E5%9F%BA%E7%A1%80-%E4%B8%80-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>要想成为一个java开发者，必须搭建开发java的环境。一共可以分为两步：  </p><ol><li>下载安装JDK  </li><li>配置环境变量  <a id="more"></a></li></ol><h2 id="下载安装JDK"><a href="#下载安装JDK" class="headerlink" title="下载安装JDK"></a>下载安装JDK</h2><h3 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h3><p>点击下面网址进入到JDK下载页面:<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank">JDK下载</a><br>在页面中选择<strong>JDK下载</strong>,如下图所示:<br><img src="http://www.ashasean.cn/blog-image/JDKchose1.png" alt="JDK下载"><br>进入后，找到下方JDK的下载部分:  </p><ol><li>点击<strong>Accept License Agreement</strong> –同意许可证书  </li><li>点击<strong>对应你操作系统</strong>的选项，如果是Windows用户就点选Windows开头的，苹果系统点选Mac开头的.<br><img src="http://www.ashasean.cn/blog-image/JDKchose2.png" alt="操作系统选择">  </li></ol><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><ol><li>打开下载后的JDK,点击<strong>下一步</strong>，进入如下页面:<br><img src="http://www.ashasean.cn/blog-image/jdkinstall1.png" alt="JDK安装">  </li><li>如图点击<strong>设置</strong>,在<strong>E</strong>盘下新建文件夹<strong>java</strong>,再新建文件夹<strong>jdk</strong>,选择该文件夹，点击确定.请保证左侧路径和我的完全一致后,点击<strong>下一步</strong>自动安装。  </li><li>安装完成后会弹出<strong>Java</strong>安装的提示框,其实是安装我们的JAVA运行环境<strong>JRE</strong>,为保证路径和我一致，请打开刚刚新建的<strong>jdk</strong>,新建<strong>jre</strong>文件夹。并将jre安装在该目录下。  </li><li><strong>注意:</strong> 你也可以选择和我不一样的安装路径。但一般安装路径下<strong>不要含有中文</strong>，以免出现编码错误等问题。并且如果选择了不同的安装路径，那么下面配置环境变量的时候，请在系统变量<strong>Path</strong>下填写自己的<strong>jdk</strong>和<strong>jre</strong>路径下的<strong>bin</strong>文件夹的路径。</li></ol><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><ol><li>右键点击<strong>我的电脑</strong>,选择<strong>属性</strong>:<br><img src="http://www.ashasean.cn/blog-image/javaenvironment1.png" alt="JAVA环境配置">  </li><li>点击<strong>高级系统设置</strong>:<br><img src="http://www.ashasean.cn/blog-image/javaenvironment2.png" alt="JAVA环境配置">  </li><li>上方选择<strong>高级</strong>, 下方点击<strong>环境变量</strong>:<br><img src="http://www.ashasean.cn/blog-image/javaenvironment3.png" alt="JAVA环境配置">  </li><li>点击下方<strong>新建</strong>,变量名填写<strong>JAVA_HOME</strong>,变量值填写<strong>你的JDK安装路径</strong>.(这个路径下一定会有名叫<strong>bin</strong>的文件夹,请确认后填写)。<br><img src="http://www.ashasean.cn/blog-image/javaenvironment4.png" alt="JAVA环境配置">  </li><li>然后同样在系统变量里找到 <strong>Path</strong>, 按照如图填写JDK和JRE下的bin路径即可。（如果你的JRE路径和我配置的不一样，第二栏可以直接填写JRE的路径).<br><img src="http://www.ashasean.cn/blog-image/javaenvironment5.png" alt="JAVA环境配置">  </li></ol><h2 id="检测安装结果"><a href="#检测安装结果" class="headerlink" title="检测安装结果"></a>检测安装结果</h2><h3 id="正确情况"><a href="#正确情况" class="headerlink" title="正确情况"></a>正确情况</h3><p>以上java的开发环境就配置完成了。我们可以检验一下。按<strong>Win</strong> + <strong>R</strong>弹出运行框,输入<strong>cmd</strong>，敲回车:<br><img src="http://www.ashasean.cn/blog-image/javacheck1.png" alt="JAVA检测结果"><br>依次输入 <strong>java -version</strong> 、 <strong>javac</strong>,结果和我一样，配置就成功了。<br><img src="http://www.ashasean.cn/blog-image/javacheck2.png" alt="JAVA检测结果"> </p><h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><h4 id="Error-could-not-find-java-dll-Error-Could-not-find-Java-SE-Runtime-Environment"><a href="#Error-could-not-find-java-dll-Error-Could-not-find-Java-SE-Runtime-Environment" class="headerlink" title="Error: could not find java.dll / Error: Could not find Java SE Runtime Environment"></a>Error: could not find java.dll / Error: Could not find Java SE Runtime Environment</h4><p>这种情况是JRE安装错误。回到官网重新安装JRE即可。</p><h4 id="’javac’-不是内部或外部命令，也不是可运行的程序"><a href="#’javac’-不是内部或外部命令，也不是可运行的程序" class="headerlink" title="’javac’ 不是内部或外部命令，也不是可运行的程序"></a>’javac’ 不是内部或外部命令，也不是可运行的程序</h4><p>这种情况是JDK环境变量配置错误。请再次确认Path中有没有JDK下bin文件夹的目录。  </p><h2 id="环境变量答疑"><a href="#环境变量答疑" class="headerlink" title="环境变量答疑"></a>环境变量答疑</h2><p>学习过C语言的同学初学JAVA,都会产生疑问，为什么C语言不需要配置环境变量，而JAVA需要？<br>因为系统默认提供了C的编译器，所以C语言可以直接编译运行。<br>而java无论是编译还是运行，都需要调用java 、javac这些非默认系统指令。系统则需要在环境变量中寻找对应指令进行操作。<br>不仅仅是JAVA, Python, Golang等语言也需要配置环境变量。</p>]]></content>
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>工具类(一)反射类InvokeUtil</title>
      <link href="/2018/08/21/%E5%B7%A5%E5%85%B7%E7%B1%BB-%E4%B8%80-%E5%8F%8D%E5%B0%84%E7%B1%BBInvokeUtil/"/>
      <url>/2018/08/21/%E5%B7%A5%E5%85%B7%E7%B1%BB-%E4%B8%80-%E5%8F%8D%E5%B0%84%E7%B1%BBInvokeUtil/</url>
      <content type="html"><![CDATA[<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><h3 id="过滤器中使用"><a href="#过滤器中使用" class="headerlink" title="过滤器中使用"></a>过滤器中使用</h3><p>复杂的业务环境下,我们可能会需要在过滤器中对前台或其他接口传过来的参数做统一处理.比如日期格式处理,千分位转换,排序等.<br>方法处理的对象可能是各种各样的, 但对应的属性和方法是通用的.这种时候我们一般有两种办法:  </p><pre><code>1. 为这些对象封装统一的接口,通过转换成接口进行统一处理.  2. 使用反射,根据属性信息进行处理.</code></pre><p>第一种方法一般用在类似排序处理这样功能清晰的情况下使用.<br>比起第二种方法,第一种方法能使代码结构更清晰,同时效率也会高一些.  </p><p>但面对二次开发或者需求变更的时候,大量代码已经完成.这时候采用第一种方法将会消耗极大的人力.<br>在类似日期格式处理这样,需要处理的属性名不统一的情况,也不方便采用第一种方法(<strong>这时可以采用反射并使用注解</strong>).  </p><h3 id="业务中使用"><a href="#业务中使用" class="headerlink" title="业务中使用"></a>业务中使用</h3><p>在业务环境中,我们可能会有需要将一组配置类根据某个属性值转换成一个map,然后数据类从中快速取到需要的配置.<br>这时也可以采用反射类中<strong>CollectionToMap</strong>方法.<br><a id="more"></a></p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得实体属性的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getFieldValue</span><span class="params">(Object object, String fieldName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getFieldValue(object, fieldName, object.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">getFieldValue</span><span class="params">(Object object, String fieldName, Class clazz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = clazz.getDeclaredField(fieldName);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> field.get(object);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> getFieldValue(object, fieldName, clazz.getSuperclass());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将变量为T的list,按照field的值提取为map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> collection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> field</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">collectionToMap</span><span class="params">(Collection&lt;T&gt; collection, String field)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, T&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(collection)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (T t : collection) &#123;</span><br><span class="line">            Object value = getFieldValue(t, field);</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (String.class.isAssignableFrom(value.getClass())) &#123;</span><br><span class="line">                    String valStr = (String) value;</span><br><span class="line">                    map.put(valStr, t);</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    String valStr = String.valueOf(value);</span><br><span class="line">                    map.put(valStr, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得类中所有属性(包含父类的属性)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Field&gt; <span class="title">getAllFields</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Object.class.equals(clazz) || clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取本类中的所有属性（private/public/protected/default）</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        List&lt;Field&gt; fieldList  = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(fields));</span><br><span class="line">        fieldList.addAll(getAllFields(clazz.getSuperclass()));</span><br><span class="line">        <span class="keyword">return</span> fieldList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得类的所有方法(包含父类的方法)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Method&gt; <span class="title">getAllMethods</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Object.class.equals(clazz) || clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取本类中的所有属性（private/public/protected/default）</span></span><br><span class="line">            Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">            List&lt;Method&gt; methodList= <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(methods));</span><br><span class="line">            methodList.addAll(getAllMethods(clazz.getSuperclass()));</span><br><span class="line">            <span class="keyword">return</span> methodList;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 方法的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">invoke</span><span class="params">(Object obj, Method m, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m.invoke(obj, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeUtilTest</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">animal</span></span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String phone;</span><br><span class="line">        <span class="keyword">private</span> String hobby;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> phone;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.phone = phone;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getHobby</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hobby;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHobby</span><span class="params">(String hobby)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.hobby = hobby;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="keyword">super</span>.name + <span class="string">" is eating"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Person(String name, String phone, String hobby) &#123;</span><br><span class="line">            <span class="keyword">super</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.phone = phone;</span><br><span class="line">            <span class="keyword">this</span>.hobby = hobby;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                    <span class="string">"name='"</span> + <span class="keyword">super</span>.name + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">", phone='"</span> + phone + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">", hobby='"</span> + hobby + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetFieldValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"tom"</span>, <span class="string">"1312"</span>, <span class="string">"basketball"</span>);</span><br><span class="line">        <span class="comment">// tom</span></span><br><span class="line">        String name = String.valueOf(InvokeUtil.getFieldValue(person, <span class="string">"name"</span>));</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListToMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"tom"</span>, <span class="string">"1312"</span>, <span class="string">"basketball"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"jerry"</span>, <span class="string">"13123"</span>, <span class="string">"football"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"mickey"</span>, <span class="string">"131234"</span>, <span class="string">"baseball"</span>));</span><br><span class="line">        Map&lt;String,Person&gt; namePersonMap = InvokeUtil.collectionToMap(personList, <span class="string">"name"</span>);</span><br><span class="line">        <span class="comment">// &#123;tom=Person&#123;name='tom', phone='1312', hobby='basketball'&#125;,</span></span><br><span class="line">        <span class="comment">//  jerry=Person&#123;name='jerry', phone='13123', hobby='football'&#125;,</span></span><br><span class="line">        <span class="comment">//  mickey=Person&#123;name='mickey', phone='131234', hobby='baseball'&#125;&#125;</span></span><br><span class="line">        System.out.println(namePersonMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetAllFields</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Field&gt; fields = InvokeUtil.getAllFields(Person.class);</span><br><span class="line">        <span class="comment">// [private java.lang.String main.util.InvokeUtilTest$Person.phone,</span></span><br><span class="line">        <span class="comment">// private java.lang.String main.util.InvokeUtilTest$Person.hobby,</span></span><br><span class="line">        <span class="comment">// final main.util.InvokeUtilTest main.util.InvokeUtilTest$Person.this$0,</span></span><br><span class="line">        <span class="comment">// protected java.lang.String main.util.InvokeUtilTest$animal.name,</span></span><br><span class="line">        <span class="comment">// final main.util.InvokeUtilTest main.util.InvokeUtilTest$animal.this$0]</span></span><br><span class="line">            System.out.println(fields);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetAllMethods</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Method&gt; methods = InvokeUtil.getAllMethods(Person.class);</span><br><span class="line">        <span class="comment">// [public java.lang.String main.util.InvokeUtilTest$Person.toString(),</span></span><br><span class="line">        <span class="comment">// public void main.util.InvokeUtilTest$Person.setPhone(java.lang.String),</span></span><br><span class="line">        <span class="comment">// public java.lang.String main.util.InvokeUtilTest$Person.getPhone(),</span></span><br><span class="line">        <span class="comment">// public java.lang.String main.util.InvokeUtilTest$Person.getHobby(),</span></span><br><span class="line">        <span class="comment">// public void main.util.InvokeUtilTest$Person.eat(),</span></span><br><span class="line">        <span class="comment">// public void main.util.InvokeUtilTest$Person.setHobby(java.lang.String),</span></span><br><span class="line">        <span class="comment">// public java.lang.String main.util.InvokeUtilTest$animal.getName(),</span></span><br><span class="line">        <span class="comment">// public void main.util.InvokeUtilTest$animal.setName(java.lang.String)]</span></span><br><span class="line">        System.out.println(methods);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 工具类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cmd和shell指令对比(三):进程操作</title>
      <link href="/2018/08/17/cmd%E5%92%8Cshell%E6%8C%87%E4%BB%A4%E5%AF%B9%E6%AF%94-%E4%B8%89-%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/08/17/cmd%E5%92%8Cshell%E6%8C%87%E4%BB%A4%E5%AF%B9%E6%AF%94-%E4%B8%89-%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h2 id="命令速览"><a href="#命令速览" class="headerlink" title="命令速览"></a>命令速览</h2><p><table><br>    <tr><br>        <th>目的</th><br>        <th>linux</th><br>        <th>windows</th><br>    </tr><br>    <tr><br>        <td>查看内存占用状态</td><br>        <td>top</td><br>        <td>tasklist</td><br>    </tr><br>    <tr><br>        <td>检测端口占用</td><br>        <td>netstat -tunlp| grep <strong>[端口号]</strong></td><br>        <td>netstat -ano | findstr <strong>[端口号]</strong></td><br>    </tr><br>    <tr><br>        <td>通过PID查看进程名</td><br>        <td>ps -aux | grep -v grep | grep <strong>[PID]</strong></td><br>        <td>tasklist | findstr <strong>[PID]</strong></td><br>    </tr><br>    <tr><br>        <td>通过PID停止进程</td><br>        <td>kill -999 <strong>[PID]</strong></td><br>        <td>taskkill /PID <strong>[PID]</strong></td><br>    </tr><br></table><br><a id="more"></a></p><h2 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h2><p>PID(port ID),即系统为端口指定的唯一ID.</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>分析刚才的命令,我们可以看到在检测端口占用,查看具体进程时,都用到了<strong>[|]</strong>符号,这个符号叫做管道.<br>管道(pipe)是在cmd和shell下通用的一个操作符.它的作用是将前面命令得到的结果用于后面的输入.<br>比如shell中 ps -aux | grep <strong>[字符串]</strong>,在管道 <strong>|</strong> 前 <strong>ps -aux</strong>的含义如下:</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">ps(Process Status)</td><td style="text-align:center">提供了一次性查看进程状态的方法.</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">显示其他用户启动的进程</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">查看属于自己的进程</td></tr><tr><td style="text-align:center">u</td><td style="text-align:center">启动进程的用户和启动的时间</td></tr></tbody></table><p>也就是说,<strong>ps -aux</strong> 会显示当前系统中所有进程的信息.<br>而 <strong>grep</strong>(global search regular expression and print out the line) 的意思是全局搜索符合输入正则,并将该行打印出来.<br>所以 ps -aux | grep [“端口号”]连起来就是:<br>    将当前系统中所有进程的信息通过管道传送给grep,在其中找到符合端口号的行,打印出来.</p>]]></content>
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmd </tag>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cmd和shell指令对比(二):文件操作</title>
      <link href="/2018/08/17/cmd%E5%92%8Cshell%E6%8C%87%E4%BB%A4%E5%AF%B9%E6%AF%94-%E4%BA%8C-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/08/17/cmd%E5%92%8Cshell%E6%8C%87%E4%BB%A4%E5%AF%B9%E6%AF%94-%E4%BA%8C-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h2 id="命令速览"><a href="#命令速览" class="headerlink" title="命令速览"></a>命令速览</h2><table><thead><tr><th style="text-align:center">目的</th><th style="text-align:center">linux</th><th style="text-align:center">windows</th></tr></thead><tbody><tr><td style="text-align:center">复制文件</td><td style="text-align:center">cp <strong>[源文件]</strong> <strong>[目标文件]</strong></td><td style="text-align:center">copy <strong>[源文件]</strong> <strong>[目标文件]</strong></td></tr><tr><td style="text-align:center">移动文件</td><td style="text-align:center">mv <strong>[源文件]</strong> <strong>[目标文件]</strong></td><td style="text-align:center">move <strong>[源文件]</strong> <strong>[目标文件]</strong></td></tr><tr><td style="text-align:center">删除文件</td><td style="text-align:center">rm <strong>[文件名]</strong></td><td style="text-align:center">rd /s /q <strong>[文件名]</strong></td></tr><tr><td style="text-align:center">新建文件夹</td><td style="text-align:center">mkdir <strong>[文件夹名]</strong></td><td style="text-align:center">mkdir <strong>[文件夹名]</strong></td></tr><tr><td style="text-align:center">新建文件</td><td style="text-align:center">touch <strong>[文件]</strong></td><td style="text-align:center">edit <strong>[文件]</strong></td></tr><tr><td style="text-align:center">写入文件</td><td style="text-align:center">echo <strong>[内容]</strong> &gt; <strong>[目标文件]</strong></td><td style="text-align:center">echo <strong>[内容]</strong> &gt; <strong>[目标文件]</strong></td></tr><tr><td style="text-align:center">追加文件</td><td style="text-align:center">echo <strong>[内容]</strong> &gt;&gt; <strong>[目标文件]</strong></td><td style="text-align:center">echo <strong>[内容]</strong> &gt;&gt; <strong>[目标文件]</strong></td></tr></tbody></table><a id="more"></a><h2 id="重定向操作符"><a href="#重定向操作符" class="headerlink" title="重定向操作符"></a>重定向操作符</h2><p>在cmd 和 shell 中都有 重定向操作符.<br><strong>></strong> 是指的将前面的输出写入文件,如果文件中有内容,将会清空原来的文件内容.<br><strong>>></strong> 是指的将前面的输出追加到文件后部.<br>所以,在linux服务器上,某个文件比较大,我们希望清空文件内容但不删除时,可以采用:<br>echo ‘’ &gt; <strong>[文件名]</strong></p>]]></content>
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmd - shell - linux - 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cmd和shell指令对比(一):路径操作</title>
      <link href="/2018/08/17/cmd%E5%92%8Cshell%E6%8C%87%E4%BB%A4%E5%AF%B9%E6%AF%94-%E4%B8%80-%E8%B7%AF%E5%BE%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/08/17/cmd%E5%92%8Cshell%E6%8C%87%E4%BB%A4%E5%AF%B9%E6%AF%94-%E4%B8%80-%E8%B7%AF%E5%BE%84%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h2 id="命令速览"><a href="#命令速览" class="headerlink" title="命令速览"></a>命令速览</h2><table><thead><tr><th style="text-align:center">目的</th><th style="text-align:center">linux</th><th style="text-align:center">windows</th></tr></thead><tbody><tr><td style="text-align:center">显示当前路径</td><td style="text-align:center">pwd(Print Working Directory)</td><td style="text-align:center">echo on 状态下自动显示</td></tr><tr><td style="text-align:center">打开目录/更改目录</td><td style="text-align:center">cd <strong>[目录名]</strong></td><td style="text-align:center">cd <strong>[目录名]</strong></td></tr><tr><td style="text-align:center">展示当前目录下的文件</td><td style="text-align:center">ls</td><td style="text-align:center">dir</td></tr><tr><td style="text-align:center">打开文件</td><td style="text-align:center">vi <strong>[文件名]</strong></td><td style="text-align:center">start <strong>[文件名]</strong></td></tr></tbody></table><a id="more"></a><h2 id="cmd中切换盘符"><a href="#cmd中切换盘符" class="headerlink" title="cmd中切换盘符"></a>cmd中切换盘符</h2><p>当我们打开命令提示符时,当前目录默认停留在打开的bat文件所在的盘符.<br>如果是输入cmd打开命令提示符,一般停留在当前用户目录(C:\Users\[UserName]).<br>我们可以直接输入<strong>start + 绝对路径</strong>等指令去打开目标文件.<br>但使用cd切换目录时,我们发现是无法成功的.<br>这时我们可以直接输入<strong>[盘符]:</strong>来切换盘符.<br>如<strong>切换E盘</strong>:<br><strong>E:</strong></p><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><h3 id="cmd-下的echo-用法"><a href="#cmd-下的echo-用法" class="headerlink" title="cmd 下的echo 用法:"></a>cmd 下的echo 用法:</h3><table><thead><tr><th style="text-align:center">用法</th><th style="text-align:center">命令</th></tr></thead><tbody><tr><td style="text-align:center">当前windows的echo状态</td><td style="text-align:center">echo</td></tr><tr><td style="text-align:center">打开/关闭系统echo</td><td style="text-align:center">echo on/off</td></tr><tr><td style="text-align:center">输出字符串</td><td style="text-align:center">echo <strong>[字符串]</strong></td></tr></tbody></table><p>在cmd中,echo会自动在命令行前打印当前工作路径.如果不想显示,可以使用 <strong>echo off</strong>来关闭.</p><h3 id="shell-中的echo-用法"><a href="#shell-中的echo-用法" class="headerlink" title="shell 中的echo 用法:"></a>shell 中的echo 用法:</h3><p>shell中的echo也用来输出字符串.不同的是:  </p><ol><li>shell中的echo,会将单引号’’和双引号””<strong>自动转义</strong>,将其中的内容作为实际输出的字符串.  </li><li>shell中的echo,可以通过添加 -e,来实现转义字符输出.</li></ol>]]></content>
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmd </tag>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javascript深入理解(二):prototype原型</title>
      <link href="/2018/07/22/javascript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-%E4%BA%8C-Object%E5%B1%9E%E6%80%A7%E5%92%8Cprototype%E5%8E%9F%E5%9E%8B/"/>
      <url>/2018/07/22/javascript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-%E4%BA%8C-Object%E5%B1%9E%E6%80%A7%E5%92%8Cprototype%E5%8E%9F%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="带着问题阅读"><a href="#带着问题阅读" class="headerlink" title="带着问题阅读"></a>带着问题阅读</h2><ol><li>js是怎样调用属性的,prototype是什么,了解它有什么作用?</li><li>Object对象有哪些默认属性?</li><li>如何操作对象的属性?</li></ol><a id="more"></a><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>要知道js调用属性的过程,我们需要从<strong>构造器</strong>说起.<br>我们打开chrome浏览器,输入下面这串代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Duck</span>(<span class="params">name, swimming</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.swimming = swimming;</span><br><span class="line">&#125;</span><br><span class="line">Duck.prototype</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">constructor: f Duck(name, swimming)...</span></span><br><span class="line"><span class="comment">__proto__: ...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>我们可以看到,我们新声明的Duck方法,它的prototype是一个对象,里面有两个对象属性,constructor 和 __proto__.</p><p>点开constructor,结构如下图:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>:ƒ Duck(name, swimming)</span><br><span class="line">// 传入参数</span><br><span class="line">arguments: null</span><br><span class="line">// 调用方法</span><br><span class="line">caller: null</span><br><span class="line">// 参数长度</span><br><span class="line">length: 2</span><br><span class="line">// 方法名</span><br><span class="line">name: "Duck"</span><br><span class="line">// 原型</span><br><span class="line">__proto__</span><br></pre></td></tr></table></figure></p><p>新声明的<strong>function</strong>,默认带有<strong>constructor</strong>变量,可以使用<strong>new</strong>来给变量赋值.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> duck = <span class="keyword">new</span> Duck(<span class="string">"Donald"</span>);</span><br><span class="line">duck.constructor; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ƒ Duck(name, swimming)&#123;</span></span><br><span class="line"><span class="comment">this.name = name;</span></span><br><span class="line"><span class="comment">this.swimming = swimming;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>我们输出变量的constructor,会发现指向的就是我们的构造器方法.<br>那么prototype里的另一个属性:__proto__又是什么呢?</p><h2 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h2><p>在js中,每一个对象都会有这个__proto__对象,并且它是不可变的:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">duck.__proto__ = <span class="number">1</span>;</span><br><span class="line">duck.__proto__ <span class="comment">//&#123;constructor: ƒ...&#125;</span></span><br></pre></td></tr></table></figure></p><p>点开duck 的 __proto__,我们会发现和Duck里是一样的.接着再点击Duck的__proto__,<br>我们会得到如下对象:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__proto__:</span><br><span class="line"><span class="keyword">constructor</span>:ƒ Object()</span><br><span class="line">hasOwnProperty:ƒ hasOwnProperty()</span><br><span class="line">isPrototypeOf:ƒ isPrototypeOf()</span><br><span class="line">propertyIsEnumerable:ƒ propertyIsEnumerable()</span><br><span class="line">toLocaleString:ƒ toLocaleString()</span><br><span class="line">toString:ƒ toString()</span><br><span class="line">valueOf:ƒ valueOf()</span><br><span class="line">__defineGetter__:ƒ __defineGetter__()</span><br><span class="line">__defineSetter__:ƒ __defineSetter__()</span><br><span class="line">__lookupGetter__:ƒ __lookupGetter__()</span><br><span class="line">__lookupSetter__:ƒ __lookupSetter__()</span><br><span class="line">get __proto__:ƒ __proto__()</span><br><span class="line">set __proto__:ƒ __proto__()</span><br></pre></td></tr></table></figure></p><p>这一长串属性就是Object的基本属性.是我们所有声明对象共有的属性.而在Object里面,我们找不到__proto__这个属性了.<br>其实__proto__里输出的就是这个对象当前带有的属性,并且除了Object,对象对应的__proto__里还会包含一个__proto__,当中包含这个对象父类的属性.</p><h2 id="js是怎样调用属性的-原型链"><a href="#js是怎样调用属性的-原型链" class="headerlink" title="js是怎样调用属性的(原型链)"></a>js是怎样调用属性的(原型链)</h2><p>也就是说,他们之间的关系是:<br>引用(duck) — __proto__ —&gt; Duck — __proto__ —&gt; Object<br>这就是一条原型链.<br>我们在调用duck的属性时,会首先寻找duck有没有定义该属性,然后寻找它的原型Duck有没有定义该属性,然后再依次向上推Duck的原型,直到推到所有对象的最底层原型Object.</p><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>刚刚我们说过,在调用duck的属性时,若找不到duck相应的属性,会到它的原型Duck中寻找,但我们之前并没有为Duck提供任意的方法,它只有默认的constructor和__proto__.<br>那么,我们怎么样做,才能为Duck提供一个属性,让所有Duck对象都能调用到它的属性呢,答案就是prototype.js中,每一个使用function声明的方法,都会带有prototype这个属性.<br>我们只要为prototype添加相应的属性,对象在取Duck属性时,就会取prototype中的对应属性.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Duck.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Duck "</span>+ <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">duck + <span class="string">""</span>; <span class="comment">// Duck Donald</span></span><br></pre></td></tr></table></figure></p><p>以上重写了所有Duck对象的toString 方法,如果duck没有重写toString方法,那么都会toString 方法会默认输出”Duck”加上对象名.</p><h2 id="Object-常用属性详解"><a href="#Object-常用属性详解" class="headerlink" title="Object 常用属性详解"></a>Object 常用属性详解</h2><h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h3><p>传入一个字符串,验证这个对象本身是否有这个属性.但不会检查其原型.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Duck.prototype.say = <span class="string">"say"</span> </span><br><span class="line">duck.speak = <span class="string">"speak"</span></span><br><span class="line">duck.hasOwnProperty(<span class="string">"say"</span>) <span class="comment">// false</span></span><br><span class="line">duck.hasOwnProperty(<span class="string">"speak"</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h3 id="isPrototypeOf-与instanceof的区别"><a href="#isPrototypeOf-与instanceof的区别" class="headerlink" title="isPrototypeOf (与instanceof的区别)"></a>isPrototypeOf (与instanceof的区别)</h3><p>isPrototypeOf 主要是辨别类的原型是否在目标类的原型链上.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(Duck) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(duck) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>instanceof 实现功能一样,但语句逻辑是对象是否属于某原型.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">duck instanceOf <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">Duck instanceOf <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><h3 id="propertyIsEnumrable"><a href="#propertyIsEnumrable" class="headerlink" title="propertyIsEnumrable"></a>propertyIsEnumrable</h3><p>这个主要是判断对象的属性是否可枚举.即可循环输出.继承的属性除外.</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>如果是object类型,那么会输出[object Object], 如果是其他类型,会转换为string格式.</p><h3 id="toLocaleString-NaN"><a href="#toLocaleString-NaN" class="headerlink" title="toLocaleString"></a>toLocaleString</h3><p>这个和toString的区别在于它会根据用户所在区域对一些特殊数据做输出优化.<br>比如,日期的输出:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().toString() <span class="comment">//"Mon Jul 23 2018 21:01:51 GMT+0800 (中国标准时间)"</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString() <span class="comment">// "2018/7/23 下午9:02:36"</span></span><br></pre></td></tr></table></figure></p><h3 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h3><p>得到属性的值.<br>日期输出时会得到对应的Long值.</p>]]></content>
      
      <categories>
          
          <category> javascript深入理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> prototype </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javascript深入理解(一):js类型知多少</title>
      <link href="/2018/07/17/javascript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-%E4%B8%80-js%E7%B1%BB%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/"/>
      <url>/2018/07/17/javascript%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-%E4%B8%80-js%E7%B1%BB%E5%9E%8B%E7%9F%A5%E5%A4%9A%E5%B0%91/</url>
      <content type="html"><![CDATA[<h2 id="带着问题阅读"><a href="#带着问题阅读" class="headerlink" title="带着问题阅读"></a>带着问题阅读</h2><ol><li>什么是动态类型语言,什么是动态语言,和静态语言有什么区别?</li><li>js有哪五种数据类型?</li><li>你知道js运算可能出现浮点数误差吗,应该怎么解决?</li><li>js的对象应该怎么创建,怎样重复创建多个对象,并且相互不会影响?(深拷贝,构造器)</li><li>js类型潜在的类型转换你知道吗?</li><li>Array.join(‘’)和+拼接,到底哪个效率更高?</li><li>js空值判断有哪些隐藏的问题?<a id="more"></a></li></ol><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="动态类型语言"><a href="#动态类型语言" class="headerlink" title="动态类型语言:"></a>动态类型语言:</h3><p>js是一门动态类型语言,与静态类型语言使用修饰符来定义变量的类型不同,它可以直接使用var来定义所有的变量,然后根据数据的类型来确定变量的类型.并且在代码运行过程中,变量的类型可以相互转换.<br>来看一段静态类型语言java和js的比较:<br>(java)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number = <span class="string">"0"</span>;</span><br></pre></td></tr></table></figure></p><p>在Java中,以上number变量声明是int型,但赋值是String类型,是无法通过编译的.<br>(javascript)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="string">"0"</span>;</span><br><span class="line">number = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></p><p>而在js中,number最开始是String,其后又被转换为了number型.程序员不需要关心变量实际的类型.</p><h3 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h3><p>同时,js作为一门解释性语言,他可以在运行时,对对象的属性,方法进行替换和删除.在js中,你可以完全把方法当做使用 function声明的属性.</p><h2 id="js的基本类型"><a href="#js的基本类型" class="headerlink" title="js的基本类型"></a>js的基本类型</h2><p>js共有 number , object , boolean , function , undefined 五种基本类型.我们可以通过typeof进行查看</p><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>js的number类型和静态语言中的数字类型不同,它不区分整型和浮点型.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">1</span>;</span><br><span class="line">number += <span class="number">0.2</span>; <span class="comment">// number = 1.2</span></span><br></pre></td></tr></table></figure></p><h4 id="浮点型误差及处理"><a href="#浮点型误差及处理" class="headerlink" title="浮点型误差及处理"></a>浮点型误差及处理</h4><p>然而,涉及浮点型的运算的时候我们总会不可避免遇到二进制的精度误差,这源于十进制的小数转换到二进制时可能出现除不尽的时候:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.05</span> + <span class="number">0.01</span> <span class="comment">// 0.060000000000000005</span></span><br></pre></td></tr></table></figure></p><p>面对这样的问题,我们可以同时乘上一个数,使运算两边都为整数,运算之后再除以这个数就可以了.</p><h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p>js的object 我们一般可以使用json格式来声明:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> duck =&#123;</span><br><span class="line">name: <span class="string">"Donald"</span>,</span><br><span class="line">swimming : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" is swimming!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">duck.swimming(); <span class="comment">// Donald is swimming!</span></span><br></pre></td></tr></table></figure></p><p>当然,上面duck的名字也可以在外部取到.<br>但是,这样声明的对象是单例的.也就是说我们无论是对对象的属性还是方法(当然,其实方法在js中也可以看做是属性)进行操作,都会污染原来的对象.重新赋值会覆盖原来的对象.<br>我常用的解决办法有两种:  </p><h4 id="对象深拷贝"><a href="#对象深拷贝" class="headerlink" title="对象深拷贝"></a>对象深拷贝</h4><p>如果对象不是各处都要声明,只是担心污染的话.可以使用深拷贝的方式.JSON为我们提供了很方便的序列化和反序列化的方法:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> duck1 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringfy(duck));</span><br><span class="line">duck1.swimming = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a duck named "</span> + <span class="keyword">this</span>.name + <span class="string">" is swimming!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">duck.swimming();<span class="comment">// Donald is swimming!</span></span><br><span class="line">duck1.swimming();<span class="comment">//a duck named Donald is swimming!</span></span><br></pre></td></tr></table></figure></p><h4 id="对象构造器"><a href="#对象构造器" class="headerlink" title="对象构造器"></a>对象构造器</h4><p>如果经常性地需要新建对象,我们可以选择<strong>构造器</strong>方式:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Duck = <span class="function"><span class="keyword">function</span>(<span class="params">name, swimming</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.swimming = swimming;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> duck = <span class="keyword">new</span> Duck(<span class="string">"Donald"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" is swimming!"</span>);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">var</span> duck1 = <span class="keyword">new</span> Duck(<span class="string">"Donald"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a duck named "</span> + <span class="keyword">this</span>.name + <span class="string">" is swimming!"</span>);</span><br><span class="line">&#125;); </span><br><span class="line">duck.swimming();<span class="comment">// Donald is swimming!</span></span><br><span class="line">duck1.swimming();<span class="comment">//a duck named Donald is swimming!</span></span><br></pre></td></tr></table></figure></p><p>需要注意的一点是:null也是一个对象.</p><h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><p>js function的使用可以和静态语言类似,将function写在方法名前面,作为方法的声明:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asStaticFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不同的是,我们仍然可以把它当做一个属性来用,例如,我们可以将方法作为参数传递,或者输出它:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">arg();</span><br><span class="line">&#125;</span><br><span class="line">b(a);</span><br><span class="line"><span class="comment">/*输出: </span></span><br><span class="line"><span class="comment">f a()&#123;</span></span><br><span class="line"><span class="comment">console.log(a);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>也可以用其他属性覆盖掉它:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"asdasd"</span>;</span><br><span class="line">&#125;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line">a();<span class="comment">// Uncaught TypeError: a is not a function</span></span><br></pre></td></tr></table></figure></p><p>我们也可以声明一个匿名函数,把它赋值给一个属性,这个方法我们前面已经用过了:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> duck =&#123;</span><br><span class="line">name: <span class="string">"Donald"</span>,</span><br><span class="line">swimming : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" is swimming!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">duck.swimming(); <span class="comment">// Donald is swimming!</span></span><br></pre></td></tr></table></figure></p><p>总之,我们可以将一个函数作为参数传递,也可以随时调用它.区别是调用时需要在后面加上括号.</p><h2 id="js类型的相互转换"><a href="#js类型的相互转换" class="headerlink" title="js类型的相互转换"></a>js类型的相互转换</h2><p>js作为一种弱类型的语言,不需要过分强调类型的转换.但熟悉常用转换,偶尔可以避免一些意想不到的错误.</p><h3 id="number-–-gt-string"><a href="#number-–-gt-string" class="headerlink" title="number –&gt; string"></a>number –&gt; string</h3><p>number 转string 方法比较简单,就是添加一个空字符串,java语言都可以这样使用.用法如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> (<span class="number">5</span> + <span class="string">""</span>)<span class="comment">//string</span></span><br></pre></td></tr></table></figure></p><p>原理是javascript 和java类似,都是把”+”既当加法运算符,也当做字符串连接运算符.在符号两边如果有字符串的话,那么会将两边转换为字符串相连.<br>所以要注意<font color="red">在做加法数学运算时,要确定参数的类型是number</font>.</p><h3 id="string-–-gt-number"><a href="#string-–-gt-number" class="headerlink" title="string –&gt; number"></a>string –&gt; number</h3><p>而string 转number,由于内置的运算操作,会显得简单一些:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span>(<span class="string">"5"</span> * <span class="number">1</span>) <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="string">"5"</span> - <span class="number">0</span>) <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span>(<span class="string">"5"</span> / <span class="number">1</span>) <span class="comment">// number</span></span><br></pre></td></tr></table></figure></p><p>其实除了加法运算,其他的算术运算符单个存在时都仅表示数学运算.所以js会默认将两边转为数字进行运算.<br>但是为了可读性,我们也可以使用js的内置函数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">"500"</span>);<span class="comment">// 整型</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">"50.6"</span>)<span class="comment">// 浮点型</span></span><br></pre></td></tr></table></figure></p><h3 id="array-–-gt-string"><a href="#array-–-gt-string" class="headerlink" title="array –&gt; string"></a>array –&gt; string</h3><p>在将数组转换为string类型时,我们可以使用和number转string 一样的方法,或者调用array自带的toString方法:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="number">3</span>] + <span class="string">""</span> <span class="comment">// "1,2,3"</span></span><br><span class="line">[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="number">3</span>].toString()<span class="comment">// "1,2,3"</span></span><br></pre></td></tr></table></figure></p><p>以上两种方法,得到的字符串里,数组元素使用”,”隔开.</p><h4 id="Array-join"><a href="#Array-join" class="headerlink" title="Array.join()"></a>Array.join()</h4><p>使用Array.join(),效果和toString方法一样,也是得到用”,”分隔的字符串:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="number">3</span>].join() <span class="comment">// "1,2,3"</span></span><br></pre></td></tr></table></figure></p><p>我们有时也希望得到不使用分隔符的字符串,可以使用以下方法:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="number">3</span>].join(<span class="string">''</span>);<span class="comment">// "123"</span></span><br></pre></td></tr></table></figure></p><h4 id="Array-join-与-拼接字符串的性能测试"><a href="#Array-join-与-拼接字符串的性能测试" class="headerlink" title="Array.join() 与 + 拼接字符串的性能测试"></a>Array.join() 与 + 拼接字符串的性能测试</h4><p>这种方法常用于使用js通过对数据的循环操作得到html信息,据说比起直接使用字符串拼接,性能要高一些,我们来验证一下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="string">""</span>;</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"String"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)&#123;</span><br><span class="line">html += <span class="string">"&lt;li&gt;"</span> + i + <span class="string">"&lt;/li&gt;"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"String"</span>);</span><br><span class="line"><span class="keyword">var</span> html = [];</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">"Array"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)&#123;</span><br><span class="line">html.push(<span class="string">"&lt;li&gt;"</span>);</span><br><span class="line">html.push(i);</span><br><span class="line">html.push(<span class="string">"&lt;/li&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line">html.join(<span class="string">''</span>);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"Array"</span>);</span><br></pre></td></tr></table></figure></p><p>以上代码中,执行三次后,分别结果如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>: <span class="number">411.670166015625</span>ms</span><br><span class="line"><span class="built_in">Array</span>: <span class="number">346.830322265625</span>ms</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>: <span class="number">299.099853515625</span>ms</span><br><span class="line"><span class="built_in">Array</span>: <span class="number">234.591796875</span>ms</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>: <span class="number">282.425048828125</span>ms</span><br><span class="line"><span class="built_in">Array</span>: <span class="number">202.469970703125</span>ms</span><br></pre></td></tr></table></figure></p><p>可以看到,在三百万次的拼接中,Array.join(‘’)领先String方法<em>15%</em>到<em>28%</em>的性能.<br>我们接着测几组其他的数据:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 300 次</span></span><br><span class="line"><span class="built_in">String</span>: <span class="number">0.02099609375</span>ms</span><br><span class="line"><span class="built_in">Array</span>: <span class="number">0.038818359375</span>ms</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>: <span class="number">0.022216796875</span>ms</span><br><span class="line"><span class="built_in">Array</span>: <span class="number">0.041748046875</span>ms</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3万次</span></span><br><span class="line"><span class="built_in">String</span>: <span class="number">1.907958984375</span>ms</span><br><span class="line">   <span class="built_in">Array</span>: <span class="number">3.68603515625</span>ms</span><br><span class="line"></span><br><span class="line">   <span class="built_in">String</span>: <span class="number">2.115966796875</span>ms</span><br><span class="line">   <span class="built_in">Array</span>: <span class="number">3.5419921875</span>ms</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3000万次</span></span><br><span class="line"><span class="built_in">String</span>: <span class="number">4743.997802734375</span>ms</span><br><span class="line"><span class="built_in">Array</span>: <span class="number">2028.64599609375</span>ms</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>: <span class="number">4262.615234375</span>ms</span><br><span class="line"><span class="built_in">Array</span>: <span class="number">2114.52685546875</span>ms</span><br></pre></td></tr></table></figure></p><p>我从300 - 3000万都测过多次.篇幅原因就不一一列上来了.<br>实测发现,少量拼接String的性能高过Array.但到达30万次时,Array的性能就明显好于String 了.3000万次时,String消耗的时间甚至达到了Array的两倍.<br>但实际环境中,十万级的拼接毕竟是少数,具体选择还是应该看业务场景.<br>但js的性能主要与客户端的性能有关,我的机器性能如下:</p><table><thead><tr><th>硬件</th><th>配置</th></tr></thead><tbody><tr><td>CPU</td><td>i7</td></tr><tr><td>内存</td><td>16G</td></tr></tbody></table><h2 id="js-的空值"><a href="#js-的空值" class="headerlink" title="js 的空值"></a>js 的空值</h2><p>js的各种类型都可以当做布尔类型进行运算,但在空值的判断时,一定要小心:</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span> == [] <span class="comment">// true</span></span><br><span class="line"><span class="string">""</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line">[] == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line">!!<span class="string">""</span> <span class="comment">// false</span></span><br><span class="line">!![] <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"0"</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line">!!<span class="number">0</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="string">"0"</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// undefined</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">undefined</span> === <span class="literal">null</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">true</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">true</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line">!!<span class="literal">null</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在 == 运算时, 所有可转换为false 的值,都等于”” 和 0 .此外 还和所有可转换为数值0的字符串相等.<br>null是在执行类似document.getElementById()等获取dom元素失败后返回的参数.是一个对象.<br>undefined 是在元素未定义时, 获取元素的返回值.他的类型就是undefined.<br>这两个值在== 是相等的.</p><h3 id="如何避免判断空错误"><a href="#如何避免判断空错误" class="headerlink" title="如何避免判断空错误"></a>如何避免判断空错误</h3><p>由于 0判断为false,而”0”判断为true. 一般应用场景下,我们可以使用$.trim()来进行字符串转换.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNull</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> !! $.trim(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但上面方法会将空格等字符串当做空处理.我们可以把空字符串提出来<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNull</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> !! obj || !! $.trim(obj); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> javascript深入理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>扇入扇出的思考</title>
      <link href="/2018/07/16/%E6%89%87%E5%85%A5%E6%89%87%E5%87%BA%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2018/07/16/%E6%89%87%E5%85%A5%E6%89%87%E5%87%BA%E7%9A%84%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<h2 id="扇入和扇出"><a href="#扇入和扇出" class="headerlink" title="扇入和扇出"></a>扇入和扇出</h2><p><strong>扇入</strong>(fan-in)和<strong>扇出</strong>(fan-out)是电学的词汇,指门电路的输入端和输出端的关系.<br>软件工程中指模块和模块间的调用关系.我们可以按照不同颗粒度,从模块,类,方法层面思考我们项目的架构设计.<br>扇入：是指直接调用该模块的上级模块的个数。扇入大表示模块的复用程序高.<br>扇出：是指该模块直接调用的下级模块的个数。扇出大表示模块的复杂度高.<br><a id="more"></a></p><h2 id="模块应用"><a href="#模块应用" class="headerlink" title="模块应用"></a>模块应用</h2><p>按照项目设计的说法,<strong>底层模块</strong>主要封装整个项目的规约(返回码,配置信息等)和工具类.<br>如果不算上调用项目外jar包,这个模块的<strong>扇出</strong>应该是<strong>0</strong>.<br>而这个模块为了达成项目规约的目的,项目中所有模块都会直接或间接地调用这个模块.所以base模块的<strong>扇入</strong>会较<strong>大</strong>.  </p><p>在此模块的上层,可以进行进一步的细分:<br>对数据库读写的通用封装模块,业务的通用封装模块(公式等底层方法)…</p><p>在其上就涉及具体业务逻辑的封装:<br>这里可能随着业务的复杂,会分成多层.但都要求<strong>扇出</strong>(引用的模块)<strong>尽量的小</strong>.<br>如果引用的模块太多,那么底层代码的迁移都会导致上层代码的相应调整.<br>测试和维护的成本都会提高.此时应该对相关联的底层模块进行合并,或者在其下增加中间模块.并对关联业务设计测试框架.<br>这样底层的模块变动,只用修正中间模块,并通过中间模块对应业务的测试即可.</p><p>而最<strong>顶层</strong>的模块可以有<strong>较大的扇出</strong>,因为到了这里,基本涉及的都是展示和控制.对于错综复杂的内部业务,保持内部未可知的模式,调用的是相应的接口.<br>大部分底层的修改不应该影响到这边的代码.</p><h2 id="方法和类的应用"><a href="#方法和类的应用" class="headerlink" title="方法和类的应用"></a>方法和类的应用</h2><p>方法和类的应用也类似.扇入扇出应尽量的小.<br>但也不是将所有代码合在一起那么简单.<br>也需要结合<strong>单一职责</strong>原则来设计,即类做的事单一,方法做的事也是单一的.如果只是写着玩实现简单的逻辑,那么把代码合在一起,变量之间的调用就会比较轻松.<br>但企业级代码是需要许多人合作,并长期维护的.合理区分代码层次可以使代码更易测试和维护,这里涉及两个极端:</p><ol><li>方法或类做的事太多:<br>由于方法和类做的事太多,那么中间的逻辑必然是可拆分的.这个方法出了问题,我们如果不了解具体数据环境,不能立刻定位到是哪部分逻辑出了问题.为这种方法编写测试框架,也必须为每一套逻辑都写一份整体测试代码.<br>还是应该将逻辑块拆分成多个单一方法,为单一方法编写测试代码,再为整体方法编写测试代码.</li><li>方法层数太多,扇入扇出太复杂:<br>这里和模块的缺点类似,底层的方法略微调整,所有调用的方法都必须随之调整.<br>试想你在改一个老项目,发现某个小BUG出在较底层方法上,导致输出值异常.但同时又有几十个方法在调用这个方法,你如何能确定哪些也因为这个BUG输入了错误的值,而哪些又是其他成员编写的,需要这个错误的值.<br>并且跟代码的时候,为无谓的事钻的太多也是很恶心的.</li></ol>]]></content>
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 基础语法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>递归的一点归纳</title>
      <link href="/2018/07/08/%E9%80%92%E5%BD%92%E7%9A%84%E6%83%B3%E6%B3%95/"/>
      <url>/2018/07/08/%E9%80%92%E5%BD%92%E7%9A%84%E6%83%B3%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="递归介绍"><a href="#递归介绍" class="headerlink" title="递归介绍"></a>递归介绍</h2><pre><code>递归指的是一个方法在方法体内直接或者间接地调用自身的情况.</code></pre><h2 id="递归示例"><a href="#递归示例" class="headerlink" title="递归示例"></a>递归示例</h2><p>以下是递归和循环的java代码比较:<br>循环:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printHelloWorldByLoop</span><span class="params">(String str, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length ; i ++)&#123;</span><br><span class="line">           System.out.println(str);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>递归:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printByRecursion</span><span class="params">(String str, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    printByRecursion(str, --length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="递归应用场景"><a href="#递归应用场景" class="headerlink" title="递归应用场景"></a>递归应用场景</h2><p>递归主要应用在生成<strong>不规则树</strong>的情况.这类情况一般<strong>退出条件明确</strong>,但<strong>循环次数不确定</strong>,并且<strong>循环体内做的事有两种及以上的情况</strong>.<br>绝大多数递归都可以使用循环来实现,但部分更适用于递归的实现转换为循环时就需要<strong>额外的存储</strong>或者对循环条件及循环体的<strong>归纳</strong>.<br>例如多级表头的生成:</p><p><table><br>    <tr><br>        <td colspan="4">一级表头</td><br>    </tr><br>    <tr><br>        <td colspan="2">二级表头1</td><br>        <td colspan="2">二级表头2</td><br>    </tr><br>    <tr><br>        <td colspan="2">三级表头1</td><br>        <td colspan="1">三级表头2</td><br>        <td colspan="1">三级表头3</td><br>    </tr><br>    <tr><br>        <td>…</td><br>        <td>…</td><br>        <td>…</td><br>        <td>…</td><br>    </tr><br></table><br>多级表头的情况下,数据库可能只会有parent_id这样的关联字段,但并不知道一共有多少级的表头,并且每个父节点下面有多少个子节点.<br>那么使用下面的递归伪代码就非常合适:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">treeHeadHandle</span>(<span class="params">id,parentId</span>)</span>&#123;</span><br><span class="line">doSomethingHereWithId(id, parentId);</span><br><span class="line"><span class="keyword">var</span> childIds = <span class="string">"SELECT id FROM table WHERE parent_id = "</span> + id;</span><br><span class="line"><span class="keyword">if</span>(!childIds || childIds.length === <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> childIds)&#123;</span><br><span class="line">treeHeadHandle(ids[i], id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而如果使用循环来解决相同问题的话,就必须额外存储进行状态来判断是否需要停止,并且父子关系必须由存储来处理:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> idToHandle = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">treeHeadHandle</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">idToHandle.push(&#123;<span class="attr">parentId</span>: <span class="string">""</span>, <span class="attr">id</span>:id&#125;);</span><br><span class="line"><span class="keyword">while</span>(idToHandle.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> id = idToHandle[<span class="number">0</span>][<span class="string">"id"</span>];</span><br><span class="line"><span class="keyword">var</span> parentId = idToHandle[<span class="number">0</span>][<span class="string">"parentId"</span>];</span><br><span class="line">idToHandle.splice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">doSomethingHereWithId(id, parentId);</span><br><span class="line"><span class="keyword">var</span> childIds = <span class="string">"SELECT id FROM table WHERE parent_id = "</span> + id;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> ids)&#123;</span><br><span class="line">idToHandle.push(&#123;<span class="attr">parentId</span>: id,<span class="attr">id</span>: ids[i]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其他的情况例如文件夹的遍历,快速排序使用递归都是比较好的选择.</p><h2 id="递归的缺点"><a href="#递归的缺点" class="headerlink" title="递归的缺点"></a>递归的缺点</h2><p>递归更像演绎的思维,一步一步推导最终结果.在实现一些步骤多少和步骤内执行事物不好归纳的时候,更有优势.<br>但递归也有它的缺点,主要在于重复计算和栈的消耗方面.<br>每一次递归,程序都会将当前域放到栈里面.而循环会重复覆盖栈.所以错误的递归程序很有可能导致栈溢出的问题:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br></pre></td></tr></table></figure></p><p>部分语言(如C++)的编译器,对尾递归做了优化,即递归方法在父方法的尾部时,会清除之前相关栈的内容,因为子方法操作的数据或者返回值已不会再对该域造成影响.</p>]]></content>
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 基础语法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis初探</title>
      <link href="/2018/05/25/Redis%E5%88%9D%E6%8E%A2/"/>
      <url>/2018/05/25/Redis%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>主要整理redis安装配置,应用场景,基本概念,API及java的使用。部分参考<a href="http://www.runoob.com/redis/redis-install.html" target="_blank" rel="noopener">菜鸟教程</a>。<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="windows-下安装"><a href="#windows-下安装" class="headerlink" title="windows 下安装"></a>windows 下安装</h3><p><a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">点击下载</a><br>Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 <strong>Redis-x64-xxx.zip</strong>压缩包到 C 盘，解压后，将文件夹重新命名为 <strong>redis</strong>。  </p><p>打开一个 cmd 窗口 使用cd命令切换目录到 C:\redis 运行 <strong>redis-server.exe redis.windows.conf</strong>。  </p><p>如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。输入之后，会显示redis界面.<br>这时候另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了。<br>切换到redis目录下运行 <strong>redis-cli.exe -h 127.0.0.1 -p 6379</strong> 。(客户端)</p><h3 id="Linux-下安装"><a href="#Linux-下安装" class="headerlink" title="Linux 下安装"></a>Linux 下安装</h3><p>本教程使用的最新文档版本为 2.8.17，下载并安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-2.8.17.tar.gz</span><br><span class="line">tar xzf redis-2.8.17.tar.gz</span><br><span class="line">cd redis-2.8.17</span><br><span class="line">make</span><br><span class="line">```  </span><br><span class="line">make完后 redis-2.8.17目录下会出现编译后的redis服务程序redis-server,还有用于测试的客户端程序redis-cli,两个程序位于安装目录 src 目录下：</span><br><span class="line">下面启动redis服务.</span><br><span class="line">```linux</span><br><span class="line">cd src</span><br><span class="line">./redis-server</span><br></pre></td></tr></table></figure></p><p>注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br><span class="line">./redis-server redis.conf</span><br></pre></td></tr></table></figure></p><p>redis.conf是一个默认的配置文件。我们可以根据需要使用自己的配置文件。<br>启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了。 比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br><span class="line">./redis-cli</span><br><span class="line">redis&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line">redis&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br></pre></td></tr></table></figure></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG GET CONFIG_SETTING_NAME</span><br><span class="line">CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE</span><br></pre></td></tr></table></figure><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">默认值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">daemonize</td><td style="text-align:center">no</td><td style="text-align:center">redis默认不是以守护进程的方式运行，可以通过该配置项修改,使用yes启用守护进程。若不是守护进程,在windows界面下,关闭控制界面就会关掉redis服务器。在linux服务器时,配置开机启动必须开启守护进程</td></tr><tr><td style="text-align:center">pidfile</td><td style="text-align:center">/var/run/redis/pid</td><td style="text-align:center">当redis以守护进程方式运行时,默认把pid写入该文件夹</td></tr><tr><td style="text-align:center">port</td><td style="text-align:center">6379</td><td style="text-align:center">监听端口</td></tr><tr><td style="text-align:center">bind</td><td style="text-align:center">127.0.0.1</td><td style="text-align:center">主机地址</td></tr><tr><td style="text-align:center">timeout</td><td style="text-align:center">0</td><td style="text-align:center">客户端闲置多长时间后关闭连接,默认为0,表示关闭该功能</td></tr><tr><td style="text-align:center">loglevel</td><td style="text-align:center">verbose</td><td style="text-align:center">指定日志记录级别,redis总共支持四个级别: debug、verbose、notice、warning</td></tr><tr><td style="text-align:center">databases</td><td style="text-align:center">16</td><td style="text-align:center">设置数据库的数量,客户端如果不指定,默认使用0数据库.可以使用SELECT <dbid> 命令在连接上指定数据库id</dbid></td></tr><tr><td style="text-align:center">save <seconds><changes></changes></seconds></td><td style="text-align:center">[900 1][300 10][60 100000]</td><td style="text-align:center">指定在多长时间内，有多少次更新操作,就将数据同步到数据文件。默认1分钟10000次，5分钟10次，15分钟内1次就保存</td></tr><tr><td style="text-align:center">rdbcompression</td><td style="text-align:center">yes</td><td style="text-align:center">指定存储到本地数据库时是否压缩数据,默认为yes,redis采用LZF压缩,如果为了节省CPU时间,可以关闭该选项,但会导致数据库文件变得巨大</td></tr><tr><td style="text-align:center">dbfilename</td><td style="text-align:center">dump.rdb</td><td style="text-align:center">指定本地数据库文件名</td></tr><tr><td style="text-align:center">dir</td><td style="text-align:center">./</td><td style="text-align:center">指定本地数据库存放目录</td></tr><tr><td style="text-align:center">slaveof <masterip><masterport></masterport></masterip></td><td style="text-align:center">关闭</td><td style="text-align:center">设置当本机为slave服务时,在服务启动时，会自动从master上进行数据同步</td></tr><tr><td style="text-align:center">masterauth<master-password></master-password></td><td style="text-align:center">关闭</td><td style="text-align:center">当master服务设置了密码保护时,slave服务连接master的密码</td></tr><tr><td style="text-align:center">requirepass</td><td style="text-align:center">foobared</td><td style="text-align:center">设置redis连接密码,配置之后,客户端在连接redis服务时需要通过AUTH<password>命令提供密码</password></td></tr><tr><td style="text-align:center">maxclients</td><td style="text-align:center">0</td><td style="text-align:center">设置同一时间最大客户端连接数,默认无限制,redis可以同时打开的客户端连接数为redis进程可以打开的最大文件描述符数。如果设置maxclients 0,表示不作限制.当客户端连接达到限制时,Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</td></tr><tr><td style="text-align:center">maxmemory <bytes></bytes></td><td style="text-align:center">关闭</td><td style="text-align:center">指定redis最大内存限制,redis在启动时会把数据加载到内存中,达到最大内存后,redis会先尝试清除已到期或即将到期的key,当此方法处理后,仍然到达最大内存设置,将无法再进行写入操作,但仍然可以进行读取操作。redis新的vm机制,会把key存放在内存,value会存在swap区。</td></tr><tr><td style="text-align:center">appendonly</td><td style="text-align:center">no</td><td style="text-align:center">指定是否在每次更新操作后进行日志记录,redis在默认情况下是异步的把数据写入磁盘,如果不开启,可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面save条件来同步的,所以有的数据会在一段时间内只存在于内存中</td></tr><tr><td style="text-align:center">appendfilename</td><td style="text-align:center">appendonly.aof</td><td style="text-align:center">指定更新日志文件名</td></tr><tr><td style="text-align:center">appendfsync</td><td style="text-align:center">everysec</td><td style="text-align:center">指定更新日志条件 no:表示等操作系统进行数据缓存同步到磁盘(快); always:表示每次更新操作后手动调用fsync()将数据写到磁盘(慢,安全);everysec:表示每秒同步一次(折衷)</td></tr><tr><td style="text-align:center">vm-enabled</td><td style="text-align:center">no</td><td style="text-align:center">指定是否启用虚拟内存机制.VM机制将数据分页存放, 由redis将访问量较少的页即冷数据swap到磁盘上,访问多的页面由磁盘自动换出到内存中.</td></tr><tr><td style="text-align:center">vm-swap-file</td><td style="text-align:center">/tmp/redis.swap</td><td style="text-align:center">虚拟内存文件路径,不可多个redis实力共享</td></tr><tr><td style="text-align:center">vm-max-memory</td><td style="text-align:center">0</td><td style="text-align:center">将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的,也就是说,当vm-max-memory设置为0的时候,其实是所有的value都存在于磁盘</td></tr><tr><td style="text-align:center">vm-page-size</td><td style="text-align:center">32</td><td style="text-align:center">redis swap文件分成了很多的page,一个对象可以保存在多个page上面,但一个page上不能被多个对象共享,vm-page-size是要根据存储的数据大小来设定的,作者建议如果存储很多小对象,page大小最好设置为32或者64bytes；如果存储很大对象,则可以使用更大的page</td></tr><tr><td style="text-align:center">vm-pages</td><td style="text-align:center">134217728</td><td style="text-align:center">设置swap文件中的page数量,由于页表(一种表示页面空闲或使用的bitmap)是放在内存中的,在磁盘上每8个pages将消耗1byte的内存</td></tr><tr><td style="text-align:center">vm-max-threads</td><td style="text-align:center">4</td><td style="text-align:center">设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的。可能会造成比较长时间的延迟</td></tr><tr><td style="text-align:center">hash-max-zipmap-entries</td><td style="text-align:center">64</td><td style="text-align:center">指定在超过该数量采用哈希算法</td></tr><tr><td style="text-align:center">hash-max-zipmap-value</td><td style="text-align:center">512</td><td style="text-align:center">指定最大的元素超过该值时采用哈希算法</td></tr><tr><td style="text-align:center">activerehashing</td><td style="text-align:center">yes</td><td style="text-align:center">指定是否激活重置哈希</td></tr><tr><td style="text-align:center">include</td><td style="text-align:center"></td><td style="text-align:center">指定包含其他的配置文件,可以在同一主机上多个redis实例之间使用同一份配置文件。而同时各个实例又拥有自己的特定配置文件</td></tr></tbody></table><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>会话缓存（最常用）</li><li>消息队列，比如支付</li><li>活动排行榜或计数</li><li>发布、订阅消息（消息通知）</li><li>商品列表、评论列表等</li></ol><h2 id="数据类型API"><a href="#数据类型API" class="headerlink" title="数据类型API"></a>数据类型API</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>远程连接:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h host -p port -a password</span><br></pre></td></tr></table></figure></p><p>测试连接:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PING</span><br></pre></td></tr></table></figure></p><h3 id="键"><a href="#键" class="headerlink" title="键"></a>键</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><font style="color:red"><strong>DEL</strong></font> key</td><td style="text-align:center">删除</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>DUMP</strong></font> key</td><td style="text-align:center">序列化,并返回被序列化的值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>EXISTS</strong></font> key</td><td style="text-align:center">检查是否存在</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>EXPIRE</strong></font> key seconds</td><td style="text-align:center">为给定key设置过期时间</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>EXPIREAT</strong></font> key timestamp</td><td style="text-align:center">设置过期时间,接受UNIX时间戳</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>KEYS</strong></font> pattern</td><td style="text-align:center">查找所有符合给定模式(pattern)的key</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>MOVE</strong></font> key db</td><td style="text-align:center">将当前数据库的 key 移动到指定数据库db当中</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>PERSIST</strong></font> key</td><td style="text-align:center">移除key的过期时间,key将持久保持</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>PTTL</strong></font> key</td><td style="text-align:center">以毫秒为单位返回key的剩余的过期时间</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>TTL</strong></font> key</td><td style="text-align:center">以秒为单位, 返回给定key的剩余生存时间(time to live)</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>RANDOMKEY</strong></font></td><td style="text-align:center">从当前数据库随机返回一个key</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>RENAME</strong></font> key newkey</td><td style="text-align:center">修改key 的名称</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>RENAMENX</strong></font> key newkey</td><td style="text-align:center">仅当new key 不存在时,将key 改名为 newkey</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>TYPE</strong></font> key</td><td style="text-align:center">返回key 所储存的值的类型</td></tr></tbody></table><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><font style="color:red"><strong>SET</strong></font> key value</td><td style="text-align:center">设置值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>GET</strong></font> key</td><td style="text-align:center">获取值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>GETRANGE</strong></font> key start end</td><td style="text-align:center">返回字符串的子字符(substring)</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>GETSET</strong></font> key value</td><td style="text-align:center">设置值，并返回原值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>GETBIT</strong></font> key offset</td><td style="text-align:center">对 key 所储存的字符串值，获取指定偏移量上的位(bit)</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>MGET</strong></font> key1 [key2..]</td><td style="text-align:center">获取所有(一个或多个)给定的值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SETBIT</strong></font> key offset value</td><td style="text-align:center">对key 所储存的字符串值,设置或清除指定偏移量上的位(bit)</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SETEX</strong></font> key seconds value</td><td style="text-align:center">将值value 关联到key,并将key的过期时间设为seconds(以秒为单位)</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SETNX</strong></font> key value</td><td style="text-align:center">只有在key 不存在时设置key的值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SETRANGE</strong></font> key offset value</td><td style="text-align:center">用value 参数覆写给定key 所储存的字符串值,从偏移量offset开始</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>STRLEN</strong></font> key</td><td style="text-align:center">返回key 所储存的字符串值的长度</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>MSET</strong></font> key value[key value…]</td><td style="text-align:center">同时设置一个或多个key-value对</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>MSETNX</strong></font> key value[key value]</td><td style="text-align:center">同时设置一个或多个key-value对,当且仅当所有给定key 都不存在</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>PSETEX</strong></font> key milliseconds</td><td style="text-align:center">这个命令和SETEX命令相似,但它以毫秒为单位设置key的生存时间,而不是像SETEX命令那样,以秒为单位</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>INCR</strong></font> key</td><td style="text-align:center">将key中储存的数字值增一</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>INCRBY</strong></font> key increment</td><td style="text-align:center">将key所储存的值加上给定的增量值(increment)</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>INCRBYFLOAT</strong></font> key increment</td><td style="text-align:center">将key所储存的值加上给定的浮点增量值(increment)</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>DECR</strong></font> key</td><td style="text-align:center">将 key 中储存的数字值减一</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>DECRBY</strong></font> key decrement</td><td style="text-align:center">key所储存的值减去给定的减量值(decrement)</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>APPEND</strong></font> key value</td><td style="text-align:center">如果key已经存在并且是一个字符串, APPEND命令将制定的value追加到该key原来值(value)的末尾</td></tr></tbody></table><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><font style="color:red"><strong>HDEL</strong></font> key field1[field2..]</td><td style="text-align:center">删除一个或多个哈希表字段</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HEXISTS</strong></font>** key field</td><td style="text-align:center">查看哈希表key中,指定的字段是否存在</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HGET</strong></font> key field</td><td style="text-align:center">获取存储在哈希表中指定字段的值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HGETALL</strong></font> key</td><td style="text-align:center">获取在哈希表指定key的所有字段和值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HINCRBY</strong></font> key field increment</td><td style="text-align:center">为哈希表key中指定字段的整数值加上增量 increment</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HINCRBYFLOAT</strong></font> key field increment</td><td style="text-align:center">为哈希表key中指定字段的浮点数值加上增量increment</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HKEYS</strong></font> key</td><td style="text-align:center">获取所有哈希表中的字段</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HLEN</strong></font> key</td><td style="text-align:center">获取哈希表中字段的数量</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HMGET</strong></font> key field1 [field2]</td><td style="text-align:center">获取所有给定字段的值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HMSET</strong></font> key field1 value1 [field2 value2]</td><td style="text-align:center">同时将多个field-value(域-值)对设置到哈希表key 中</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HSET</strong></font> key field value</td><td style="text-align:center">将哈希表key中字段field的值设为value</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HSETNX</strong></font> key field value</td><td style="text-align:center">只有在字段field不存在时,设置哈希表字段的值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HVALS</strong></font> key</td><td style="text-align:center">获取哈希表中所有值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HSCAN</strong></font> key cursor[MATCH pattern][COUNT count]</td><td style="text-align:center">迭代哈希表中的键值对</td></tr></tbody></table><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><font style="color:red"><strong>BLPOP</strong></font> key1[key2] timeout</td><td style="text-align:center">移出并获取列表的第一个元素,如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>BRPOP</strong></font> key1[key2] timeout</td><td style="text-align:center">移出并获取列表的最后一个元素,如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>BRPOPLPUSH</strong></font> source destination timeout</td><td style="text-align:center">从列表中弹出一个值,将弹出的元素插入到另外一个列表中并返回它;如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>LINDEX</strong></font> key index</td><td style="text-align:center">通过索引获取列表中的元素</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>LINSERT</strong></font> key BEFORE/AFTER pivot value</td><td style="text-align:center">在列表的元素前或者后插入元素</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>LLEN</strong></font> key</td><td style="text-align:center">获取列表长度</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>LPOP</strong></font> key</td><td style="text-align:center">移出并获取列表的第一个元素</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>LPUSH</strong></font> key value1[value2..]</td><td style="text-align:center">将一个或多个值插入到列表头部</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>LPUSHX</strong></font> key value</td><td style="text-align:center">将一个值插入到已存在的列表头部</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>LRANGE</strong></font> key start stop</td><td style="text-align:center">获取列表指定范围内的元素</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>LREM</strong></font> key count value</td><td style="text-align:center">移除列表元素</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>LSET</strong></font> key index value</td><td style="text-align:center">通过索引设置列表元素的值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>LTRIM</strong></font> key start stop</td><td style="text-align:center">对一个列表进行修剪(trim),就是说,让列表只保留指定区间内的元素,不在指定区间之内的元素都将删除</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>RPOP</strong></font> key</td><td style="text-align:center">移除并获取列表最后一个元素</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>RPOPLPUSH</strong></font> source destination</td><td style="text-align:center">移除列表最后一个元素,并将该元素添加到另一个列表并返回</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>RPUSH</strong></font> key value1[value2…]</td><td style="text-align:center">在列表中添加一个或多个值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>RPUSHX</strong></font> key value</td><td style="text-align:center">为已存在的列表添加值</td></tr></tbody></table><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><font style="color:red"><strong>SADD</strong></font> key member1[member2]</td><td style="text-align:center">向集合添加一个或多个成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SCARD</strong></font> key</td><td style="text-align:center">获取集合的成员数</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SDIFF</strong></font> key1[key2]</td><td style="text-align:center">返回给定所有集合的差集</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SDIFFSTORE</strong></font> destination key1[key2]</td><td style="text-align:center">返回给定所有集合的差集并存储在destination中</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SINTER</strong></font> key1[key2]</td><td style="text-align:center">返回给定所有集合的交集</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SINTERSTORE</strong></font> destination key1[key2]</td><td style="text-align:center">返回给定所有集合的交集并存储在destination中</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SISMEMBER</strong></font> key member</td><td style="text-align:center">判断member 元素是否是集合key 的成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SMEMBERS</strong></font> key</td><td style="text-align:center">返回集合中的所有成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SMOVE</strong></font> source destination member</td><td style="text-align:center">将member元素从source集合移动到destination集合</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SPOP</strong></font> key</td><td style="text-align:center">移除并返回集合中的一个随机元素</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SRANDMEMBER</strong></font> key[count]</td><td style="text-align:center">返回集合中一个或多个随机数</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SREM</strong></font> key member1[member2]</td><td style="text-align:center">移除集合中一个或多个成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SUNION</strong></font> key1[key2]</td><td style="text-align:center">返回所有给定集合的并集</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SUNIONSTORE</strong></font> destination key1[key2]</td><td style="text-align:center">将所有给定集合的并集存储在destination 集合中</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SSCAN</strong></font> key cursor[MATCH pattern][COUNT count]</td><td style="text-align:center">迭代集合中的元素</td></tr></tbody></table><h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><font style="color:red"><strong>ZADD</strong></font> key score1 member1[score2 member2]</td><td style="text-align:center">向有序集合添加一个或多个成员,或者更新已存在成员的分数</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZCARD</strong></font> key</td><td style="text-align:center">获取有序集合的成员数</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZCOUNT</strong></font> key min max</td><td style="text-align:center">计算在有序集合中指定区间分数的成员数</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZINCRBY</strong></font> key increment member</td><td style="text-align:center">有序集合中对指定成员的分数加上增量increment</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZINTERSTORE</strong></font> destination numkeys key [key…]</td><td style="text-align:center">计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合key中</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZLEXCOUNT</strong></font> key min max</td><td style="text-align:center">在有序集合中计算指定字典区间内成员数量</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZRANGE</strong></font> key start stop[WITHSCORES]</td><td style="text-align:center">通过索引区间返回有序集合指定区间的成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZRANGEBYLEX</strong></font> key min max[LIMIT offset count]</td><td style="text-align:center">通过字典区间返回有序集合的成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZRANGEBYSCORE</strong></font> key min max[WITHSCORES]_[LIMIT]</td><td style="text-align:center">通过分数返回有序集合指定区间内的成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZRANK</strong></font> key member</td><td style="text-align:center">返回有序集合中指定成员的索引</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZREM</strong></font> key member[member…]</td><td style="text-align:center">移除有序集合中的一个或多个成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZREMRANGEBYLEX</strong></font> key min max</td><td style="text-align:center">移除有序集合中给定的字典区间的所有成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZREMRANGEBYRANK</strong></font> key start stop</td><td style="text-align:center">移除有序集合中给定排名区间的所有成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZREMRANGEBYSCORE</strong></font> key min max</td><td style="text-align:center">移除有序集合中给定的分数区间的所有成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZREVRANGE</strong></font> key start stop [WITHSCORES]</td><td style="text-align:center">返回有序集中指定区间内的成员,通过索引,分数由高到低</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZREVRABGEBYSCORE</strong></font> key max min[WITHSCORES]</td><td style="text-align:center">返回有序集中指定分数区间内的成员,分数由高到低排序</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZREVRANK</strong></font> key member</td><td style="text-align:center">返回有序集合中指定成员的排名,有序集成员按分数值递减排序</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZSCORE</strong></font> key member</td><td style="text-align:center">返回有序集中,成员的分数值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZUNIONSTORE</strong></font> destination numkeys key[key…]</td><td style="text-align:center">计算给定的一个或多个有序集的并集,并存储在新的key中</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZSCAN</strong></font> key cursor [MATCH pattern][COUNT count]</td><td style="text-align:center">迭代有序集合中的元素(包括元素成员和元素分值)</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> nosql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>idea开发常用指令</title>
      <link href="/2018/05/25/idea%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2018/05/25/idea%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>博客介绍 WINDOWS下 Intellj IDEA 原生快捷键。<br>分为 通用指令(大部分IDE都支持的快捷功能)、文件操作指令、项目索引指令三个部分。<br><a id="more"></a></p><h2 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h2><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">CTRL+C</td><td style="text-align:center">复制</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CTRL+V</td><td style="text-align:center">粘贴</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CTRL+F</td><td style="text-align:center">搜索</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CTRL+R</td><td style="text-align:center">替换</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CTRL+A</td><td style="text-align:center">全选</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CTRL+/</td><td style="text-align:center">注释</td><td style="text-align:center">也可取消注释</td></tr><tr><td style="text-align:center">CTRL+S</td><td style="text-align:center">保存</td><td style="text-align:center">一般不设置支持自动保存</td></tr><tr><td style="text-align:center">SHIFT+ENTER</td><td style="text-align:center">新建一行，光标移至行首</td></tr></tbody></table><h2 id="文件操作指令"><a href="#文件操作指令" class="headerlink" title="文件操作指令"></a>文件操作指令</h2><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">ALT+/</td><td style="text-align:center">查看描述</td><td style="text-align:center">导包、查看错误提示…</td></tr><tr><td style="text-align:center">CTRL+W</td><td style="text-align:center">选择当前单词</td><td style="text-align:center">再次点击依次选择:包含周围符号、方法参数、句子、行、方法体、方法…</td></tr><tr><td style="text-align:center">CTRL+SHIFT+W</td><td style="text-align:center">反选</td><td style="text-align:center">返回CTRL+W的选择</td></tr><tr><td style="text-align:center">CTRL+Y</td><td style="text-align:center">删除当前行</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CTRL+X</td><td style="text-align:center">剪切</td><td style="text-align:center">这个单独提出来，因为在没有选择文本的情况下,该操作是剪切当前行,按着比Y方便</td></tr><tr><td style="text-align:center">CTRL+D</td><td style="text-align:center">复制当前行</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CTRL+G</td><td style="text-align:center">定位到指定行</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ALT+↑/↓</td><td style="text-align:center">到上/下个方法</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CTRL+SHIFT+[1-0]</td><td style="text-align:center">标记</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CTRL+[1-0]</td><td style="text-align:center">快速定位到标记位置</td><td style="text-align:center">飞雷神之术..其实F11的搭配能配置的更多。但按键比较复杂而且一般1-0就够用了</td></tr><tr><td style="text-align:center">ALT+INSERT</td><td style="text-align:center">生成方法</td><td style="text-align:center">getter啊,setter啊,Constructor…</td></tr><tr><td style="text-align:center">CTRL+SHIFT+V</td><td style="text-align:center">剪贴板</td><td style="text-align:center">最近复制的内容都会显示在上面</td></tr><tr><td style="text-align:center">CTRL+B</td><td style="text-align:center">进入</td><td style="text-align:center">可以查看光标位置的类或者方法内容,和CTRL+鼠标左键功能一样</td></tr><tr><td style="text-align:center">ALT+SHIFT+鼠标左键</td><td style="text-align:center">多光标同时操作</td><td style="text-align:center">也可以按住中间滚轮拖动</td></tr></tbody></table><h2 id="项目索引指令"><a href="#项目索引指令" class="headerlink" title="项目索引指令"></a>项目索引指令</h2><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">CTRL+N</td><td style="text-align:center">寻找类</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CTRL+SHIFT+N</td><td style="text-align:center">寻找文件</td><td style="text-align:center">可以在后面+/寻找文件夹</td></tr><tr><td style="text-align:center">CTRL+SHIFT+F</td><td style="text-align:center">寻找字符串</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">SHIFT * 2</td><td style="text-align:center">全局搜索</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ALT+F1弹框后ENTER</td><td style="text-align:center">定位到文件所在位置</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ALT+F1弹框后C</td><td style="text-align:center">在文件夹中打开当前文件</td><td style="text-align:center"></td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> Intellj Idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Intellj Idea </tag>
            
            <tag> 开发工具 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>堆排序实现及数学思考</title>
      <link href="/2018/05/23/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%95%B0%E5%AD%A6%E6%80%9D%E8%80%83/"/>
      <url>/2018/05/23/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%95%B0%E5%AD%A6%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>堆排序java算法,排序的思想理解以及里面数学部分的思考。<br><a id="more"></a></p><h2 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> https://www.cnblogs.com/chengxiao/p/6129630.html </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> []arr = &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">10</span>&#125;;  </span><br><span class="line">        sort(arr);  </span><br><span class="line">        System.out.println(Arrays.toString(arr));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;  </span><br><span class="line">        <span class="comment">//1.构建大顶堆  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;  </span><br><span class="line">            <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构  </span></span><br><span class="line">            adjustHeap(arr,i,arr.length);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;  </span><br><span class="line">            <span class="comment">//将堆顶元素与末尾元素进行交换  </span></span><br><span class="line">            swap(arr,<span class="number">0</span>,j);  </span><br><span class="line">            <span class="comment">//重新对堆进行调整  </span></span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>,j);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上） </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;  </span><br><span class="line">        <span class="comment">//先取出当前元素i  </span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];  </span><br><span class="line">        <span class="comment">//从i结点的左子结点开始，也就是2i+1处开始  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;  </span><br><span class="line">            <span class="comment">//如果左子结点小于右子结点，k指向右子结点  </span></span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="number">1</span>])&#123;  </span><br><span class="line">                k++;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）  </span></span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt;temp)&#123;  </span><br><span class="line">                arr[i] = arr[k];  </span><br><span class="line">                i = k;  </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//将temp值放到最终的位置  </span></span><br><span class="line">        arr[i] = temp;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 交换元素 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> temp=arr[a];  </span><br><span class="line">        arr[a] = arr[b];  </span><br><span class="line">        arr[b] = temp;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h2><h3 id="顶堆的概念"><a href="#顶堆的概念" class="headerlink" title="顶堆的概念"></a>顶堆的概念</h3><p>堆排序处理顺序的特点是升序使用大顶堆，降序使用小顶堆。<br><strong>大顶堆</strong>（又叫大根堆，最大堆）：<br>子节点的值一定小于父节点。<br>即下图中，(1)的值大于(2)、(3)的值<br><img src="http://www.ashasean.cn/blog-image/heap1.png" alt="顶堆示意图"><br>有的人觉得升序应该使用小顶堆，这样从上自下依次读取(1)(2)(3)，就是一个升序的数组；<br>这实际上是误解了堆排序的实现方式，因为堆排序没有进行横向排序的。即(2)和(3)没有固定的大小关系。</p><h3 id="堆排序的实现步骤"><a href="#堆排序的实现步骤" class="headerlink" title="堆排序的实现步骤"></a>堆排序的实现步骤</h3><p>将数组看作一个二叉树。数组从左至右依次对应二叉树从上至下从左至右的元素，如下图是一个长度为12的数组对应的二叉树示意图，数字为对应数组的下标。<br><img src="http://www.ashasean.cn/blog-image/heap2.png" alt="二叉树示意图">  </p><ol><li>首先从末尾父节点(5)开始，比较两个子节点和父节点的大小，将最大值和父节点交换。然后按(4)，(3)，(2)，(1)，(0)的顺序一直遍历到根节点。此时得到一个大顶堆。</li><li>在大顶堆中，根节点(0)的值一定是最大值。所以此时将根节点的值置于末尾。【即交换(0)和(11)的值】</li><li>再次基于剩下的元素构建大顶堆，并将根节点值置于当前末尾。。。。</li></ol><p>这样做在第二次开始每一次构建大顶堆时，除开顶层元素a，第二层开始都是构建好的大顶堆，不需比较所有元素，只需要不停交换a和剩下旁支中较大的元素即可。<br>如下图是第二次比较及交换的其中一种情况。<br><img src="http://www.ashasean.cn/blog-image/heap3.png" alt="比较示意图">  </p><h2 id="数学思考"><a href="#数学思考" class="headerlink" title="数学思考"></a>数学思考</h2><h3 id="为什么最末父节点的坐标为array-length-2-1"><a href="#为什么最末父节点的坐标为array-length-2-1" class="headerlink" title="为什么最末父节点的坐标为array.length/2-1?"></a>为什么最末父节点的坐标为array.length/2-1?</h3><p>由于数组的起始坐标为0，我们可以简单地理解一个元素的坐标为它之前元素的总个数。<br>二叉树可按每层的元素个数转换为一个基数为1，比值为2的等比数列（除开叶子层)；<br>可得第n层的元素个数为2^(n-1)<br>1~n层的元素个数和为2^(n-1)-1<br><img src="http://www.ashasean.cn/blog-image/heap4.png" alt="数学运算"><br>以上图为例：<br>此时，最末父节点所在层n为第三层，最末父节点的子节点数count =1；</p><p>由等比数列性质可知：</p><p>该节点之前的元素个数为： 2^(n-1)-1+(x-count)/2;</p><p>该节点之后的元素个数为： 2^(n-1)-1-(x-count)/2-1+x;</p><p>设m = 2^(n-1) -1 +x/2</p><p>则该节点之前的元素个数为： m-count/2</p><p>该节点之后的元素个数为：m+count/2</p><p>array.length = 节点之前元素+节点+节点之后元素 = 2m+1</p><p>m = (array.length-1)/2</p><p>可得该节点下标为其之前的元素个数：</p><p>(array.length -1)/2 -count/2…………………………………………………………(1)</p><p>由于java浮点数转int总是截断小数点后的数（即1/2取值为0）：</p><p>若count =1：</p><p> 则array.length为偶数;array.length-1为奇数；</p><p> (array.length-1)/2 = (array.length)/2 -1;</p><p> 同时count/2舍去；</p><p> (1)式可转换为 array.length/2 -1;</p><p>若count = 2 :</p><p> 则array.length为奇数;array.length-1为偶数;</p><p> (array.length-1)/2 = (array.length)/2;</p><p>count/2 = 1;</p><p>(2)式也可转换为array.length/2 - 1;</p><h3 id="为什么某节点的左子节点的坐标-该节点坐标i-2-1？"><a href="#为什么某节点的左子节点的坐标-该节点坐标i-2-1？" class="headerlink" title="为什么某节点的左子节点的坐标 = 该节点坐标i*2+1？"></a>为什么某节点的左子节点的坐标 = 该节点坐标i*2+1？</h3><p>将上个问题的最末父节点看作二叉树中的某一节点，则上个问题中count=1情况下的array.length即为子节点的坐标。</p><p>可得关系：</p><p> （子节点坐标-1）/2 = 父节点坐标。</p><p> 即 父节点坐标的左子节点坐标 = 父节点坐标 * 2 + 1</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>(转载)编码那点事</title>
      <link href="/2018/05/23/%E8%BD%AC%E8%BD%BD-%E7%BC%96%E7%A0%81%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
      <url>/2018/05/23/%E8%BD%AC%E8%BD%BD-%E7%BC%96%E7%A0%81%E9%82%A3%E7%82%B9%E4%BA%8B/</url>
      <content type="html"><![CDATA[<h2 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h2><p>电脑是如何从电信号转变为英文、数字、符号乃至整个语言系统的,这篇文章讲的太棒了。<br>原文来源于<a href="https://www.zhihu.com/question/23374078/answer/69732605" target="_blank" rel="noopener">知乎</a><br><a id="more"></a></p><h2 id="由电信号到ASCII"><a href="#由电信号到ASCII" class="headerlink" title="由电信号到ASCII"></a>由电信号到ASCII</h2><p>很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为”<strong>字节</strong>  “。再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”<strong>计算机</strong>“。<br>开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。<br>他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作：<br>遇上0×10, 终端就换行；<br>遇上0×07, 终端就向人们嘟嘟叫；<br>遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。<br>他们看到这样很好，于是就把这些0×20以下的字节状态称为”控制码”。他们又把所有的空 格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉 很好，于是大家都把这个方案叫做 <strong>ANSI</strong> 的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的<strong>ASCII</strong>方案来保存英文文字。<br>后来，就像建造巴比伦塔一样，世界各地都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用 127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128 到255这一页的字符集被称”<strong>扩展字符集</strong>“。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！  </p><h2 id="中文的发展历程-GB2312-、-GBK-、-GB18030-DBCS"><a href="#中文的发展历程-GB2312-、-GBK-、-GB18030-DBCS" class="headerlink" title="中文的发展历程:GB2312 、 GBK 、 GB18030(DBCS)"></a>中文的发展历程:GB2312 、 GBK 、 GB18030(DBCS)</h2><p>等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。中国人民看到这样很不错，于是就把这种汉字方案叫做 “<strong>GB2312</strong>“。GB2312 是对 ASCII 的中文扩展。  </p><p>但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把GB2312 没有用到的码位找出来老实不客气地用上。后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 <strong>GBK</strong> 标准，GBK包括了GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。 后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK扩成了 <strong>GB18030</strong>。从此之后，中华民族的文化就可以在计算机时代中传承了。 中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “<strong>DBCS</strong>“（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍： “一个汉字算两个英文字符！一个汉字算两个英文字符……”  </p><p>因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，像是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ 真是计算机的巴比伦塔命题啊！  </p><h2 id="巴比伦塔问题的解决方案-unicode"><a href="#巴比伦塔问题的解决方案-unicode" class="headerlink" title="巴比伦塔问题的解决方案:unicode"></a>巴比伦塔问题的解决方案:unicode</h2><p>正在这时，大天使加百列及时出现了——一个叫 <strong>ISO</strong>（国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号 的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 <strong>UCS</strong>, 俗称 “<strong>unicode</strong>“。  </p><p>unicode开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ASCII里的那些“半角”字符，unicode包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。  </p><p>这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的 strlen 函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是的，从unicode开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的”<strong>一个字符</strong>“！同时，也都是统一的”<strong>两个字节</strong>“，请注意”字符”和”字节”两个术语的不同，“<strong>字节</strong>”是一个8位的物理存贮单元，而“<strong>字符</strong>”则是一个文化相关的符号。在unicode中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。<br>unicode同样也不完美，这里就有两个的问题，一个是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费，文本文件的大小会因此大出二三倍，这是难以接受的。  </p><h2 id="unicode-的数据传输解决方法-UTF-X"><a href="#unicode-的数据传输解决方法-UTF-X" class="headerlink" title="unicode 的数据传输解决方法:UTF-X"></a>unicode 的数据传输解决方法:UTF-X</h2><p>unicode在很长一段时间内无法推广，直到互联网的出现，为解决unicode如何在网络上传输的问题，于是面向传输的众多 <strong>UTF</strong>（UCS Transfer Format）标准出现了，顾名思义，<strong>UTF-8</strong>就是每次8个位传输数据，而<strong>UTF-16</strong>就是每次16个位。UTF-8就是在互联网上使用最广的一种unicode的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节）。从unicode到utf-8并不是直接的对应，而是通过一些算法和规则来转换。  </p><table><thead><tr><th style="text-align:center">Unicode符号范围 (十六进制)</th><th style="text-align:center">UTF-8编码方式  （二进制）</th></tr></thead><tbody><tr><td style="text-align:center">0000 0000-0000 007F</td><td style="text-align:center">0xxxxxxx</td></tr><tr><td style="text-align:center">0000 0080-0000 07FF</td><td style="text-align:center">110xxxxx</td></tr><tr><td style="text-align:center">10xxxxxx0000 0800-0000 FFFF</td><td style="text-align:center">1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td style="text-align:center">0001 0000-0010 FFFF</td><td style="text-align:center">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最后简单总结一下：</p><ul><li>中国人民通过对 ASCII 编码的中文扩充改造，产生了 GB2312 编码，可以表示6000多个常用汉字。  </li><li>汉字实在是太多了，包括繁体和各种字符，于是产生了 GBK 编码，它包括了 GB2312 中的编码，同时扩充了很多。  </li><li>中国是个多民族国家，各个民族几乎都有自己独立的语言系统，为了表示那些字符，继续把 GBK 编码扩充为 GB18030 编码。  </li><li>每个国家都像中国一样，把自己的语言编码，于是出现了各种各样的编码，如果你不安装相应的编码，就无法解释相应编码想表达的内容。  </li><li>终于，有个叫 ISO 的组织看不下去了。他们一起创造了一种编码 UNICODE ，这种编码非常大，大到可以容纳世界上任何一个文字和标志。所以只要电脑上有 UNICODE 这种编码系统，无论是全球哪种文字，只需要保存文件的时候，保存成 UNICODE 编码就可以被其他电脑正常解释。  </li><li>UNICODE 在网络传输中，出现了两个标准 UTF-8 和 UTF-16，分别每次传输 8个位和 16个位。于是就会有人产生疑问，UTF-8 既然能保存那么多文字、符号，为什么国内还有这么多使用 GBK 等编码的人？因为 UTF-8 等编码体积比较大，占电脑空间比较多，如果面向的使用人群绝大部分都是中国人，用 GBK 等编码也可以。  </li></ul>]]></content>
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 编码发展 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>工具类(二)数字安全运算BigDecimalUtil</title>
      <link href="/2018/05/23/%E5%B7%A5%E5%85%B7%E7%B1%BB(%E4%BA%8C)%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8%E8%BF%90%E7%AE%97BigDecimalUtil/"/>
      <url>/2018/05/23/%E5%B7%A5%E5%85%B7%E7%B1%BB(%E4%BA%8C)%E6%95%B0%E5%AD%97%E5%AE%89%E5%85%A8%E8%BF%90%E7%AE%97BigDecimalUtil/</url>
      <content type="html"><![CDATA[<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>由于以下几点原因，我们需要对BigDecimal 进行封装。使用起来更方便。</p><ol><li>BigDecimal 参数为double 类型时，有可能会出现误差。</li><li>参数为空时，会抛出异常。这里默认为0。</li><li>除法运算时，若结果为无限小数，会抛出异常。<a id="more"></a></li></ol><h2 id="API说明"><a href="#API说明" class="headerlink" title="API说明"></a>API说明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// obj == null,所得值为0,obj 不能转换为数字,抛出转换异常。</span></span><br><span class="line"><span class="keyword">new</span> BigDecimalUtil(Object obj);</span><br><span class="line"><span class="comment">// 加法 obj处理同上</span></span><br><span class="line">add(Object obj);</span><br><span class="line"><span class="comment">// 减法 obj处理同上</span></span><br><span class="line">minus(Object obj);</span><br><span class="line"><span class="comment">// 乘法 obj处理同上</span></span><br><span class="line">times(Object obj);</span><br><span class="line"><span class="comment">// 除法 obj处理同上</span></span><br><span class="line">divide(Object obj);</span><br><span class="line"><span class="comment">// 转换为String</span></span><br><span class="line">toString();</span><br><span class="line"><span class="comment">// 按精度转换为String,roundMode参见BigDecimal精度模式</span></span><br><span class="line">toString(<span class="keyword">int</span> digit, <span class="keyword">int</span> roundMode);</span><br><span class="line"><span class="comment">// 转换为Double</span></span><br><span class="line">toDouble();</span><br><span class="line"><span class="comment">// 按精度转换为Double,roundMode参见BigDecimal精度模式</span></span><br><span class="line">toDouble(<span class="keyword">int</span> digit, <span class="keyword">int</span> roundMode);</span><br></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bigDecimalUtilIntroduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">    assertEquals(String.valueOf(<span class="number">0.05</span>+<span class="number">0.01</span>),<span class="string">"0.060000000000000005"</span>);</span><br><span class="line">    BigDecimalUtil bigDecimalUtil = <span class="keyword">new</span> BigDecimalUtil(<span class="number">0.05</span>);</span><br><span class="line">    bigDecimalUtil.add(<span class="number">0.01</span>);</span><br><span class="line">    assertEquals(bigDecimalUtil.toString(),<span class="string">"0.06"</span>);</span><br><span class="line">    <span class="comment">// 长运算示例</span></span><br><span class="line">    assertEquals(<span class="keyword">new</span> BigDecimalUtil(<span class="number">0.05</span>).add(<span class="number">0.01</span>).minus(<span class="string">"3"</span>).times(<span class="number">6</span>).divide(<span class="number">3</span>).toString(),<span class="string">"-5.88"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimalUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 当前值 */</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigDecimalUtil</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">new</span> BigDecimal(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigDecimalUtil</span><span class="params">(Object value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = getBigDecimal(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 加 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimalUtil <span class="title">add</span><span class="params">(Object calc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.value.add(getBigDecimal(calc));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 减 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimalUtil <span class="title">minus</span><span class="params">(Object calc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.value.subtract(getBigDecimal(calc));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 乘 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimalUtil <span class="title">times</span><span class="params">(Object calc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.value.multiply(getBigDecimal(calc));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 除 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimalUtil <span class="title">divide</span><span class="params">(Object calc)</span></span>&#123;</span><br><span class="line">       <span class="comment">// this.value = this.value.divide(getBigDecimal(calc));</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.value.divide(getBigDecimal(calc),MathContext.DECIMAL64);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 空处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">ifNull</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (obj == <span class="keyword">null</span> || (obj <span class="keyword">instanceof</span> java.lang.String &amp;&amp; obj == <span class="string">""</span>) ) ? <span class="string">"0"</span> : String.valueOf(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 类型转换 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> BigDecimal <span class="title">getBigDecimal</span><span class="params">(Object value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value <span class="keyword">instanceof</span> BigDecimalUtil)&#123;</span><br><span class="line">            BigDecimalUtil val = (BigDecimalUtil) value;</span><br><span class="line">            <span class="keyword">return</span> val.value;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(ifNull(value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 得到值 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> digit, <span class="keyword">int</span> roundMode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value.setScale(digit, roundMode).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">toDouble</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value.doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">toDouble</span><span class="params">(<span class="keyword">int</span> digit, <span class="keyword">int</span> roundMode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value.setScale(digit, roundMode).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">toInt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 工具类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 工具类 </tag>
            
            <tag> 数学运算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>工具类(三)中文阿拉伯数字相互转换NumberUtil</title>
      <link href="/2018/05/23/%E5%B7%A5%E5%85%B7%E7%B1%BB(%E4%B8%89)%E4%B8%AD%E6%96%87%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2NumberUtil/"/>
      <url>/2018/05/23/%E5%B7%A5%E5%85%B7%E7%B1%BB(%E4%B8%89)%E4%B8%AD%E6%96%87%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2NumberUtil/</url>
      <content type="html"><![CDATA[<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>我们有时会需要将中文和阿拉伯数字相互转换。<br>但中文数字并非单纯像电话号码一样一一对应解读，会出现一百零五万三千零伍拾这样的问题。</p><h3 id="中文解读有趣的例子"><a href="#中文解读有趣的例子" class="headerlink" title="中文解读有趣的例子"></a>中文解读有趣的例子</h3><p>这是我在解读月份时发现的有趣例子。<br>两位数中十的解读:</p><table><thead><tr><th style="text-align:center">情况</th><th style="text-align:center">中文</th><th style="text-align:center">阿拉伯数字</th><th style="text-align:center">解读说明</th></tr></thead><tbody><tr><td style="text-align:center">十在首位</td><td style="text-align:center">十一</td><td style="text-align:center">11</td><td style="text-align:center">十解读为1</td></tr><tr><td style="text-align:center">十在中间</td><td style="text-align:center">三十一</td><td style="text-align:center">31</td><td style="text-align:center">十不解读</td></tr><tr><td style="text-align:center">十在末尾</td><td style="text-align:center">二十</td><td style="text-align:center">20</td><td style="text-align:center">十解读为0</td></tr><tr><td style="text-align:center">十单独出现</td><td style="text-align:center">十</td><td style="text-align:center">10</td><td style="text-align:center">十解读为10</td></tr></tbody></table><hr><p>并且我的工作环境下，大量数据的录入可能存在数据源填写错误的情况，比如一白〇而时(120)的情况。<br>所以也在Util中加了容错的数组(可自行扩充)判断。<br><a id="more"></a></p><h2 id="API说明"><a href="#API说明" class="headerlink" title="API说明"></a>API说明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中文 --&gt; 阿拉伯数字</span></span><br><span class="line">String num = NumberUtil.parse(chineseNum);</span><br><span class="line"><span class="comment">// 阿拉伯数字 --&gt; 中文</span></span><br><span class="line">String chineseNum = NumberUtil.format(num);</span><br><span class="line"><span class="comment">// 阿拉伯数字 --&gt; 中文年</span></span><br><span class="line">String chineseYear = NumberUtil.getChineseYear(num);</span><br></pre></td></tr></table></figure><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sean22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/1/19/019.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] chinese=&#123;<span class="string">"零"</span>,<span class="string">"一"</span>,<span class="string">"二"</span>,<span class="string">"三"</span>,<span class="string">"四"</span>,<span class="string">"五"</span>,<span class="string">"六"</span>,<span class="string">"七"</span>,<span class="string">"八"</span>,<span class="string">"九"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] replace=&#123;<span class="string">"|〇"</span>,<span class="string">"|壹"</span>,<span class="string">"|贰"</span>,<span class="string">"|叁"</span>,<span class="string">"|肆"</span>,<span class="string">"|伍"</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hashtable&lt;Character,Long&gt; digits = <span class="keyword">new</span> Hashtable();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] commonDigit =&#123;<span class="string">""</span>,<span class="string">"十"</span>,<span class="string">"百"</span>,<span class="string">"千"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] twiceDigit = &#123;<span class="string">"万"</span>,<span class="string">"亿"</span>,<span class="string">"兆"</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        digits.put(<span class="string">'十'</span>,<span class="number">10L</span>);</span><br><span class="line">        digits.put(<span class="string">'百'</span>,<span class="number">100L</span>);</span><br><span class="line">        digits.put(<span class="string">'千'</span>,<span class="number">1000L</span>);</span><br><span class="line">        digits.put(<span class="string">'万'</span>,<span class="number">10000L</span>);</span><br><span class="line">        digits.put(<span class="string">'亿'</span>,<span class="number">100000000L</span>);</span><br><span class="line">        digits.put(<span class="string">'兆'</span>,<span class="number">10000000000000000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可用于处理年份(如二〇一六)及多位数字</span></span><br><span class="line"><span class="comment">     * 若需添加错字验证，可在replace中对应位置放置；以|隔开</span></span><br><span class="line"><span class="comment">     * 若需添加更高位运算，请在digits中put相应元素，并注意修改long</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chineseNum</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parse</span><span class="params">(String chineseNum)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,len=chinese.length;i&lt;len;i++)&#123;</span><br><span class="line">            chineseNum =chineseNum.replaceAll(chinese[i]+replace[i],Integer.toString(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(chineseNum.matches(<span class="string">"[0-9]+"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> chineseNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//十六处理为一十六</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"十"</span>.equals(chineseNum.substring(<span class="number">0</span>,<span class="number">1</span>)))&#123;</span><br><span class="line">            chineseNum = <span class="string">"1"</span>.concat(chineseNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] cNums = chineseNum.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> getNum(cNums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 算法思路：</span></span><br><span class="line"><span class="comment">     * 倒序累加数字乘以其叠加倍数，</span></span><br><span class="line"><span class="comment">     * 如3千8百万亿中,</span></span><br><span class="line"><span class="comment">     * 3的叠加倍数(multi)是一千万亿,当前倍数(current)是一千,基数(base)是一万亿</span></span><br><span class="line"><span class="comment">     * 8的叠加倍数       是一百万亿,当前倍数         是一百,基数      是一万亿</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getNum</span><span class="params">(<span class="keyword">char</span>[] cNums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum =<span class="number">0</span>,multi = <span class="number">1</span>,current,last=<span class="number">1</span>,base=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=cNums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cNums[i]&gt;<span class="string">'9'</span>)&#123;</span><br><span class="line">                current = digits.get(cNums[i]);</span><br><span class="line">                <span class="comment">//当前倍数比基数大，则更新叠加倍数和基数为当前倍数</span></span><br><span class="line">                <span class="keyword">if</span>(current&gt;base)&#123;</span><br><span class="line">                    base = current;</span><br><span class="line">                    current = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    base = getBase(current, last, base);</span><br><span class="line">                &#125;</span><br><span class="line">                multi = current * base;</span><br><span class="line">                last = current;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum += (cNums[i]-<span class="string">'0'</span>)*multi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果当前倍数突然比上个倍数少，说明已进入到上个倍数的子倍数</span></span><br><span class="line"><span class="comment">     * 则更新叠加倍数为上个倍数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 比较基数和上个倍数</span></span><br><span class="line"><span class="comment">     *      基数&gt;上个倍数时(如三百万亿,读取到百时，base(亿)&gt;last(万))</span></span><br><span class="line"><span class="comment">     *          则更新基数为万亿</span></span><br><span class="line"><span class="comment">     *      基数&lt;上个倍数时(如三十亿零六十万，</span></span><br><span class="line"><span class="comment">     * 读取到十时进入，last(万)&gt;base(1)，更新基数为万</span></span><br><span class="line"><span class="comment">     * 读取到十时再次进入，last(亿)&gt;base(万),更新基数为亿</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getBase</span><span class="params">(<span class="keyword">long</span> current,<span class="keyword">long</span> last,<span class="keyword">long</span> base)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current&lt;last) &#123;</span><br><span class="line">            base = base &gt; last? base*last :last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将阿拉伯数字转换为中文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">format</span><span class="params">(<span class="keyword">long</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//千以上位计数器</span></span><br><span class="line">        <span class="keyword">int</span>[] twiceDigitCounter =<span class="keyword">new</span> <span class="keyword">int</span>[twiceDigit.length];</span><br><span class="line">        String numStr = simpleFormat(number);</span><br><span class="line">        <span class="comment">//&#123;三,零,零,零,零,五&#125;</span></span><br><span class="line">        <span class="keyword">char</span>[] nums = numStr.toCharArray();</span><br><span class="line">        StringBuffer addDigit = <span class="keyword">new</span> StringBuffer(nums.length*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> index =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> appendZero = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//倒序装载十百千，若遇千位以上，特殊处理(getDigitByCounter)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(appendZero&amp;&amp;lastIsNum(addDigit))&#123;</span><br><span class="line">                addDigit.append(<span class="string">"零"</span>);</span><br><span class="line">                appendZero = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index == commonDigit.length) &#123;</span><br><span class="line">                String current = getDigitByCounter(twiceDigitCounter);</span><br><span class="line">                String last = getLast(addDigit);</span><br><span class="line">                <span class="keyword">if</span>(indexOf(last)&lt;indexOf(current))&#123;</span><br><span class="line">                    addDigit.delete(addDigit.length()-<span class="number">1</span>,addDigit.length());</span><br><span class="line">                &#125;</span><br><span class="line">                addDigit.append(current);</span><br><span class="line">                index=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="string">'零'</span>) &#123;</span><br><span class="line">                appendZero =<span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (index != commonDigit.length) &#123;</span><br><span class="line">                    addDigit.append(commonDigit[index]);</span><br><span class="line">                &#125;</span><br><span class="line">                addDigit.append(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> addDigit.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 200173518 简单转换为 二零零一七三五一八</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">simpleFormat</span><span class="params">(<span class="keyword">long</span> number)</span></span>&#123;</span><br><span class="line">        String numStr = String.valueOf(number);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,len=chinese.length;i&lt;len;i++)&#123;</span><br><span class="line">            numStr =numStr.replaceAll(Integer.toString(i),chinese[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转换为中文的年</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getChineseNumYear</span><span class="params">(<span class="keyword">long</span> number)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;<span class="number">2000</span>||number&gt;<span class="number">2100</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"日期格式错误"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> simpleFormat(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 万出现两次则为亿，亿出现两次则为兆</span></span><br><span class="line"><span class="comment">     * 因此，千位以上从万计数，</span></span><br><span class="line"><span class="comment">     * 若万没出现过，则为万。</span></span><br><span class="line"><span class="comment">     * 若万出现过，则置万为没出现过，进位到亿</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getDigitByCounter</span><span class="params">(<span class="keyword">int</span>[] twiceDigitCounter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,len=twiceDigit.length;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(twiceDigitCounter[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                twiceDigitCounter[i]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> twiceDigit[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(twiceDigitCounter[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                twiceDigitCounter[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        twiceDigitCounter[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> twiceDigit[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到最后一位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> addDigit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getLast</span><span class="params">(StringBuffer addDigit)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(addDigit.length()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> addDigit.substring(addDigit.length()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 万亿兆。。。的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> digit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String digit)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,len=twiceDigit.length;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(twiceDigit[i].equals(digit))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> twiceDigit.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最后一位是否为非零数字(不可为万/亿等计位符)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> addDigit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lastIsNum</span><span class="params">(StringBuffer addDigit)</span></span>&#123;</span><br><span class="line">        String last =getLast(addDigit);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,len=chinese.length;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chinese[i].equals(last))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试年份及错别字</span></span><br><span class="line">        System.out.println(NumberUtil.parse(<span class="string">"贰〇一八"</span>));</span><br><span class="line">        System.out.println(NumberUtil.parse(<span class="string">"十六"</span>));</span><br><span class="line">        System.out.println(NumberUtil.parse(<span class="string">"二十"</span>));</span><br><span class="line">        System.out.println(NumberUtil.parse(<span class="string">"二千零四十五"</span>));</span><br><span class="line">        System.out.println(NumberUtil.parse(<span class="string">"三百二十五万零四十"</span>));</span><br><span class="line">        System.out.println(NumberUtil.parse(<span class="string">"三十亿零四十万"</span>));</span><br><span class="line">        System.out.println(NumberUtil.parse(<span class="string">"一万"</span>));</span><br><span class="line">        System.out.println(NumberUtil.parse(<span class="string">"九千万零一"</span>));</span><br><span class="line">        System.out.println(NumberUtil.parse(<span class="string">"三百万亿"</span>));</span><br><span class="line">        System.out.println(NumberUtil.parse(<span class="string">"一百二十三兆四千五百六十七万八千九百零一亿二千三百四十五万六千七百八十九"</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(NumberUtil.getChineseNumYear(<span class="number">2018</span>));</span><br><span class="line">        System.out.println(NumberUtil.format(<span class="number">16</span>));</span><br><span class="line">        System.out.println(NumberUtil.format(<span class="number">20</span>));</span><br><span class="line">        System.out.println(NumberUtil.format(<span class="number">2045</span>));</span><br><span class="line">        System.out.println(NumberUtil.format(<span class="number">3000400000L</span>));</span><br><span class="line">        System.out.println(NumberUtil.format(<span class="number">10000</span>));</span><br><span class="line">        System.out.println(NumberUtil.format(<span class="number">90000001</span>));</span><br><span class="line">        System.out.println(NumberUtil.format(<span class="number">300000000000000L</span>));</span><br><span class="line">        System.out.println(NumberUtil.format(<span class="number">1234567890123456789L</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">2018</span><br><span class="line">16</span><br><span class="line">20</span><br><span class="line">2045</span><br><span class="line">3250040</span><br><span class="line">3000400000</span><br><span class="line">10000</span><br><span class="line">90000001</span><br><span class="line">300000000000000</span><br><span class="line">1234567890123456789</span><br><span class="line">二零一八</span><br><span class="line">一十六</span><br><span class="line">二十</span><br><span class="line">二千零四十五</span><br><span class="line">三十亿零四十万</span><br><span class="line">一万</span><br><span class="line">九千万零一</span><br><span class="line">三百万亿</span><br><span class="line">一百二十三兆四千五百六十七万八千九百零一亿二千三百四十五万六千七百八十九</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 工具类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
