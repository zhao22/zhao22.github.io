<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>扇入扇出的思考</title>
      <link href="/2018/07/16/%E6%89%87%E5%85%A5%E6%89%87%E5%87%BA%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2018/07/16/%E6%89%87%E5%85%A5%E6%89%87%E5%87%BA%E7%9A%84%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<h2 id="扇入和扇出"><a href="#扇入和扇出" class="headerlink" title="扇入和扇出"></a>扇入和扇出</h2><p><strong>扇入</strong>(fan-in)和<strong>扇出</strong>(fan-out)是电学的词汇,指门电路的输入端和输出端的关系.<br>软件工程中指模块和模块间的调用关系.我们可以按照不同颗粒度,从模块,类,方法层面思考我们项目的架构设计.<br>扇入：是指直接调用该模块的上级模块的个数。扇入大表示模块的复用程序高.<br>扇出：是指该模块直接调用的下级模块的个数。扇出大表示模块的复杂度高.<br><a id="more"></a></p><h2 id="模块应用"><a href="#模块应用" class="headerlink" title="模块应用"></a>模块应用</h2><p>按照项目设计的说法,<strong>底层模块</strong>主要封装整个项目的规约(返回码,配置信息等)和工具类.<br>如果不算上调用项目外jar包,这个模块的<strong>扇出</strong>应该是<strong>0</strong>.<br>而这个模块为了达成项目规约的目的,项目中所有模块都会直接或间接地调用这个模块.所以base模块的<strong>扇入</strong>会较<strong>大</strong>.  </p><p>在此模块的上层,可以进行进一步的细分:<br>对数据库读写的通用封装模块,业务的通用封装模块(公式等底层方法)…</p><p>在其上就涉及具体业务逻辑的封装:<br>这里可能随着业务的复杂,会分成多层.但都要求<strong>扇出</strong>(引用的模块)<strong>尽量的小</strong>.<br>如果引用的模块太多,那么底层代码的迁移都会导致上层代码的相应调整.<br>测试和维护的成本都会提高.此时应该对相关联的底层模块进行合并,或者在其下增加中间模块.并对关联业务设计测试框架.<br>这样底层的模块变动,只用修正中间模块,并通过中间模块对应业务的测试即可.</p><p>而最<strong>顶层</strong>的模块可以有<strong>较大的扇出</strong>,因为到了这里,基本涉及的都是展示和控制.对于错综复杂的内部业务,保持内部未可知的模式,调用的是相应的接口.<br>大部分底层的修改不应该影响到这边的代码.</p><h2 id="方法和类的应用"><a href="#方法和类的应用" class="headerlink" title="方法和类的应用"></a>方法和类的应用</h2><p>方法和类的应用也类似.扇入扇出应尽量的小.<br>但也不是将所有代码合在一起那么简单.<br>也需要结合<strong>单一职责</strong>原则来设计,即类做的事单一,方法做的事也是单一的.如果只是写着玩实现简单的逻辑,那么把代码合在一起,变量之间的调用就会比较轻松.<br>但企业级代码是需要许多人合作,并长期维护的.合理区分代码层次可以使代码更易测试和维护,这里涉及两个极端:</p><ol><li>方法或类做的事太多:<br>由于方法和类做的事太多,那么中间的逻辑必然是可拆分的.这个方法出了问题,我们如果不了解具体数据环境,不能立刻定位到是哪部分逻辑出了问题.为这种方法编写测试框架,也必须为每一套逻辑都写一份整体测试代码.<br>还是应该将逻辑块拆分成多个单一方法,为单一方法编写测试代码,再为整体方法编写测试代码.</li><li>方法层数太多,扇入扇出太复杂:<br>这里和模块的缺点类似,底层的方法略微调整,所有调用的方法都必须随之调整.<br>试想你在改一个老项目,发现某个小BUG出在较底层方法上,导致输出值异常.但同时又有几十个方法在调用这个方法,你如何能确定哪些也因为这个BUG输入了错误的值,而哪些又是其他成员编写的,需要这个错误的值.<br>并且跟代码的时候,为无谓的事钻的太多也是很恶心的.</li></ol>]]></content>
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 基础语法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>递归的一点归纳</title>
      <link href="/2018/07/08/%E9%80%92%E5%BD%92%E7%9A%84%E6%83%B3%E6%B3%95/index/"/>
      <url>/2018/07/08/%E9%80%92%E5%BD%92%E7%9A%84%E6%83%B3%E6%B3%95/index/</url>
      <content type="html"><![CDATA[<h2 id="递归介绍"><a href="#递归介绍" class="headerlink" title="递归介绍"></a>递归介绍</h2><pre><code>递归指的是一个方法在方法体内直接或者间接地调用自身的情况.</code></pre><h2 id="递归示例"><a href="#递归示例" class="headerlink" title="递归示例"></a>递归示例</h2><p>以下是递归和循环的java代码比较:<br>循环:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printHelloWorldByLoop</span><span class="params">(String str, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length ; i ++)&#123;</span><br><span class="line">           System.out.println(str);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>递归:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printByRecursion</span><span class="params">(String str, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    printByRecursion(str, --length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="递归应用场景"><a href="#递归应用场景" class="headerlink" title="递归应用场景"></a>递归应用场景</h2><p>递归主要应用在生成<strong>不规则树</strong>的情况.这类情况一般<strong>退出条件明确</strong>,但<strong>循环次数不确定</strong>,并且<strong>循环体内做的事有两种及以上的情况</strong>.<br>绝大多数递归都可以使用循环来实现,但部分更适用于递归的实现转换为循环时就需要<strong>额外的存储</strong>或者对循环条件及循环体的<strong>归纳</strong>.<br>例如多级表头的生成:</p><p><table><br>    <tr><br>        <td colspan="4">一级表头</td><br>    </tr><br>    <tr><br>        <td colspan="2">二级表头1</td><br>        <td colspan="2">二级表头2</td><br>    </tr><br>    <tr><br>        <td colspan="2">三级表头1</td><br>        <td colspan="1">三级表头2</td><br>        <td colspan="1">三级表头3</td><br>    </tr><br>    <tr><br>        <td>…</td><br>        <td>…</td><br>        <td>…</td><br>        <td>…</td><br>    </tr><br></table><br>多级表头的情况下,数据库可能只会有parent_id这样的关联字段,但并不知道一共有多少级的表头,并且每个父节点下面有多少个子节点.<br>那么使用下面的递归伪代码就非常合适:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">treeHeadHandle</span>(<span class="params">id,parentId</span>)</span>&#123;</span><br><span class="line">doSomethingHereWithId(id, parentId);</span><br><span class="line"><span class="keyword">var</span> childIds = <span class="string">"SELECT id FROM table WHERE parent_id = "</span> + id;</span><br><span class="line"><span class="keyword">if</span>(!childIds || childIds.length === <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> childIds)&#123;</span><br><span class="line">treeHeadHandle(ids[i], id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而如果使用循环来解决相同问题的话,就必须额外存储进行状态来判断是否需要停止,并且父子关系必须由存储来处理:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> idToHandle = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">treeHeadHandle</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">idToHandle.push(&#123;<span class="attr">parentId</span>: <span class="string">""</span>, <span class="attr">id</span>:id&#125;);</span><br><span class="line"><span class="keyword">while</span>(idToHandle.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> id = idToHandle[<span class="number">0</span>][<span class="string">"id"</span>];</span><br><span class="line"><span class="keyword">var</span> parentId = idToHandle[<span class="number">0</span>][<span class="string">"parentId"</span>];</span><br><span class="line">idToHandle.splice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">doSomethingHereWithId(id, parentId);</span><br><span class="line"><span class="keyword">var</span> childIds = <span class="string">"SELECT id FROM table WHERE parent_id = "</span> + id;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> ids)&#123;</span><br><span class="line">idToHandle.push(&#123;<span class="attr">parentId</span>: id,<span class="attr">id</span>: ids[i]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其他的情况例如文件夹的遍历,快速排序使用递归都是比较好的选择.</p><h2 id="递归的缺点"><a href="#递归的缺点" class="headerlink" title="递归的缺点"></a>递归的缺点</h2><p>递归更像演绎的思维,一步一步推导最终结果.在实现一些步骤多少和步骤内执行事物不好归纳的时候,更有优势.<br>但递归也有它的缺点,主要在于重复计算和栈的消耗方面.<br>每一次递归,程序都会将当前域放到栈里面.而循环会重复覆盖栈.所以错误的递归程序很有可能导致栈溢出的问题:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br></pre></td></tr></table></figure></p><p>部分语言(如C++)的编译器,对尾递归做了优化,即递归方法在父方法的尾部时,会清除之前相关栈的内容,因为子方法操作的数据或者返回值已不会再对该域造成影响.</p>]]></content>
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 基础语法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis初探</title>
      <link href="/2018/05/25/Redis%E5%88%9D%E6%8E%A2/"/>
      <url>/2018/05/25/Redis%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>主要整理redis安装配置,应用场景,基本概念,API及java的使用。部分参考<a href="http://www.runoob.com/redis/redis-install.html" target="_blank" rel="noopener">菜鸟教程</a>。<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="windows-下安装"><a href="#windows-下安装" class="headerlink" title="windows 下安装"></a>windows 下安装</h3><p><a href="https://github.com/MSOpenTech/redis/releases" target="_blank" rel="noopener">点击下载</a><br>Redis 支持 32 位和 64 位。这个需要根据你系统平台的实际情况选择，这里我们下载 <strong>Redis-x64-xxx.zip</strong>压缩包到 C 盘，解压后，将文件夹重新命名为 <strong>redis</strong>。  </p><p>打开一个 cmd 窗口 使用cd命令切换目录到 C:\redis 运行 <strong>redis-server.exe redis.windows.conf</strong>。  </p><p>如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。输入之后，会显示redis界面.<br>这时候另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了。<br>切换到redis目录下运行 <strong>redis-cli.exe -h 127.0.0.1 -p 6379</strong> 。(客户端)</p><h3 id="Linux-下安装"><a href="#Linux-下安装" class="headerlink" title="Linux 下安装"></a>Linux 下安装</h3><p>本教程使用的最新文档版本为 2.8.17，下载并安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-2.8.17.tar.gz</span><br><span class="line">tar xzf redis-2.8.17.tar.gz</span><br><span class="line">cd redis-2.8.17</span><br><span class="line">make</span><br><span class="line">```  </span><br><span class="line">make完后 redis-2.8.17目录下会出现编译后的redis服务程序redis-server,还有用于测试的客户端程序redis-cli,两个程序位于安装目录 src 目录下：</span><br><span class="line">下面启动redis服务.</span><br><span class="line">```linux</span><br><span class="line">cd src</span><br><span class="line">./redis-server</span><br></pre></td></tr></table></figure></p><p>注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br><span class="line">./redis-server redis.conf</span><br></pre></td></tr></table></figure></p><p>redis.conf是一个默认的配置文件。我们可以根据需要使用自己的配置文件。<br>启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了。 比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br><span class="line">./redis-cli</span><br><span class="line">redis&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line">redis&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br></pre></td></tr></table></figure></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG GET CONFIG_SETTING_NAME</span><br><span class="line">CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE</span><br></pre></td></tr></table></figure><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">默认值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">daemonize</td><td style="text-align:center">no</td><td style="text-align:center">redis默认不是以守护进程的方式运行，可以通过该配置项修改,使用yes启用守护进程。若不是守护进程,在windows界面下,关闭控制界面就会关掉redis服务器。在linux服务器时,配置开机启动必须开启守护进程</td></tr><tr><td style="text-align:center">pidfile</td><td style="text-align:center">/var/run/redis/pid</td><td style="text-align:center">当redis以守护进程方式运行时,默认把pid写入该文件夹</td></tr><tr><td style="text-align:center">port</td><td style="text-align:center">6379</td><td style="text-align:center">监听端口</td></tr><tr><td style="text-align:center">bind</td><td style="text-align:center">127.0.0.1</td><td style="text-align:center">主机地址</td></tr><tr><td style="text-align:center">timeout</td><td style="text-align:center">0</td><td style="text-align:center">客户端闲置多长时间后关闭连接,默认为0,表示关闭该功能</td></tr><tr><td style="text-align:center">loglevel</td><td style="text-align:center">verbose</td><td style="text-align:center">指定日志记录级别,redis总共支持四个级别: debug、verbose、notice、warning</td></tr><tr><td style="text-align:center">databases</td><td style="text-align:center">16</td><td style="text-align:center">设置数据库的数量,客户端如果不指定,默认使用0数据库.可以使用SELECT <dbid> 命令在连接上指定数据库id</dbid></td></tr><tr><td style="text-align:center">save <seconds><changes></changes></seconds></td><td style="text-align:center">[900 1][300 10][60 100000]</td><td style="text-align:center">指定在多长时间内，有多少次更新操作,就将数据同步到数据文件。默认1分钟10000次，5分钟10次，15分钟内1次就保存</td></tr><tr><td style="text-align:center">rdbcompression</td><td style="text-align:center">yes</td><td style="text-align:center">指定存储到本地数据库时是否压缩数据,默认为yes,redis采用LZF压缩,如果为了节省CPU时间,可以关闭该选项,但会导致数据库文件变得巨大</td></tr><tr><td style="text-align:center">dbfilename</td><td style="text-align:center">dump.rdb</td><td style="text-align:center">指定本地数据库文件名</td></tr><tr><td style="text-align:center">dir</td><td style="text-align:center">./</td><td style="text-align:center">指定本地数据库存放目录</td></tr><tr><td style="text-align:center">slaveof <masterip><masterport></masterport></masterip></td><td style="text-align:center">关闭</td><td style="text-align:center">设置当本机为slave服务时,在服务启动时，会自动从master上进行数据同步</td></tr><tr><td style="text-align:center">masterauth<master-password></master-password></td><td style="text-align:center">关闭</td><td style="text-align:center">当master服务设置了密码保护时,slave服务连接master的密码</td></tr><tr><td style="text-align:center">requirepass</td><td style="text-align:center">foobared</td><td style="text-align:center">设置redis连接密码,配置之后,客户端在连接redis服务时需要通过AUTH<password>命令提供密码</password></td></tr><tr><td style="text-align:center">maxclients</td><td style="text-align:center">0</td><td style="text-align:center">设置同一时间最大客户端连接数,默认无限制,redis可以同时打开的客户端连接数为redis进程可以打开的最大文件描述符数。如果设置maxclients 0,表示不作限制.当客户端连接达到限制时,Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</td></tr><tr><td style="text-align:center">maxmemory <bytes></bytes></td><td style="text-align:center">关闭</td><td style="text-align:center">指定redis最大内存限制,redis在启动时会把数据加载到内存中,达到最大内存后,redis会先尝试清除已到期或即将到期的key,当此方法处理后,仍然到达最大内存设置,将无法再进行写入操作,但仍然可以进行读取操作。redis新的vm机制,会把key存放在内存,value会存在swap区。</td></tr><tr><td style="text-align:center">appendonly</td><td style="text-align:center">no</td><td style="text-align:center">指定是否在每次更新操作后进行日志记录,redis在默认情况下是异步的把数据写入磁盘,如果不开启,可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面save条件来同步的,所以有的数据会在一段时间内只存在于内存中</td></tr><tr><td style="text-align:center">appendfilename</td><td style="text-align:center">appendonly.aof</td><td style="text-align:center">指定更新日志文件名</td></tr><tr><td style="text-align:center">appendfsync</td><td style="text-align:center">everysec</td><td style="text-align:center">指定更新日志条件 no:表示等操作系统进行数据缓存同步到磁盘(快); always:表示每次更新操作后手动调用fsync()将数据写到磁盘(慢,安全);everysec:表示每秒同步一次(折衷)</td></tr><tr><td style="text-align:center">vm-enabled</td><td style="text-align:center">no</td><td style="text-align:center">指定是否启用虚拟内存机制.VM机制将数据分页存放, 由redis将访问量较少的页即冷数据swap到磁盘上,访问多的页面由磁盘自动换出到内存中.</td></tr><tr><td style="text-align:center">vm-swap-file</td><td style="text-align:center">/tmp/redis.swap</td><td style="text-align:center">虚拟内存文件路径,不可多个redis实力共享</td></tr><tr><td style="text-align:center">vm-max-memory</td><td style="text-align:center">0</td><td style="text-align:center">将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的,也就是说,当vm-max-memory设置为0的时候,其实是所有的value都存在于磁盘</td></tr><tr><td style="text-align:center">vm-page-size</td><td style="text-align:center">32</td><td style="text-align:center">redis swap文件分成了很多的page,一个对象可以保存在多个page上面,但一个page上不能被多个对象共享,vm-page-size是要根据存储的数据大小来设定的,作者建议如果存储很多小对象,page大小最好设置为32或者64bytes；如果存储很大对象,则可以使用更大的page</td></tr><tr><td style="text-align:center">vm-pages</td><td style="text-align:center">134217728</td><td style="text-align:center">设置swap文件中的page数量,由于页表(一种表示页面空闲或使用的bitmap)是放在内存中的,在磁盘上每8个pages将消耗1byte的内存</td></tr><tr><td style="text-align:center">vm-max-threads</td><td style="text-align:center">4</td><td style="text-align:center">设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的。可能会造成比较长时间的延迟</td></tr><tr><td style="text-align:center">hash-max-zipmap-entries</td><td style="text-align:center">64</td><td style="text-align:center">指定在超过该数量采用哈希算法</td></tr><tr><td style="text-align:center">hash-max-zipmap-value</td><td style="text-align:center">512</td><td style="text-align:center">指定最大的元素超过该值时采用哈希算法</td></tr><tr><td style="text-align:center">activerehashing</td><td style="text-align:center">yes</td><td style="text-align:center">指定是否激活重置哈希</td></tr><tr><td style="text-align:center">include</td><td style="text-align:center"></td><td style="text-align:center">指定包含其他的配置文件,可以在同一主机上多个redis实例之间使用同一份配置文件。而同时各个实例又拥有自己的特定配置文件</td></tr></tbody></table><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>会话缓存（最常用）</li><li>消息队列，比如支付</li><li>活动排行榜或计数</li><li>发布、订阅消息（消息通知）</li><li>商品列表、评论列表等</li></ol><h2 id="数据类型API"><a href="#数据类型API" class="headerlink" title="数据类型API"></a>数据类型API</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>远程连接:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h host -p port -a password</span><br></pre></td></tr></table></figure></p><p>测试连接:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PING</span><br></pre></td></tr></table></figure></p><h3 id="键"><a href="#键" class="headerlink" title="键"></a>键</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><font style="color:red"><strong>DEL</strong></font> key</td><td style="text-align:center">删除</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>DUMP</strong></font> key</td><td style="text-align:center">序列化,并返回被序列化的值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>EXISTS</strong></font> key</td><td style="text-align:center">检查是否存在</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>EXPIRE</strong></font> key seconds</td><td style="text-align:center">为给定key设置过期时间</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>EXPIREAT</strong></font> key timestamp</td><td style="text-align:center">设置过期时间,接受UNIX时间戳</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>KEYS</strong></font> pattern</td><td style="text-align:center">查找所有符合给定模式(pattern)的key</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>MOVE</strong></font> key db</td><td style="text-align:center">将当前数据库的 key 移动到指定数据库db当中</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>PERSIST</strong></font> key</td><td style="text-align:center">移除key的过期时间,key将持久保持</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>PTTL</strong></font> key</td><td style="text-align:center">以毫秒为单位返回key的剩余的过期时间</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>TTL</strong></font> key</td><td style="text-align:center">以秒为单位, 返回给定key的剩余生存时间(time to live)</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>RANDOMKEY</strong></font></td><td style="text-align:center">从当前数据库随机返回一个key</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>RENAME</strong></font> key newkey</td><td style="text-align:center">修改key 的名称</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>RENAMENX</strong></font> key newkey</td><td style="text-align:center">仅当new key 不存在时,将key 改名为 newkey</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>TYPE</strong></font> key</td><td style="text-align:center">返回key 所储存的值的类型</td></tr></tbody></table><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><font style="color:red"><strong>SET</strong></font> key value</td><td style="text-align:center">设置值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>GET</strong></font> key</td><td style="text-align:center">获取值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>GETRANGE</strong></font> key start end</td><td style="text-align:center">返回字符串的子字符(substring)</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>GETSET</strong></font> key value</td><td style="text-align:center">设置值，并返回原值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>GETBIT</strong></font> key offset</td><td style="text-align:center">对 key 所储存的字符串值，获取指定偏移量上的位(bit)</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>MGET</strong></font> key1 [key2..]</td><td style="text-align:center">获取所有(一个或多个)给定的值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SETBIT</strong></font> key offset value</td><td style="text-align:center">对key 所储存的字符串值,设置或清除指定偏移量上的位(bit)</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SETEX</strong></font> key seconds value</td><td style="text-align:center">将值value 关联到key,并将key的过期时间设为seconds(以秒为单位)</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SETNX</strong></font> key value</td><td style="text-align:center">只有在key 不存在时设置key的值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SETRANGE</strong></font> key offset value</td><td style="text-align:center">用value 参数覆写给定key 所储存的字符串值,从偏移量offset开始</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>STRLEN</strong></font> key</td><td style="text-align:center">返回key 所储存的字符串值的长度</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>MSET</strong></font> key value[key value…]</td><td style="text-align:center">同时设置一个或多个key-value对</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>MSETNX</strong></font> key value[key value]</td><td style="text-align:center">同时设置一个或多个key-value对,当且仅当所有给定key 都不存在</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>PSETEX</strong></font> key milliseconds</td><td style="text-align:center">这个命令和SETEX命令相似,但它以毫秒为单位设置key的生存时间,而不是像SETEX命令那样,以秒为单位</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>INCR</strong></font> key</td><td style="text-align:center">将key中储存的数字值增一</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>INCRBY</strong></font> key increment</td><td style="text-align:center">将key所储存的值加上给定的增量值(increment)</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>INCRBYFLOAT</strong></font> key increment</td><td style="text-align:center">将key所储存的值加上给定的浮点增量值(increment)</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>DECR</strong></font> key</td><td style="text-align:center">将 key 中储存的数字值减一</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>DECRBY</strong></font> key decrement</td><td style="text-align:center">key所储存的值减去给定的减量值(decrement)</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>APPEND</strong></font> key value</td><td style="text-align:center">如果key已经存在并且是一个字符串, APPEND命令将制定的value追加到该key原来值(value)的末尾</td></tr></tbody></table><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><font style="color:red"><strong>HDEL</strong></font> key field1[field2..]</td><td style="text-align:center">删除一个或多个哈希表字段</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HEXISTS</strong></font>** key field</td><td style="text-align:center">查看哈希表key中,指定的字段是否存在</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HGET</strong></font> key field</td><td style="text-align:center">获取存储在哈希表中指定字段的值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HGETALL</strong></font> key</td><td style="text-align:center">获取在哈希表指定key的所有字段和值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HINCRBY</strong></font> key field increment</td><td style="text-align:center">为哈希表key中指定字段的整数值加上增量 increment</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HINCRBYFLOAT</strong></font> key field increment</td><td style="text-align:center">为哈希表key中指定字段的浮点数值加上增量increment</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HKEYS</strong></font> key</td><td style="text-align:center">获取所有哈希表中的字段</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HLEN</strong></font> key</td><td style="text-align:center">获取哈希表中字段的数量</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HMGET</strong></font> key field1 [field2]</td><td style="text-align:center">获取所有给定字段的值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HMSET</strong></font> key field1 value1 [field2 value2]</td><td style="text-align:center">同时将多个field-value(域-值)对设置到哈希表key 中</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HSET</strong></font> key field value</td><td style="text-align:center">将哈希表key中字段field的值设为value</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HSETNX</strong></font> key field value</td><td style="text-align:center">只有在字段field不存在时,设置哈希表字段的值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HVALS</strong></font> key</td><td style="text-align:center">获取哈希表中所有值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>HSCAN</strong></font> key cursor[MATCH pattern][COUNT count]</td><td style="text-align:center">迭代哈希表中的键值对</td></tr></tbody></table><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><font style="color:red"><strong>BLPOP</strong></font> key1[key2] timeout</td><td style="text-align:center">移出并获取列表的第一个元素,如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>BRPOP</strong></font> key1[key2] timeout</td><td style="text-align:center">移出并获取列表的最后一个元素,如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>BRPOPLPUSH</strong></font> source destination timeout</td><td style="text-align:center">从列表中弹出一个值,将弹出的元素插入到另外一个列表中并返回它;如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>LINDEX</strong></font> key index</td><td style="text-align:center">通过索引获取列表中的元素</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>LINSERT</strong></font> key BEFORE/AFTER pivot value</td><td style="text-align:center">在列表的元素前或者后插入元素</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>LLEN</strong></font> key</td><td style="text-align:center">获取列表长度</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>LPOP</strong></font> key</td><td style="text-align:center">移出并获取列表的第一个元素</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>LPUSH</strong></font> key value1[value2..]</td><td style="text-align:center">将一个或多个值插入到列表头部</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>LPUSHX</strong></font> key value</td><td style="text-align:center">将一个值插入到已存在的列表头部</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>LRANGE</strong></font> key start stop</td><td style="text-align:center">获取列表指定范围内的元素</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>LREM</strong></font> key count value</td><td style="text-align:center">移除列表元素</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>LSET</strong></font> key index value</td><td style="text-align:center">通过索引设置列表元素的值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>LTRIM</strong></font> key start stop</td><td style="text-align:center">对一个列表进行修剪(trim),就是说,让列表只保留指定区间内的元素,不在指定区间之内的元素都将删除</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>RPOP</strong></font> key</td><td style="text-align:center">移除并获取列表最后一个元素</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>RPOPLPUSH</strong></font> source destination</td><td style="text-align:center">移除列表最后一个元素,并将该元素添加到另一个列表并返回</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>RPUSH</strong></font> key value1[value2…]</td><td style="text-align:center">在列表中添加一个或多个值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>RPUSHX</strong></font> key value</td><td style="text-align:center">为已存在的列表添加值</td></tr></tbody></table><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><font style="color:red"><strong>SADD</strong></font> key member1[member2]</td><td style="text-align:center">向集合添加一个或多个成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SCARD</strong></font> key</td><td style="text-align:center">获取集合的成员数</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SDIFF</strong></font> key1[key2]</td><td style="text-align:center">返回给定所有集合的差集</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SDIFFSTORE</strong></font> destination key1[key2]</td><td style="text-align:center">返回给定所有集合的差集并存储在destination中</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SINTER</strong></font> key1[key2]</td><td style="text-align:center">返回给定所有集合的交集</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SINTERSTORE</strong></font> destination key1[key2]</td><td style="text-align:center">返回给定所有集合的交集并存储在destination中</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SISMEMBER</strong></font> key member</td><td style="text-align:center">判断member 元素是否是集合key 的成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SMEMBERS</strong></font> key</td><td style="text-align:center">返回集合中的所有成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SMOVE</strong></font> source destination member</td><td style="text-align:center">将member元素从source集合移动到destination集合</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SPOP</strong></font> key</td><td style="text-align:center">移除并返回集合中的一个随机元素</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SRANDMEMBER</strong></font> key[count]</td><td style="text-align:center">返回集合中一个或多个随机数</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SREM</strong></font> key member1[member2]</td><td style="text-align:center">移除集合中一个或多个成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SUNION</strong></font> key1[key2]</td><td style="text-align:center">返回所有给定集合的并集</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SUNIONSTORE</strong></font> destination key1[key2]</td><td style="text-align:center">将所有给定集合的并集存储在destination 集合中</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>SSCAN</strong></font> key cursor[MATCH pattern][COUNT count]</td><td style="text-align:center">迭代集合中的元素</td></tr></tbody></table><h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><font style="color:red"><strong>ZADD</strong></font> key score1 member1[score2 member2]</td><td style="text-align:center">向有序集合添加一个或多个成员,或者更新已存在成员的分数</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZCARD</strong></font> key</td><td style="text-align:center">获取有序集合的成员数</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZCOUNT</strong></font> key min max</td><td style="text-align:center">计算在有序集合中指定区间分数的成员数</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZINCRBY</strong></font> key increment member</td><td style="text-align:center">有序集合中对指定成员的分数加上增量increment</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZINTERSTORE</strong></font> destination numkeys key [key…]</td><td style="text-align:center">计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合key中</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZLEXCOUNT</strong></font> key min max</td><td style="text-align:center">在有序集合中计算指定字典区间内成员数量</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZRANGE</strong></font> key start stop[WITHSCORES]</td><td style="text-align:center">通过索引区间返回有序集合指定区间的成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZRANGEBYLEX</strong></font> key min max[LIMIT offset count]</td><td style="text-align:center">通过字典区间返回有序集合的成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZRANGEBYSCORE</strong></font> key min max[WITHSCORES]_[LIMIT]</td><td style="text-align:center">通过分数返回有序集合指定区间内的成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZRANK</strong></font> key member</td><td style="text-align:center">返回有序集合中指定成员的索引</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZREM</strong></font> key member[member…]</td><td style="text-align:center">移除有序集合中的一个或多个成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZREMRANGEBYLEX</strong></font> key min max</td><td style="text-align:center">移除有序集合中给定的字典区间的所有成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZREMRANGEBYRANK</strong></font> key start stop</td><td style="text-align:center">移除有序集合中给定排名区间的所有成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZREMRANGEBYSCORE</strong></font> key min max</td><td style="text-align:center">移除有序集合中给定的分数区间的所有成员</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZREVRANGE</strong></font> key start stop [WITHSCORES]</td><td style="text-align:center">返回有序集中指定区间内的成员,通过索引,分数由高到低</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZREVRABGEBYSCORE</strong></font> key max min[WITHSCORES]</td><td style="text-align:center">返回有序集中指定分数区间内的成员,分数由高到低排序</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZREVRANK</strong></font> key member</td><td style="text-align:center">返回有序集合中指定成员的排名,有序集成员按分数值递减排序</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZSCORE</strong></font> key member</td><td style="text-align:center">返回有序集中,成员的分数值</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZUNIONSTORE</strong></font> destination numkeys key[key…]</td><td style="text-align:center">计算给定的一个或多个有序集的并集,并存储在新的key中</td></tr><tr><td style="text-align:center"><font style="color:red"><strong>ZSCAN</strong></font> key cursor [MATCH pattern][COUNT count]</td><td style="text-align:center">迭代有序集合中的元素(包括元素成员和元素分值)</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> nosql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>idea开发常用指令</title>
      <link href="/2018/05/25/idea%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2018/05/25/idea%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>博客介绍 WINDOWS下 Intellj IDEA 原生快捷键。<br>分为 通用指令(大部分IDE都支持的快捷功能)、文件操作指令、项目索引指令三个部分。<br><a id="more"></a></p><h2 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h2><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">CTRL+C</td><td style="text-align:center">复制</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CTRL+V</td><td style="text-align:center">粘贴</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CTRL+F</td><td style="text-align:center">搜索</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CTRL+R</td><td style="text-align:center">替换</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CTRL+A</td><td style="text-align:center">全选</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CTRL+/</td><td style="text-align:center">注释</td><td style="text-align:center">也可取消注释</td></tr><tr><td style="text-align:center">CTRL+S</td><td style="text-align:center">保存</td><td style="text-align:center">一般不设置支持自动保存</td></tr><tr><td style="text-align:center">SHIFT+ENTER</td><td style="text-align:center">新建一行，光标移至行首</td></tr></tbody></table><h2 id="文件操作指令"><a href="#文件操作指令" class="headerlink" title="文件操作指令"></a>文件操作指令</h2><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">ALT+/</td><td style="text-align:center">查看描述</td><td style="text-align:center">导包、查看错误提示…</td></tr><tr><td style="text-align:center">CTRL+W</td><td style="text-align:center">选择当前单词</td><td style="text-align:center">再次点击依次选择:包含周围符号、方法参数、句子、行、方法体、方法…</td></tr><tr><td style="text-align:center">CTRL+SHIFT+W</td><td style="text-align:center">反选</td><td style="text-align:center">返回CTRL+W的选择</td></tr><tr><td style="text-align:center">CTRL+Y</td><td style="text-align:center">删除当前行</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CTRL+X</td><td style="text-align:center">剪切</td><td style="text-align:center">这个单独提出来，因为在没有选择文本的情况下,该操作是剪切当前行,按着比Y方便</td></tr><tr><td style="text-align:center">CTRL+D</td><td style="text-align:center">复制当前行</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CTRL+G</td><td style="text-align:center">定位到指定行</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ALT+↑/↓</td><td style="text-align:center">到上/下个方法</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CTRL+SHIFT+[1-0]</td><td style="text-align:center">标记</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CTRL+[1-0]</td><td style="text-align:center">快速定位到标记位置</td><td style="text-align:center">飞雷神之术..其实F11的搭配能配置的更多。但按键比较复杂而且一般1-0就够用了</td></tr><tr><td style="text-align:center">ALT+INSERT</td><td style="text-align:center">生成方法</td><td style="text-align:center">getter啊,setter啊,Constructor…</td></tr><tr><td style="text-align:center">CTRL+SHIFT+V</td><td style="text-align:center">剪贴板</td><td style="text-align:center">最近复制的内容都会显示在上面</td></tr><tr><td style="text-align:center">CTRL+B</td><td style="text-align:center">进入</td><td style="text-align:center">可以查看光标位置的类或者方法内容,和CTRL+鼠标左键功能一样</td></tr><tr><td style="text-align:center">ALT+SHIFT+鼠标左键</td><td style="text-align:center">多光标同时操作</td><td style="text-align:center">也可以按住中间滚轮拖动</td></tr></tbody></table><h2 id="项目索引指令"><a href="#项目索引指令" class="headerlink" title="项目索引指令"></a>项目索引指令</h2><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">CTRL+N</td><td style="text-align:center">寻找类</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">CTRL+SHIFT+N</td><td style="text-align:center">寻找文件</td><td style="text-align:center">可以在后面+/寻找文件夹</td></tr><tr><td style="text-align:center">CTRL+SHIFT+F</td><td style="text-align:center">寻找字符串</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">SHIFT * 2</td><td style="text-align:center">全局搜索</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ALT+F1弹框后ENTER</td><td style="text-align:center">定位到文件所在位置</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ALT+F1弹框后C</td><td style="text-align:center">在文件夹中打开当前文件</td><td style="text-align:center"></td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> Intellj Idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Intellj Idea </tag>
            
            <tag> 开发工具 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>堆排序实现及数学思考</title>
      <link href="/2018/05/23/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%95%B0%E5%AD%A6%E6%80%9D%E8%80%83/"/>
      <url>/2018/05/23/%E5%A0%86%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%95%B0%E5%AD%A6%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<h2 id="文章简介"><a href="#文章简介" class="headerlink" title="文章简介"></a>文章简介</h2><p>堆排序java算法,排序的思想理解以及里面数学部分的思考。<br><a id="more"></a></p><h2 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> https://www.cnblogs.com/chengxiao/p/6129630.html </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> []arr = &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">10</span>&#125;;  </span><br><span class="line">        sort(arr);  </span><br><span class="line">        System.out.println(Arrays.toString(arr));  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;  </span><br><span class="line">        <span class="comment">//1.构建大顶堆  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;  </span><br><span class="line">            <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构  </span></span><br><span class="line">            adjustHeap(arr,i,arr.length);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;  </span><br><span class="line">            <span class="comment">//将堆顶元素与末尾元素进行交换  </span></span><br><span class="line">            swap(arr,<span class="number">0</span>,j);  </span><br><span class="line">            <span class="comment">//重新对堆进行调整  </span></span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>,j);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上） </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;  </span><br><span class="line">        <span class="comment">//先取出当前元素i  </span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];  </span><br><span class="line">        <span class="comment">//从i结点的左子结点开始，也就是2i+1处开始  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;  </span><br><span class="line">            <span class="comment">//如果左子结点小于右子结点，k指向右子结点  </span></span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="number">1</span>])&#123;  </span><br><span class="line">                k++;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）  </span></span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt;temp)&#123;  </span><br><span class="line">                arr[i] = arr[k];  </span><br><span class="line">                i = k;  </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//将temp值放到最终的位置  </span></span><br><span class="line">        arr[i] = temp;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 交换元素 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> temp=arr[a];  </span><br><span class="line">        arr[a] = arr[b];  </span><br><span class="line">        arr[b] = temp;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h2><h3 id="顶堆的概念"><a href="#顶堆的概念" class="headerlink" title="顶堆的概念"></a>顶堆的概念</h3><p>堆排序处理顺序的特点是升序使用大顶堆，降序使用小顶堆。<br><strong>大顶堆</strong>（又叫大根堆，最大堆）：<br>子节点的值一定小于父节点。<br>即下图中，(1)的值大于(2)、(3)的值<br><img src="http://www.ashasean.cn/blog-image/heap1.png" alt="顶堆示意图"><br>有的人觉得升序应该使用小顶堆，这样从上自下依次读取(1)(2)(3)，就是一个升序的数组；<br>这实际上是误解了堆排序的实现方式，因为堆排序没有进行横向排序的。即(2)和(3)没有固定的大小关系。</p><h3 id="堆排序的实现步骤"><a href="#堆排序的实现步骤" class="headerlink" title="堆排序的实现步骤"></a>堆排序的实现步骤</h3><p>将数组看作一个二叉树。数组从左至右依次对应二叉树从上至下从左至右的元素，如下图是一个长度为12的数组对应的二叉树示意图，数字为对应数组的下标。<br><img src="http://www.ashasean.cn/blog-image/heap2.png" alt="二叉树示意图">  </p><ol><li>首先从末尾父节点(5)开始，比较两个子节点和父节点的大小，将最大值和父节点交换。然后按(4)，(3)，(2)，(1)，(0)的顺序一直遍历到根节点。此时得到一个大顶堆。</li><li>在大顶堆中，根节点(0)的值一定是最大值。所以此时将根节点的值置于末尾。【即交换(0)和(11)的值】</li><li>再次基于剩下的元素构建大顶堆，并将根节点值置于当前末尾。。。。</li></ol><p>这样做在第二次开始每一次构建大顶堆时，除开顶层元素a，第二层开始都是构建好的大顶堆，不需比较所有元素，只需要不停交换a和剩下旁支中较大的元素即可。<br>如下图是第二次比较及交换的其中一种情况。<br><img src="http://www.ashasean.cn/blog-image/heap3.png" alt="比较示意图">  </p><h2 id="数学思考"><a href="#数学思考" class="headerlink" title="数学思考"></a>数学思考</h2><h3 id="为什么最末父节点的坐标为array-length-2-1"><a href="#为什么最末父节点的坐标为array-length-2-1" class="headerlink" title="为什么最末父节点的坐标为array.length/2-1?"></a>为什么最末父节点的坐标为array.length/2-1?</h3><p>由于数组的起始坐标为0，我们可以简单地理解一个元素的坐标为它之前元素的总个数。<br>二叉树可按每层的元素个数转换为一个基数为1，比值为2的等比数列（除开叶子层)；<br>可得第n层的元素个数为2^(n-1)<br>1~n层的元素个数和为2^(n-1)-1<br><img src="http://www.ashasean.cn/blog-image/heap4.png" alt="数学运算"><br>以上图为例：<br>此时，最末父节点所在层n为第三层，最末父节点的子节点数count =1；</p><p>由等比数列性质可知：</p><p>该节点之前的元素个数为： 2^(n-1)-1+(x-count)/2;</p><p>该节点之后的元素个数为： 2^(n-1)-1-(x-count)/2-1+x;</p><p>设m = 2^(n-1) -1 +x/2</p><p>则该节点之前的元素个数为： m-count/2</p><p>该节点之后的元素个数为：m+count/2</p><p>array.length = 节点之前元素+节点+节点之后元素 = 2m+1</p><p>m = (array.length-1)/2</p><p>可得该节点下标为其之前的元素个数：</p><p>(array.length -1)/2 -count/2…………………………………………………………(1)</p><p>由于java浮点数转int总是截断小数点后的数（即1/2取值为0）：</p><p>若count =1：</p><p> 则array.length为偶数;array.length-1为奇数；</p><p> (array.length-1)/2 = (array.length)/2 -1;</p><p> 同时count/2舍去；</p><p> (1)式可转换为 array.length/2 -1;</p><p>若count = 2 :</p><p> 则array.length为奇数;array.length-1为偶数;</p><p> (array.length-1)/2 = (array.length)/2;</p><p>count/2 = 1;</p><p>(2)式也可转换为array.length/2 - 1;</p><h3 id="为什么某节点的左子节点的坐标-该节点坐标i-2-1？"><a href="#为什么某节点的左子节点的坐标-该节点坐标i-2-1？" class="headerlink" title="为什么某节点的左子节点的坐标 = 该节点坐标i*2+1？"></a>为什么某节点的左子节点的坐标 = 该节点坐标i*2+1？</h3><p>将上个问题的最末父节点看作二叉树中的某一节点，则上个问题中count=1情况下的array.length即为子节点的坐标。</p><p>可得关系：</p><p> （子节点坐标-1）/2 = 父节点坐标。</p><p> 即 父节点坐标的左子节点坐标 = 父节点坐标 * 2 + 1</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>(转载)编码那点事</title>
      <link href="/2018/05/23/%E8%BD%AC%E8%BD%BD-%E7%BC%96%E7%A0%81%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
      <url>/2018/05/23/%E8%BD%AC%E8%BD%BD-%E7%BC%96%E7%A0%81%E9%82%A3%E7%82%B9%E4%BA%8B/</url>
      <content type="html"><![CDATA[<h2 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h2><p>电脑是如何从电信号转变为英文、数字、符号乃至整个语言系统的,这篇文章讲的太棒了。<br>原文来源于<a href="https://www.zhihu.com/question/23374078/answer/69732605" target="_blank" rel="noopener">知乎</a><br><a id="more"></a></p><h2 id="由电信号到ASCII"><a href="#由电信号到ASCII" class="headerlink" title="由电信号到ASCII"></a>由电信号到ASCII</h2><p>很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为”<strong>字节</strong>  “。再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”<strong>计算机</strong>“。<br>开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。<br>他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作：<br>遇上0×10, 终端就换行；<br>遇上0×07, 终端就向人们嘟嘟叫；<br>遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。<br>他们看到这样很好，于是就把这些0×20以下的字节状态称为”控制码”。他们又把所有的空 格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉 很好，于是大家都把这个方案叫做 <strong>ANSI</strong> 的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的<strong>ASCII</strong>方案来保存英文文字。<br>后来，就像建造巴比伦塔一样，世界各地都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用 127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128 到255这一页的字符集被称”<strong>扩展字符集</strong>“。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！  </p><h2 id="中文的发展历程-GB2312-、-GBK-、-GB18030-DBCS"><a href="#中文的发展历程-GB2312-、-GBK-、-GB18030-DBCS" class="headerlink" title="中文的发展历程:GB2312 、 GBK 、 GB18030(DBCS)"></a>中文的发展历程:GB2312 、 GBK 、 GB18030(DBCS)</h2><p>等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。中国人民看到这样很不错，于是就把这种汉字方案叫做 “<strong>GB2312</strong>“。GB2312 是对 ASCII 的中文扩展。  </p><p>但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把GB2312 没有用到的码位找出来老实不客气地用上。后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 <strong>GBK</strong> 标准，GBK包括了GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。 后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK扩成了 <strong>GB18030</strong>。从此之后，中华民族的文化就可以在计算机时代中传承了。 中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “<strong>DBCS</strong>“（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍： “一个汉字算两个英文字符！一个汉字算两个英文字符……”  </p><p>因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，像是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ 真是计算机的巴比伦塔命题啊！  </p><h2 id="巴比伦塔问题的解决方案-unicode"><a href="#巴比伦塔问题的解决方案-unicode" class="headerlink" title="巴比伦塔问题的解决方案:unicode"></a>巴比伦塔问题的解决方案:unicode</h2><p>正在这时，大天使加百列及时出现了——一个叫 <strong>ISO</strong>（国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号 的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 <strong>UCS</strong>, 俗称 “<strong>unicode</strong>“。  </p><p>unicode开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ASCII里的那些“半角”字符，unicode包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。  </p><p>这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的 strlen 函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是的，从unicode开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的”<strong>一个字符</strong>“！同时，也都是统一的”<strong>两个字节</strong>“，请注意”字符”和”字节”两个术语的不同，“<strong>字节</strong>”是一个8位的物理存贮单元，而“<strong>字符</strong>”则是一个文化相关的符号。在unicode中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。<br>unicode同样也不完美，这里就有两个的问题，一个是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费，文本文件的大小会因此大出二三倍，这是难以接受的。  </p><h2 id="unicode-的数据传输解决方法-UTF-X"><a href="#unicode-的数据传输解决方法-UTF-X" class="headerlink" title="unicode 的数据传输解决方法:UTF-X"></a>unicode 的数据传输解决方法:UTF-X</h2><p>unicode在很长一段时间内无法推广，直到互联网的出现，为解决unicode如何在网络上传输的问题，于是面向传输的众多 <strong>UTF</strong>（UCS Transfer Format）标准出现了，顾名思义，<strong>UTF-8</strong>就是每次8个位传输数据，而<strong>UTF-16</strong>就是每次16个位。UTF-8就是在互联网上使用最广的一种unicode的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节）。从unicode到utf-8并不是直接的对应，而是通过一些算法和规则来转换。  </p><table><thead><tr><th style="text-align:center">Unicode符号范围 (十六进制)</th><th style="text-align:center">UTF-8编码方式  （二进制）</th></tr></thead><tbody><tr><td style="text-align:center">0000 0000-0000 007F</td><td style="text-align:center">0xxxxxxx</td></tr><tr><td style="text-align:center">0000 0080-0000 07FF</td><td style="text-align:center">110xxxxx</td></tr><tr><td style="text-align:center">10xxxxxx0000 0800-0000 FFFF</td><td style="text-align:center">1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td style="text-align:center">0001 0000-0010 FFFF</td><td style="text-align:center">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最后简单总结一下：</p><ul><li>中国人民通过对 ASCII 编码的中文扩充改造，产生了 GB2312 编码，可以表示6000多个常用汉字。  </li><li>汉字实在是太多了，包括繁体和各种字符，于是产生了 GBK 编码，它包括了 GB2312 中的编码，同时扩充了很多。  </li><li>中国是个多民族国家，各个民族几乎都有自己独立的语言系统，为了表示那些字符，继续把 GBK 编码扩充为 GB18030 编码。  </li><li>每个国家都像中国一样，把自己的语言编码，于是出现了各种各样的编码，如果你不安装相应的编码，就无法解释相应编码想表达的内容。  </li><li>终于，有个叫 ISO 的组织看不下去了。他们一起创造了一种编码 UNICODE ，这种编码非常大，大到可以容纳世界上任何一个文字和标志。所以只要电脑上有 UNICODE 这种编码系统，无论是全球哪种文字，只需要保存文件的时候，保存成 UNICODE 编码就可以被其他电脑正常解释。  </li><li>UNICODE 在网络传输中，出现了两个标准 UTF-8 和 UTF-16，分别每次传输 8个位和 16个位。于是就会有人产生疑问，UTF-8 既然能保存那么多文字、符号，为什么国内还有这么多使用 GBK 等编码的人？因为 UTF-8 等编码体积比较大，占电脑空间比较多，如果面向的使用人群绝大部分都是中国人，用 GBK 等编码也可以。  </li></ul>]]></content>
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 编码发展 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BigDecimal封装</title>
      <link href="/2018/05/23/BigDecimal%E5%B0%81%E8%A3%85/"/>
      <url>/2018/05/23/BigDecimal%E5%B0%81%E8%A3%85/</url>
      <content type="html"><![CDATA[<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>由于以下几点原因，我们需要对BigDecimal 进行封装。使用起来更方便。</p><ol><li>BigDecimal 参数为double 类型时，有可能会出现误差。</li><li>参数为空时，会抛出异常。这里默认为0。</li><li>除法运算时，若结果为无限小数，会抛出异常。<a id="more"></a></li></ol><h2 id="API说明"><a href="#API说明" class="headerlink" title="API说明"></a>API说明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// obj == null,所得值为0,obj 不能转换为数字,抛出转换异常。</span></span><br><span class="line"><span class="keyword">new</span> BigDecimalUtil(Object obj);</span><br><span class="line"><span class="comment">// 加法 obj处理同上</span></span><br><span class="line">add(Object obj);</span><br><span class="line"><span class="comment">// 减法 obj处理同上</span></span><br><span class="line">minus(Object obj);</span><br><span class="line"><span class="comment">// 乘法 obj处理同上</span></span><br><span class="line">times(Object obj);</span><br><span class="line"><span class="comment">// 除法 obj处理同上</span></span><br><span class="line">divide(Object obj);</span><br><span class="line"><span class="comment">// 转换为String</span></span><br><span class="line">toString();</span><br><span class="line"><span class="comment">// 按精度转换为String,roundMode参见BigDecimal精度模式</span></span><br><span class="line">toString(<span class="keyword">int</span> digit, <span class="keyword">int</span> roundMode);</span><br><span class="line"><span class="comment">// 转换为Double</span></span><br><span class="line">toDouble();</span><br><span class="line"><span class="comment">// 按精度转换为Double,roundMode参见BigDecimal精度模式</span></span><br><span class="line">toDouble(<span class="keyword">int</span> digit, <span class="keyword">int</span> roundMode);</span><br></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bigDecimalUtilIntroduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">    assertEquals(String.valueOf(<span class="number">0.05</span>+<span class="number">0.01</span>),<span class="string">"0.060000000000000005"</span>);</span><br><span class="line">    BigDecimalUtil bigDecimalUtil = <span class="keyword">new</span> BigDecimalUtil(<span class="number">0.05</span>);</span><br><span class="line">    bigDecimalUtil.add(<span class="number">0.01</span>);</span><br><span class="line">    assertEquals(bigDecimalUtil.toString(),<span class="string">"0.06"</span>);</span><br><span class="line">    <span class="comment">// 长运算示例</span></span><br><span class="line">    assertEquals(<span class="keyword">new</span> BigDecimalUtil(<span class="number">0.05</span>).add(<span class="number">0.01</span>).minus(<span class="string">"3"</span>).times(<span class="number">6</span>).divide(<span class="number">3</span>).toString(),<span class="string">"-5.88"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimalUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 当前值 */</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigDecimalUtil</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">new</span> BigDecimal(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigDecimalUtil</span><span class="params">(Object value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = getBigDecimal(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 加 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimalUtil <span class="title">add</span><span class="params">(Object calc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.value.add(getBigDecimal(calc));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 减 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimalUtil <span class="title">minus</span><span class="params">(Object calc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.value.subtract(getBigDecimal(calc));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 乘 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimalUtil <span class="title">times</span><span class="params">(Object calc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.value.multiply(getBigDecimal(calc));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 除 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimalUtil <span class="title">divide</span><span class="params">(Object calc)</span></span>&#123;</span><br><span class="line">       <span class="comment">// this.value = this.value.divide(getBigDecimal(calc));</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.value.divide(getBigDecimal(calc),MathContext.DECIMAL64);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 空处理 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">ifNull</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (obj == <span class="keyword">null</span> || (obj <span class="keyword">instanceof</span> java.lang.String &amp;&amp; obj == <span class="string">""</span>) ) ? <span class="string">"0"</span> : String.valueOf(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 类型转换 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> BigDecimal <span class="title">getBigDecimal</span><span class="params">(Object value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value <span class="keyword">instanceof</span> BigDecimalUtil)&#123;</span><br><span class="line">            BigDecimalUtil val = (BigDecimalUtil) value;</span><br><span class="line">            <span class="keyword">return</span> val.value;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(ifNull(value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 得到值 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> digit, <span class="keyword">int</span> roundMode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value.setScale(digit, roundMode).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">toDouble</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value.doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">toDouble</span><span class="params">(<span class="keyword">int</span> digit, <span class="keyword">int</span> roundMode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value.setScale(digit, roundMode).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">toInt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 工具类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 工具类 </tag>
            
            <tag> 数学运算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>中文阿拉伯数字相互转换</title>
      <link href="/2018/05/23/%E4%B8%AD%E6%96%87%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"/>
      <url>/2018/05/23/%E4%B8%AD%E6%96%87%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/</url>
      <content type="html"><![CDATA[<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>我们有时会需要将中文和阿拉伯数字相互转换。<br>但中文数字并非单纯像电话号码一样一一对应解读，会出现一百零五万三千零伍拾这样的问题。</p><h3 id="中文解读有趣的例子"><a href="#中文解读有趣的例子" class="headerlink" title="中文解读有趣的例子"></a>中文解读有趣的例子</h3><p>这是我在解读月份时发现的有趣例子。<br>两位数中十的解读:</p><table><thead><tr><th style="text-align:center">情况</th><th style="text-align:center">中文</th><th style="text-align:center">阿拉伯数字</th><th style="text-align:center">解读说明</th></tr></thead><tbody><tr><td style="text-align:center">十在首位</td><td style="text-align:center">十一</td><td style="text-align:center">11</td><td style="text-align:center">十解读为1</td></tr><tr><td style="text-align:center">十在中间</td><td style="text-align:center">三十一</td><td style="text-align:center">31</td><td style="text-align:center">十不解读</td></tr><tr><td style="text-align:center">十在末尾</td><td style="text-align:center">二十</td><td style="text-align:center">20</td><td style="text-align:center">十解读为0</td></tr><tr><td style="text-align:center">十单独出现</td><td style="text-align:center">十</td><td style="text-align:center">10</td><td style="text-align:center">十解读为10</td></tr></tbody></table><hr><p>并且我的工作环境下，大量数据的录入可能存在数据源填写错误的情况，比如一白〇而时(120)的情况。<br>所以也在Util中加了容错的数组(可自行扩充)判断。<br><a id="more"></a></p><h2 id="API说明"><a href="#API说明" class="headerlink" title="API说明"></a>API说明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中文 --&gt; 阿拉伯数字</span></span><br><span class="line">String num = NumberUtil.parse(chineseNum);</span><br><span class="line"><span class="comment">// 阿拉伯数字 --&gt; 中文</span></span><br><span class="line">String chineseNum = NumberUtil.format(num);</span><br><span class="line"><span class="comment">// 阿拉伯数字 --&gt; 中文年</span></span><br><span class="line">String chineseYear = NumberUtil.getChineseYear(num);</span><br></pre></td></tr></table></figure><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sean22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/1/19/019.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] chinese=&#123;<span class="string">"零"</span>,<span class="string">"一"</span>,<span class="string">"二"</span>,<span class="string">"三"</span>,<span class="string">"四"</span>,<span class="string">"五"</span>,<span class="string">"六"</span>,<span class="string">"七"</span>,<span class="string">"八"</span>,<span class="string">"九"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] replace=&#123;<span class="string">"|〇"</span>,<span class="string">"|壹"</span>,<span class="string">"|贰"</span>,<span class="string">"|叁"</span>,<span class="string">"|肆"</span>,<span class="string">"|伍"</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hashtable&lt;Character,Long&gt; digits = <span class="keyword">new</span> Hashtable();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] commonDigit =&#123;<span class="string">""</span>,<span class="string">"十"</span>,<span class="string">"百"</span>,<span class="string">"千"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] twiceDigit = &#123;<span class="string">"万"</span>,<span class="string">"亿"</span>,<span class="string">"兆"</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        digits.put(<span class="string">'十'</span>,<span class="number">10L</span>);</span><br><span class="line">        digits.put(<span class="string">'百'</span>,<span class="number">100L</span>);</span><br><span class="line">        digits.put(<span class="string">'千'</span>,<span class="number">1000L</span>);</span><br><span class="line">        digits.put(<span class="string">'万'</span>,<span class="number">10000L</span>);</span><br><span class="line">        digits.put(<span class="string">'亿'</span>,<span class="number">100000000L</span>);</span><br><span class="line">        digits.put(<span class="string">'兆'</span>,<span class="number">10000000000000000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可用于处理年份(如二〇一六)及多位数字</span></span><br><span class="line"><span class="comment">     * 若需添加错字验证，可在replace中对应位置放置；以|隔开</span></span><br><span class="line"><span class="comment">     * 若需添加更高位运算，请在digits中put相应元素，并注意修改long</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chineseNum</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parse</span><span class="params">(String chineseNum)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,len=chinese.length;i&lt;len;i++)&#123;</span><br><span class="line">            chineseNum =chineseNum.replaceAll(chinese[i]+replace[i],Integer.toString(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(chineseNum.matches(<span class="string">"[0-9]+"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> chineseNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//十六处理为一十六</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"十"</span>.equals(chineseNum.substring(<span class="number">0</span>,<span class="number">1</span>)))&#123;</span><br><span class="line">            chineseNum = <span class="string">"1"</span>.concat(chineseNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] cNums = chineseNum.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> getNum(cNums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 算法思路：</span></span><br><span class="line"><span class="comment">     * 倒序累加数字乘以其叠加倍数，</span></span><br><span class="line"><span class="comment">     * 如3千8百万亿中,</span></span><br><span class="line"><span class="comment">     * 3的叠加倍数(multi)是一千万亿,当前倍数(current)是一千,基数(base)是一万亿</span></span><br><span class="line"><span class="comment">     * 8的叠加倍数       是一百万亿,当前倍数         是一百,基数      是一万亿</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getNum</span><span class="params">(<span class="keyword">char</span>[] cNums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum =<span class="number">0</span>,multi = <span class="number">1</span>,current,last=<span class="number">1</span>,base=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=cNums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cNums[i]&gt;<span class="string">'9'</span>)&#123;</span><br><span class="line">                current = digits.get(cNums[i]);</span><br><span class="line">                <span class="comment">//当前倍数比基数大，则更新叠加倍数和基数为当前倍数</span></span><br><span class="line">                <span class="keyword">if</span>(current&gt;base)&#123;</span><br><span class="line">                    base = current;</span><br><span class="line">                    current = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    base = getBase(current, last, base);</span><br><span class="line">                &#125;</span><br><span class="line">                multi = current * base;</span><br><span class="line">                last = current;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum += (cNums[i]-<span class="string">'0'</span>)*multi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果当前倍数突然比上个倍数少，说明已进入到上个倍数的子倍数</span></span><br><span class="line"><span class="comment">     * 则更新叠加倍数为上个倍数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 比较基数和上个倍数</span></span><br><span class="line"><span class="comment">     *      基数&gt;上个倍数时(如三百万亿,读取到百时，base(亿)&gt;last(万))</span></span><br><span class="line"><span class="comment">     *          则更新基数为万亿</span></span><br><span class="line"><span class="comment">     *      基数&lt;上个倍数时(如三十亿零六十万，</span></span><br><span class="line"><span class="comment">     * 读取到十时进入，last(万)&gt;base(1)，更新基数为万</span></span><br><span class="line"><span class="comment">     * 读取到十时再次进入，last(亿)&gt;base(万),更新基数为亿</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getBase</span><span class="params">(<span class="keyword">long</span> current,<span class="keyword">long</span> last,<span class="keyword">long</span> base)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(current&lt;last) &#123;</span><br><span class="line">            base = base &gt; last? base*last :last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将阿拉伯数字转换为中文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">format</span><span class="params">(<span class="keyword">long</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//千以上位计数器</span></span><br><span class="line">        <span class="keyword">int</span>[] twiceDigitCounter =<span class="keyword">new</span> <span class="keyword">int</span>[twiceDigit.length];</span><br><span class="line">        String numStr = simpleFormat(number);</span><br><span class="line">        <span class="comment">//&#123;三,零,零,零,零,五&#125;</span></span><br><span class="line">        <span class="keyword">char</span>[] nums = numStr.toCharArray();</span><br><span class="line">        StringBuffer addDigit = <span class="keyword">new</span> StringBuffer(nums.length*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> index =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> appendZero = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//倒序装载十百千，若遇千位以上，特殊处理(getDigitByCounter)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(appendZero&amp;&amp;lastIsNum(addDigit))&#123;</span><br><span class="line">                addDigit.append(<span class="string">"零"</span>);</span><br><span class="line">                appendZero = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index == commonDigit.length) &#123;</span><br><span class="line">                String current = getDigitByCounter(twiceDigitCounter);</span><br><span class="line">                String last = getLast(addDigit);</span><br><span class="line">                <span class="keyword">if</span>(indexOf(last)&lt;indexOf(current))&#123;</span><br><span class="line">                    addDigit.delete(addDigit.length()-<span class="number">1</span>,addDigit.length());</span><br><span class="line">                &#125;</span><br><span class="line">                addDigit.append(current);</span><br><span class="line">                index=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="string">'零'</span>) &#123;</span><br><span class="line">                appendZero =<span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (index != commonDigit.length) &#123;</span><br><span class="line">                    addDigit.append(commonDigit[index]);</span><br><span class="line">                &#125;</span><br><span class="line">                addDigit.append(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> addDigit.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 200173518 简单转换为 二零零一七三五一八</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">simpleFormat</span><span class="params">(<span class="keyword">long</span> number)</span></span>&#123;</span><br><span class="line">        String numStr = String.valueOf(number);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,len=chinese.length;i&lt;len;i++)&#123;</span><br><span class="line">            numStr =numStr.replaceAll(Integer.toString(i),chinese[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转换为中文的年</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getChineseNumYear</span><span class="params">(<span class="keyword">long</span> number)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number&lt;<span class="number">2000</span>||number&gt;<span class="number">2100</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"日期格式错误"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> simpleFormat(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 万出现两次则为亿，亿出现两次则为兆</span></span><br><span class="line"><span class="comment">     * 因此，千位以上从万计数，</span></span><br><span class="line"><span class="comment">     * 若万没出现过，则为万。</span></span><br><span class="line"><span class="comment">     * 若万出现过，则置万为没出现过，进位到亿</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getDigitByCounter</span><span class="params">(<span class="keyword">int</span>[] twiceDigitCounter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,len=twiceDigit.length;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(twiceDigitCounter[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                twiceDigitCounter[i]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> twiceDigit[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(twiceDigitCounter[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                twiceDigitCounter[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        twiceDigitCounter[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> twiceDigit[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到最后一位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> addDigit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getLast</span><span class="params">(StringBuffer addDigit)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(addDigit.length()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> addDigit.substring(addDigit.length()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 万亿兆。。。的位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> digit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String digit)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,len=twiceDigit.length;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(twiceDigit[i].equals(digit))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> twiceDigit.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最后一位是否为非零数字(不可为万/亿等计位符)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> addDigit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">lastIsNum</span><span class="params">(StringBuffer addDigit)</span></span>&#123;</span><br><span class="line">        String last =getLast(addDigit);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,len=chinese.length;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chinese[i].equals(last))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试年份及错别字</span></span><br><span class="line">        System.out.println(NumberUtil.parse(<span class="string">"贰〇一八"</span>));</span><br><span class="line">        System.out.println(NumberUtil.parse(<span class="string">"十六"</span>));</span><br><span class="line">        System.out.println(NumberUtil.parse(<span class="string">"二十"</span>));</span><br><span class="line">        System.out.println(NumberUtil.parse(<span class="string">"二千零四十五"</span>));</span><br><span class="line">        System.out.println(NumberUtil.parse(<span class="string">"三百二十五万零四十"</span>));</span><br><span class="line">        System.out.println(NumberUtil.parse(<span class="string">"三十亿零四十万"</span>));</span><br><span class="line">        System.out.println(NumberUtil.parse(<span class="string">"一万"</span>));</span><br><span class="line">        System.out.println(NumberUtil.parse(<span class="string">"九千万零一"</span>));</span><br><span class="line">        System.out.println(NumberUtil.parse(<span class="string">"三百万亿"</span>));</span><br><span class="line">        System.out.println(NumberUtil.parse(<span class="string">"一百二十三兆四千五百六十七万八千九百零一亿二千三百四十五万六千七百八十九"</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(NumberUtil.getChineseNumYear(<span class="number">2018</span>));</span><br><span class="line">        System.out.println(NumberUtil.format(<span class="number">16</span>));</span><br><span class="line">        System.out.println(NumberUtil.format(<span class="number">20</span>));</span><br><span class="line">        System.out.println(NumberUtil.format(<span class="number">2045</span>));</span><br><span class="line">        System.out.println(NumberUtil.format(<span class="number">3000400000L</span>));</span><br><span class="line">        System.out.println(NumberUtil.format(<span class="number">10000</span>));</span><br><span class="line">        System.out.println(NumberUtil.format(<span class="number">90000001</span>));</span><br><span class="line">        System.out.println(NumberUtil.format(<span class="number">300000000000000L</span>));</span><br><span class="line">        System.out.println(NumberUtil.format(<span class="number">1234567890123456789L</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">2018</span><br><span class="line">16</span><br><span class="line">20</span><br><span class="line">2045</span><br><span class="line">3250040</span><br><span class="line">3000400000</span><br><span class="line">10000</span><br><span class="line">90000001</span><br><span class="line">300000000000000</span><br><span class="line">1234567890123456789</span><br><span class="line">二零一八</span><br><span class="line">一十六</span><br><span class="line">二十</span><br><span class="line">二千零四十五</span><br><span class="line">三十亿零四十万</span><br><span class="line">一万</span><br><span class="line">九千万零一</span><br><span class="line">三百万亿</span><br><span class="line">一百二十三兆四千五百六十七万八千九百零一亿二千三百四十五万六千七百八十九</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 工具类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 工具类 </tag>
            
            <tag> 自然语言处理 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
