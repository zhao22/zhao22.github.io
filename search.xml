<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>同步与异步,阻塞与非阻塞</title>
      <link href="/2019/09/09/thread-1/"/>
      <url>/2019/09/09/thread-1/</url>
      <content type="html"><![CDATA[<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>同步与异步主要描述在<strong>单线程</strong>中，执行者是否具备主动通知功能:</p><p>同步: 调用者会等到方法调用返回后才能继续后面的行为</p><p>异步: 调用者不需要等到方法返回，方法执行完毕后会主动通知调用者</p><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>阻塞与非阻塞主要关心调用者的<strong>多个线程</strong>是否可以同时执行</p><p>阻塞: 线程1和线程2不能同时进行</p><p>非阻塞: 线程1和线程2可以同时进行</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h3><p>小明把水壶放到火上，然后在那傻等水开  </p><p>(客户端请求服务器，在服务器返回前，客户端不执行任何操作)</p><h3 id="同步非阻塞"><a href="#同步非阻塞" class="headerlink" title="同步非阻塞"></a>同步非阻塞</h3><p>小明把水壶放到火上，然后去客厅看电视，时不时的去厨房看看水开没有</p><p>(客户端新开一个线程请求服务器，主线程执行其他操作，同时主线程对请求结果进行轮询，发现收到请求结果后，执行后续操作)</p><h3 id="异步阻塞"><a href="#异步阻塞" class="headerlink" title="异步阻塞"></a>异步阻塞</h3><p>小明把响水壶放到火上，然后在那傻等水开</p><p>(客户端请求服务器，在服务器返回前，客户端不执行任何操作，服务器返回时，通过回调通知客户端执行后续操作)</p><h3 id="异步非阻塞"><a href="#异步非阻塞" class="headerlink" title="异步非阻塞"></a>异步非阻塞</h3><p>小明把响水水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去处理</p><p>(客户端新开一个线程请求服务器，主线程执行其他操作，服务器返回时，调用回调客户端的回调接口执行特定操作)</p>]]></content>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL问题总结-SHOW PROCESSLIST</title>
      <link href="/2019/09/05/mysql-1/"/>
      <url>/2019/09/05/mysql-1/</url>
      <content type="html"><![CDATA[<h2 id="以下两条指令可以用来查看当前库有哪些正在运行的线程"><a href="#以下两条指令可以用来查看当前库有哪些正在运行的线程" class="headerlink" title="以下两条指令可以用来查看当前库有哪些正在运行的线程"></a>以下两条指令可以用来查看当前库有哪些正在运行的线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW [FULL] PROCESSLIST;</span><br><span class="line">SELECT * FROM information_schema.processlist;</span><br></pre></td></tr></table></figure><ol><li><p>如果操作员有PROCESS权限，则可以查看所有的线程，否则只能查看当前用的线程。  </p></li><li><p>如果没有使用FULL关键字，只能查看Info字段的前100个字符。</p></li></ol><h2 id="操作将会显示以下字段"><a href="#操作将会显示以下字段" class="headerlink" title="操作将会显示以下字段"></a>操作将会显示以下字段</h2><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">ID标识,要kill一个语句使用此字段</td></tr><tr><td style="text-align:center">user</td><td style="text-align:center">使用线程的用户</td></tr><tr><td style="text-align:center">host</td><td style="text-align:center">使用线程的IP和端口号</td></tr><tr><td style="text-align:center">db</td><td style="text-align:center">数据库名</td></tr><tr><td style="text-align:center">command</td><td style="text-align:center">连接状态,主要有休眠(sleep)、查询(query)、连接(connect)</td></tr><tr><td style="text-align:center">time</td><td style="text-align:center">连接持续时间，单位是秒</td></tr><tr><td style="text-align:center">state</td><td style="text-align:center">显示当前sql语句的状态</td></tr><tr><td style="text-align:center">info</td><td style="text-align:center">显示这个sql语句</td></tr></tbody></table><h2 id="state-主要状态和描述"><a href="#state-主要状态和描述" class="headerlink" title="state 主要状态和描述"></a>state 主要状态和描述</h2><table><thead><tr><th style="text-align:center">状态</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Checking table</td><td style="text-align:center">正在检查数据表(自动)</td></tr><tr><td style="text-align:center">Closing tables</td><td style="text-align:center">正在将表中修改的数据刷新到磁盘中，同时正在关闭已经用完的表。这是一个很快的操作，如果不是这样的话，应该确认磁盘空间是否已经满了或者磁盘是否正处于重负中</td></tr><tr><td style="text-align:center">Connect Out</td><td style="text-align:center">复制从服务器正在连接主服务器</td></tr><tr><td style="text-align:center">Copying to tmp table on disk</td><td style="text-align:center">由于临时结果集大于tmp_table_size.正在将临时表从内存存储转为磁盘存储以节省内存</td></tr><tr><td style="text-align:center">Creating tmp table</td><td style="text-align:center">正在创建临时表以存放部分查询结果</td></tr><tr><td style="text-align:center">deleting from main table</td><td style="text-align:center">服务器正在执行多表删除中的第一部分，刚删除第一个表</td></tr><tr><td style="text-align:center">deleting from reference tables</td><td style="text-align:center">服务器正在执行多表删除中的第二部分，正在删除其他表的记录</td></tr><tr><td style="text-align:center">Flushing tables</td><td style="text-align:center">正在执行FLUSH TABLES,等待其他线程关闭数据表</td></tr><tr><td style="text-align:center">Killed</td><td style="text-align:center">发送了一个kill请求给某线程，那么这个线程将会检查kill标志位，同时会放弃下一个kill请求。MySQL会在每次的主循环中检查kill标志位，不过有些情况下该线程可能会过一小段时间才能关闭。如果该线程被其他线程锁住，那么kill请求会在锁释放时马上生效</td></tr><tr><td style="text-align:center">Locked</td><td style="text-align:center">被其他查询锁住了</td></tr><tr><td style="text-align:center">Sending data</td><td style="text-align:center">正在处理SELECT查询的记录，同时正在把结果发送给客户端</td></tr><tr><td style="text-align:center">Sorting for group</td><td style="text-align:center">正在为GROUP BY做排序</td></tr><tr><td style="text-align:center">Sorting for order</td><td style="text-align:center">正在为ORDER BY做排序</td></tr><tr><td style="text-align:center">Opening tables</td><td style="text-align:center">正在尝试打开一个表，这个过程应该会很快，除非收到其他因素的干扰。例如，在执行ALTER TABLE或LOCK TABLE语句行完之前，数据表无法被其他线程打开。</td></tr><tr><td style="text-align:center">Removing duplicates</td><td style="text-align:center">正在执行一个SELECT DISTINCT方式的查询，但是MySQL无法在前一个阶段优化掉那些重复的记录。因此MySQL需要再次去掉重复的记录，然后再把结果发送给客户端。</td></tr><tr><td style="text-align:center">Reopen table</td><td style="text-align:center">获得了对一个表的锁，必须在表结构修改后才能获得这个锁，已经释放锁，关闭数据表，正尝试重新打开数据表。</td></tr><tr><td style="text-align:center">Repair by sorting</td><td style="text-align:center">修复指令正在排序以创建索引</td></tr><tr><td style="text-align:center">Repair with keycache</td><td style="text-align:center">修复指令正在利用索引缓存一个一个地创建新索引。它会比Repair by sorting慢些。</td></tr><tr><td style="text-align:center">Searching rows for update</td><td style="text-align:center">正在将符合条件的记录找出来用于更新,一定在UPDATE要修改相关记录前就完成</td></tr><tr><td style="text-align:center">Sleeping</td><td style="text-align:center">正在等待客户端发送新请求</td></tr><tr><td style="text-align:center">System lock</td><td style="text-align:center">正在等待取得一个外部的系统锁。如果当前没有运行多个mysqld服务器同时请求一个表，可以通过增加–skip-external-locking来禁止外部系统锁</td></tr><tr><td style="text-align:center">Upgrading lock</td><td style="text-align:center">INSERT DELAYED正在尝试取得一个锁以插入新记录</td></tr><tr><td style="text-align:center">Updating</td><td style="text-align:center">正在修改匹配的记录</td></tr><tr><td style="text-align:center">User Lock</td><td style="text-align:center">正在等待GET_LOCK()</td></tr><tr><td style="text-align:center">Waiting for tables</td><td style="text-align:center">线程得到通知，数据表结构已经被修改了，需要重新打开数据表以取得新的结构。为了重新打开数据表，必须等到所有其他线程关闭这个表。以下几种情况会产生这个通知:FLUSH, ALTER,RENAME,REPAIR,ANALYZE,OPTIMIZE</td></tr><tr><td style="text-align:center">waiting for handler insert</td><td style="text-align:center">INSERT DELAYED已经处理完了所有待处理的插入操作，正在等待新的请求</td></tr></tbody></table>]]></content>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> MySQL问题总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux问题总结-linux时间调整</title>
      <link href="/2019/08/29/linux-question-1/"/>
      <url>/2019/08/29/linux-question-1/</url>
      <content type="html"><![CDATA[<h2 id="修改时间说明"><a href="#修改时间说明" class="headerlink" title="修改时间说明"></a>修改时间说明</h2><p>有时需要修改服务器的时间来测试某些定时任务，具体操作手段如下:</p><h3 id="查看当前时间及时区"><a href="#查看当前时间及时区" class="headerlink" title="查看当前时间及时区"></a>查看当前时间及时区</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -R</span><br></pre></td></tr></table></figure><h3 id="修改日期为2019年08月24日"><a href="#修改日期为2019年08月24日" class="headerlink" title="修改日期为2019年08月24日"></a>修改日期为2019年08月24日</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -s 08/24/2019</span><br></pre></td></tr></table></figure><h3 id="修改时间为下午18-00-00"><a href="#修改时间为下午18-00-00" class="headerlink" title="修改时间为下午18:00:00"></a>修改时间为下午18:00:00</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -s 18:00:00</span><br></pre></td></tr></table></figure><h3 id="将当前时间写入BIOS-避免重启后失效"><a href="#将当前时间写入BIOS-避免重启后失效" class="headerlink" title="将当前时间写入BIOS,避免重启后失效"></a>将当前时间写入BIOS,避免重启后失效</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock -w</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure><h3 id="查看BIOS时间"><a href="#查看BIOS时间" class="headerlink" title="查看BIOS时间"></a>查看BIOS时间</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock --show</span><br></pre></td></tr></table></figure><h3 id="用硬件时钟同步系统时钟"><a href="#用硬件时钟同步系统时钟" class="headerlink" title="用硬件时钟同步系统时钟"></a>用硬件时钟同步系统时钟</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock --hctosys</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> linux问题总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jvm字节码执行引擎</title>
      <link href="/2019/08/13/jvm-15/"/>
      <url>/2019/08/13/jvm-15/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>执行引擎是Java虚拟机最核心的组成部分之一。”虚拟机”是一个相对于”物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，而虚拟机的执行引擎则是由自己实现的，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。</p><p>在Java虚拟机规范中制定了虚拟机执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观(Facade)。</p><p>在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能有解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码执行)两种选择。也可能两者兼备，甚至还可能包含几个不同级别的编译器执行引擎。但从外观上看起来，所有的Java虚拟机的执行引擎都是一致的: 输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。</p><h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>栈帧(Stack Frame) 是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈(Virtual Machine Stack)的栈元素。</p><p>栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。  </p><p>每一个方法从调用开始到执行完成的过程，就对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p><p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p><p>一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来讲，活动线程中， 只有栈顶的栈帧是有效的，称为 <strong>当前栈帧</strong>(Current Stack Frame)，这个栈帧所关联的方法称为当前方法(Current Method)。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。</p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量。  </p><p>局部变量表的容量以变量槽(Variable Slot， 下称Slot) 为最小单位，虚拟机规范中并没有明确指明一个Slot应占用的内存空间大小，只是很有”导向性”地说明每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据。这种描述与明确指出”每个Slot占用32位长度的内存空间”有一些区别，它允许Slot的长度随着处理器、操作系统或虚拟机的不同而发生变化。</p><p>不过无论如何，即使在64位虚拟机中使用了64位长度的内存空间来实现一个Slot,虚拟机仍要使用对齐和补白的手段让Slot在外观上看起来与32位虚拟机中的一致。</p><p>一个Slot可以存放一个32位以内的数据类型，Java中占用32位以内的数据类型有boolean、byte、char、short、int、float、reference和returnAddress八种类型。</p><p>reference是对象的引用。虚拟机规范既没有说明它的长度，也没有明确指出这个引用应有怎样的结构，但是一般来说，虚拟机实现至少都应当能从此引用中直接或间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。</p><p>returnAddress是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。</p><p>对于64位的数据类型，虚拟机会以高位在前的方式为其分配两个连续的Slot空间。Java语言中明确规定的64位的数据类型只有long和double两种(reference类型则可能是32位也可能是64位)。</p><p>由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的Slot是否是原子操作，都不会引起数据安全问题。</p><p>虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始到局部变量表最大的Slot数量。如果是32位数据类型的变量，索引n就代表了使用第n个Slot，如果是64位数据类型的变量，则说明要使用第n和第n+1两个Slot。</p><p>虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果是实例方法(非static的方法)，那么局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字”this”来访问这个隐含的参数。其余参数则按照参数表的顺序来排列，占用从1开始的局部变量Slot,参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。</p><p>局部变量表中的Slot是可重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那么这个变量对应的Slot就可以交给其他变量使用。这样的设计不仅仅是为了节省栈空间，在某些情况下Slot的复用会直接影响到系统的垃圾收集行为。</p><h4 id="局部变量表复用的示例"><a href="#局部变量表复用的示例" class="headerlink" title="局部变量表复用的示例"></a>局部变量表复用的示例</h4><p>在虚拟机运行参数中加上”-verbose: gc”可以查看垃圾收集的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码不会回收placeholder所占的内存，在System.gc()时，变量placeholder还处于作用域之内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时代码虽然已经离开了placeholder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder原本所占用的Slot还没有被其他变量复用，所以作为GC Roots一部分的局部变量表仍然保持着对它的关联。<br>在下方加入新变量的赋值后，问题就可以解决:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前虚拟机的优化已经可以正确回收内存了。</p><h4 id="局部变量没有默认值"><a href="#局部变量没有默认值" class="headerlink" title="局部变量没有默认值"></a>局部变量没有默认值</h4><p>局部变量不像类变量那样存在“准备阶段”。</p><p>类变量有两次赋初值的过程，一次在准备阶段，赋予系统初始值；另一次在初始化阶段，赋予程序员定义的初始值。</p><p>因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值是不能使用的。所以不要认为Java中任何情况下都存在诸如整型变量默认为0、布尔型变量默认为false之类的默认值。</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈也被称为操作栈，它是一个后入先出(Last In First Out, LIFO)栈。同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。</p><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令向操作数栈中写入和提取内容，也就是入栈出栈操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。</p><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。</p><p>另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的。但是大多数虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据，而无需进行额外的参数复制传递了。</p><p>Java虚拟机的解释执行引擎称为”基于栈的执行引擎”，其中所指的”栈”就是操作数栈。</p><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。</p><p>Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。</p><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法被执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口(Normal Method Invocation Completion)。</p><p>另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口(Abrupt Method Invocation Completion)。 一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。  </p><p>无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。 一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p><p>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：</p><ol><li><p>恢复上层方法的局部变量表和操作数栈</p></li><li><p>把返回值（如果有的话）压入调用者栈帧的操作数栈中</p></li><li><p>调整PC计数器的值以指向方法调用指令后面一条指令</p></li></ol><p>…</p><h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。</p><p>在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。</p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。</p><p>Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于之前所说的直接引用）。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法的调用过程变得相对复杂起来，需要在类加载期间甚至到运行期间才能确定目标方法的直接引用。</p><p>这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法的调用过程变得相对复杂起来，需要在类加载期间甚至到运行期间才能确定目标方法的直接引用。</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来，这类方法的调用称为解析(Resolution)。</p>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jvm类加载器</title>
      <link href="/2019/08/12/jvm-14/"/>
      <url>/2019/08/12/jvm-14/</url>
      <content type="html"><![CDATA[<h2 id="类加载器介绍"><a href="#类加载器介绍" class="headerlink" title="类加载器介绍"></a>类加载器介绍</h2><p>虚拟机涉及团队把类加载阶段中的”通过一个类的权限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块被称为”类加载器”。</p><h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。</p><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。这句话等同于:</p><p>比较两个类是否”相等”，只有在这两个类是由同一个类加载器加载的前提之下才有意义，否则，即使这两个类是来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。  </p><p>这里所指的”相等”，包括代表类的Class对象的equals()方法、isAssignableFrom() 方法、isInstance()方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等情况。如果没有注意到类加载器的影响，在某些情况下可能会产生具有迷惑性的结果。</p><p>不同的类加载器对instanceof关键字运算结果的影响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类加载器与instanceof关键字演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Object obj = myLoader.loadClass(<span class="string">"org.fenixsoft.classloading.ClassLoaderTest"</span>).newInstance();</span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> org.fenixsoft.classloading.ClassLoaderTest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="Java虚拟机角度的类加载器"><a href="#Java虚拟机角度的类加载器" class="headerlink" title="Java虚拟机角度的类加载器"></a>Java虚拟机角度的类加载器</h3><p>在Java虚拟机的角度讲，只存在两种不同的类加载器：</p><ol><li><p>启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分；</p></li><li><p>其他类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。</p></li></ol><h3 id="开发人员角度的类加载器"><a href="#开发人员角度的类加载器" class="headerlink" title="开发人员角度的类加载器"></a>开发人员角度的类加载器</h3><p>从开发人员角度出发，绝大部分Java程序都会使用到以下三种系统提供的类加载器:  </p><ul><li><p>启动类加载器(Bootstrap ClassLoader): 这个类加载器负责将存放在\&lt;JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的(仅按照文件名识别，如rt.jar,名字不符合的类库即使放在lib目录中也不会被加载)类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用。</p></li><li><p>扩展类加载器(Extension ClassLoader): 这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载\&lt;JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p></li><li><p>应用程序类加载器(Application ClassLoader): 这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径(ClassPath)上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></li></ul><h3 id="双亲委派模型简介"><a href="#双亲委派模型简介" class="headerlink" title="双亲委派模型简介"></a>双亲委派模型简介</h3><p>我们的应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动类加载器(Bootstrap ClassLoader) &lt;--- 扩展类加载器(Extension ClassLoader) &lt;--- 应用程序类加载器(Application ClassLoader) &lt;----多个用户自己定义的类加载器</span><br></pre></td></tr></table></figure><p>类加载器之间的这种层次关系，就称为类加载器的<strong>双亲委派模型</strong>(Parents Delegation Model)。</p><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承(Inheritance)关系来实现，而是都使用组合(Composition)关系来复用父加载器的代码。</p><p>类加载器的双亲委派模型在JDK1.2期间被引入并被广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者们的一种类加载器实现方式。  </p><h4 id="双亲委派模型工作过程"><a href="#双亲委派模型工作过程" class="headerlink" title="双亲委派模型工作过程"></a>双亲委派模型工作过程</h4><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去加载。</p><h4 id="双亲委派模型的优点"><a href="#双亲委派模型的优点" class="headerlink" title="双亲委派模型的优点"></a>双亲委派模型的优点</h4><p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。</p><p>例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。  </p><p>相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己写了一个名为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序也将会变得一片混乱。</p><h4 id="双亲委派模型的实现"><a href="#双亲委派模型的实现" class="headerlink" title="双亲委派模型的实现"></a>双亲委派模型的实现</h4><p>双亲委派模型的实现非常简单，实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass()方法之中</p><p>逻辑清晰易懂:  </p><ol><li><p>先检查是否已经被加载过</p></li><li><p>若没有加载则调用父加载器的loadClass()方法</p></li><li><p>若父加载器为空则默认使用启动类</p></li><li><p>如果父类加载失败，则在抛出ClassNotFoundException异常后，再调用自己的findClass() 方法进行加载。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 首先， 检查请求的类是否已经被加载过了</span></span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 如果父类加载器抛出ClassNotFoundException</span></span><br><span class="line">            <span class="comment">// 则说明父类加载器无法完成加载请求</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在父类加载器无法加载的时候</span></span><br><span class="line">            <span class="comment">// 再调用本身的findClass方法来进行类加载</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双亲委派模型的破坏"><a href="#双亲委派模型的破坏" class="headerlink" title="双亲委派模型的破坏"></a>双亲委派模型的破坏</h4><h5 id="为了兼容JDK1-2之前的自定义类加载器"><a href="#为了兼容JDK1-2之前的自定义类加载器" class="headerlink" title="为了兼容JDK1.2之前的自定义类加载器"></a>为了兼容JDK1.2之前的自定义类加载器</h5><p>为了向前兼容, JDK 1.2之后的java.lang.ClassLoader添加了一个新的protected方法findClass(),在此之前，用户去继承java.lang.ClassLoader的唯一目的就是为了重写loadClass()方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass()。</p><p>JDK1.2之后已不提倡用户再去覆盖loadClass() 方法，而应当把自己的类加载逻辑写到findClass()方法中，在loadClass()方法的逻辑里如果父类加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。</p><h5 id="基础类调用用户代码"><a href="#基础类调用用户代码" class="headerlink" title="基础类调用用户代码"></a>基础类调用用户代码</h5><p>JNDI服务的代码由启动类加载器去加载(在JDK1.3时代放进去的rt.jar),但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的JNDI接口提供者(SPI, Service Provider Interface)的代码，但启动类加载器不可能”认识”这些代码。</p><p>Java设计团队引入了 <strong>线程上下文类加载器</strong>(Thread Context ClassLoader) 来解决这个困境。这个类加载器可以通过java.lang.Thread类的setContextClassLoader() 方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。</p><p>JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作。  </p><h5 id="动态性的追求"><a href="#动态性的追求" class="headerlink" title="动态性的追求"></a>动态性的追求</h5><p>动态性的追求就是希望应用程序能像电脑外设那样，插上鼠标或U盘，不用重启机器就能立即使用。  </p><p>OSGi是当前业界的Java模块化标准，OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块(OSGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。</p><p>在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为网状结构，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索:</p><ol><li><p>将以java.*开头的类，委派给父类加载器加载。</p></li><li><p>否则，将委派列表名单内的类，委派给父类加载器加载。</p></li><li><p>否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</p></li><li><p>否则， 查找当前Bundle的ClassPath, 使用自己的类加载器加载。</p></li><li><p>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</p></li><li><p>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</p></li><li><p>否则，类查找失败。</p></li></ol><p>上面的查找顺序只有开头两点仍然符合双亲委派规则，其余的类查找都是在平级的类加载器中进行的。</p>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jvm类加载的过程</title>
      <link href="/2019/08/09/jvm-13/"/>
      <url>/2019/08/09/jvm-13/</url>
      <content type="html"><![CDATA[<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>“加载”(Loading)阶段是”类加载(Class Loading)”的第一个阶段。<br>在加载阶段，虚拟机需要完成以下三件事情:</p><ol><li><p>通过一个类的全限定名来获取定义此类的二进制字节流。  </p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。  </p></li><li><p>在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。  </p></li></ol><h3 id="类的获取方式"><a href="#类的获取方式" class="headerlink" title="类的获取方式"></a>类的获取方式</h3><p>通过一个类的全限定名来获取定义此类的二进制字节流，并没有指明二进制字节流要从一个Class文件中获取，准确地说是根本没有指明要从哪里获取及怎样获取，一般有以下获取方式:</p><ul><li><p>从ZIP包中读取，最终成为JAR、EAR、WAR格式的基础。</p></li><li><p>从网络中获取，这种场景最典型的应用是Applet。</p></li><li><p>运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass来为特定接口生成*$Proxy的代理类的二进制字节流。  </p></li><li><p>由其他文件生成，典型场景: JSP应用。</p></li><li><p>从数据库中读取，这种场景相对少见些，有些中间件服务器(如SAP Netweaver)可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</p></li></ul><p>相对于类加载的其他阶段，加载阶段获取类的二进制字节流的动作是开发期可控性最强的阶段，因为加载阶段既可以使用系统提供的类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员们可以通过定义自己的类加载器去控制字节流的获取方式。  </p><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。  </p><p>然后在Java堆中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的这些类型数据的外部接口。加载阶段与连接阶段的部分内容(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。  </p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="验证工作的重要性"><a href="#验证工作的重要性" class="headerlink" title="验证工作的重要性"></a>验证工作的重要性</h3><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。  </p><p>Java语言本身是相对安全的语言(相对C/C++),使用纯粹的Java代码无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果这样做了，编译器将拒绝编译。  </p><p>但Class文件并不一定要求用Java源码编译而来，可以使用任何途径，包括用十六进制编辑器直接编写来产生Class文件。  </p><p>在字节码的语言层面上，上述Java代码无法做到的事情都是可以实现的，至少语义上是可以表达出来的。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。  </p><h3 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a>验证过程</h3><p>尽管验证阶段的工作量在虚拟机的类加载子系统中占了很大一部分，但虚拟机规范对这个阶段仅仅要求如果验证到输入的字节流不符合Clas文件的存储格式，就抛出一个java.lang.VerifyError异常或其子类异常。  </p><p>不同的虚拟机对类验证的实现可能会有所不同，但大致上都会完成下面四个阶段的检验过程:  </p><h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h4><p>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段一般包括以下验证点:</p><ul><li><p>是否以魔数0xCAFEBABE开头。  </p></li><li><p>主、次版本号是否在当前虚拟机处理范围之内。</p></li><li><p>常量池的常量中是否有不被支持的常量类型(检查常量tag标志)。</p></li><li><p>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</p></li><li><p>CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。  </p></li><li><p>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。  </p></li></ul><p>……</p><h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h4><p>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，这个阶段可能包括的验证点如下：</p><ul><li><p>这个类是否有父类（除了java.lang.Object之外， 所有的类都应当有父类）</p></li><li><p>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</p></li><li><p>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。  </p></li><li><p>类中的字段、方法是否与父类产生了矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。  </p></li></ul><p>……</p><p>第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。  </p><h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><p>第三阶段是整个验证过程中最复杂的一个阶段，主要工作是进行数据流和控制流分析。在第二阶段对元数据信息中的数据类型做完校验后，这阶段将对类的方法体进行校验分析。这阶段的任务是保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，如:  </p><ul><li><p>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈中放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。</p></li><li><p>保证跳转指令不会跳转到方法体以外的字节码指令上。  </p></li><li><p>保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。</p></li></ul><p>……</p><p>通过程序去校验程序逻辑是无法做到绝对准确的————不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。  </p><p>在JDK 1.6之后的Javac编译器中进行了一项优化，给方法体的Code属性的属性表中增加了一项名为”StackMapTable”属性，描述方法体中所有的基本块(Basic Block，按照控制流拆分的代码块)开始时本地变量表和操作栈应有的状态，这可以将字节码验证的类型推导转变为类型检查从而节省一些时间。</p><p>当然，这个属性也存在被篡改的可能，在JDK1.6的HotSpot虚拟机中提供了-XX: -UseSplitVerifier选项来关闭掉这项优化。  </p><h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><p>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段————解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性的校验，通常需要校验以下内容：</p><ul><li><p>符号引用中通过字符串描述的全限定名是否能找到对应的类。</p></li><li><p>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</p></li><li><p>符号引用中的类、字段和方法的访问性(private、protected、public、default)是否可被当前类访问。</p></li></ul><p>……</p><p>符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，将会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</p><p>验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但不一定是必要的阶段。如果所运行的全部代码(包括自己写的、第三方包中的代码)都已经被反复使用和验证过，在实施阶段就可以考虑使用-Xverify: none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。</p><h3 id="只分配类变量"><a href="#只分配类变量" class="headerlink" title="只分配类变量"></a>只分配类变量</h3><p>这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p><h4 id="初始值”通常”是零值"><a href="#初始值”通常”是零值" class="headerlink" title="初始值”通常”是零值"></a>初始值”通常”是零值</h4><p>假设一个类变量的定义为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>那么变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器\&lt;clinit>()方法中，所以把value赋值为123的动作将在初始化阶段才会被执行。  </p><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">零值</th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">0L</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">(short)0</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">‘\u0000’</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">(byte)0</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">0.0f</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">0.0d</td></tr><tr><td style="text-align:center">reference</td><td style="text-align:center">null</td></tr></tbody></table><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。  </p><p>符号引用在Class文件中以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量。  </p><p>符号引用与直接引用的区别：</p><h3 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h3><p>符号引用(Symbolic References): 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</p><h3 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h3><p>直接引用(Direct References): 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</p><h3 id="解析进行的时机"><a href="#解析进行的时机" class="headerlink" title="解析进行的时机"></a>解析进行的时机</h3><p>虚拟机规范之中并未规定解析阶段发生的具体时间，只要求了在执行anewarray、checkcast、getfield、getstatic、instanceof、invokeinterface、invokespecial、invokestatic、invokevirtual、multianewarray、new、putfield和putstatic这13个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。</p><p>所以虚拟机实现会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p><p>对同一个符号引用进行多次解析请求是很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存(在运行时常量池中记录直接引用，并把常量标识为已解析状态)从而避免解析动作重复进行。无论是否真正执行了多次解析动作，虚拟机需要保证的都是在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直成功;同样地，如果第一次解析失败了，其他指令对这个符号的解析请求也应该收到相同的异常。  </p><h3 id="解析对应的对象"><a href="#解析对应的对象" class="headerlink" title="解析对应的对象"></a>解析对应的对象</h3><p>解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info及CONSTANT_InterfaceMethodref_info四种常量类型。  </p><h4 id="类或接口的解析"><a href="#类或接口的解析" class="headerlink" title="类或接口的解析"></a>类或接口的解析</h4><p>假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤:</p><ol><li><p>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于无数据验证、字节码验证的需要，又将可能触发其他类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败。  </p></li><li><p>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava.lang.Integer”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是”java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。</p></li><li><p>如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认C是否具备对D的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。</p></li></ol><h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><p>要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索:</p><ol><li><p>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p></li><li><p>否则，如果在C中实现了接口，将会按照继承关系从上往下递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p></li><li><p>否则，如果C不是java.lang.Object的话，将会按照继承关系从上往下递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p></li><li><p>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</p></li></ol><p>如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。</p><p>在实际应用中，虚拟机的编译器实现可能会比上述规范要求得更加严格一些，如果有一个同名字段同时出现在C的接口和父类中，或者同时在自己或父类的多个接口中出现，那编译器将可能拒绝编译。</p><h4 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h4><p>类方法解析的第一个步骤与字段解析一样，也是需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索:</p><ol><li><p>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</p></li><li><p>如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p></li><li><p>否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p></li><li><p>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束抛出java.lang.AbstractMethodError异常。</p></li><li><p>否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。</p></li></ol><p>最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证；如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。</p><h4 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h4><p>接口方法也是需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索:</p><ol><li><p>与类方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。</p></li><li><p>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p></li><li><p>否则，在接口C的父接口中递归查找，直到java.lang.Object类(查找范围会包括Object类)为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p></li><li><p>否则， 宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</p></li></ol><p>由于接口中的所有方法都是public的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出java.lang.IllegalAccessError异常。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码(或者说是字节码)。</p><p>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达: 初始化阶段是执行类执行器\&lt;clinit>()方法的过程。</p><h4 id="lt-clinit-方法"><a href="#lt-clinit-方法" class="headerlink" title="\&lt;clinit>()方法"></a>\&lt;clinit>()方法</h4><ol><li><p>\&lt;clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{} 块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问。</p></li><li><p>\&lt;clinit>()方法与类的构造函数(或者说实例构造器\&lt;clinit>()方法)不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的\&lt;clinit>()方法执行之前，父类的\&lt;clinit>()方法已经执行完毕。因此在虚拟机中第一个被执行的\&lt;clinit>()方法的类肯定是java.lang.Object。</p></li><li><p>由于父类的\&lt;clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</p></li><li><p>\&lt;clinit>() 方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成\&lt;clinit>() 方法。</p></li><li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成\&lt;clinit>()方法。但接口与类不同的是，执行接口的\&lt;clinit>()方法不需要先执行父接口的\&lt;clinit>()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的\&lt;clinit>方法。</p></li><li><p>虚拟机会保证一个类的\&lt;clinit>() 方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的\&lt;clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行\&lt;clinit>()方法执行完毕。 如果在一个类的\&lt;clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</p></li></ol>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jvm类加载机制概述</title>
      <link href="/2019/08/09/jvm-12/"/>
      <url>/2019/08/09/jvm-12/</url>
      <content type="html"><![CDATA[<h2 id="类加载机制概述"><a href="#类加载机制概述" class="headerlink" title="类加载机制概述"></a>类加载机制概述</h2><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。  </p><p>与那些在编译时需要进行连接工作的语言不同，在Java语言里面，类型的加载和连接过程都是在程序运行期间完成的，这样会在类加载时稍微增加一些性能开销，但是却能为Java应用程序提供高度的灵活性，Java中天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类的生命周期:  </p><p>加载(Loading) –&gt; 验证(Verification) –&gt; 准备(Preparation) —&gt; 解析(Resolution) —&gt; 初始化(Initialization) —&gt; 使用(Using) —&gt; 卸载(Unloading)</p><p>其中 验证，准备，解析统称为连接。  </p><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始。  </p><p>而解析阶段则不一定:  它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定(也称为动态绑定或晚期绑定)。  </p><p>这些阶段的各个步骤是互相交叉地混合式进行的，通常会在一个阶段执行的过程中调用或激活另外一个阶段。  </p><p>虚拟机并没有强制约束什么时候执行加载，但严格规定了四种情况下必须立即对类进行”初始化”(而加载、验证、准备自然需要在此之前开始):  </p><ol><li><p>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先出发其初始化。生成这4条指令的最常见的Java代码场景是: 使用new关键字实例化对象的时候、读取或设置一个类的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外)的时候，以及调用一个类的静态方法的时候。</p></li><li><p>使用java.lang.reflect包的方法对类进行发射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。  </p></li><li><p>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p></li><li><p>当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。  </p></li></ol><p>这四种场景中的行为称为对一个类进行主动引用。除此之外所有引用类的方式，都不会触发初始化，称为被动引用。  </p><h3 id="被动引用例子"><a href="#被动引用例子" class="headerlink" title="被动引用例子"></a>被动引用例子</h3><p>例一:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过子类引用父类的静态字段，不会导致子类初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SuperClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码运行之后，只会输出”SuperClass init!”，而不会输出”SubClass init!”。对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。至于是否要触发子类的加载和验证，在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。</p><p>例二:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过数组定义来引用类，不会触发此类的初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例三:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"ConstClass init!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非主动使用类字段演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         System.out.println(Constant.HELLOWORLD);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述代码运行之后，也没有输出”ConstClass init!”, 这是因为虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，但是在编译阶段将此常量的值”hello world”存储到了NotInitialization类的常量池中，对常量ConstClass.HELLOWORLD的引用实际都被转化为NotInitialization类对自身常量池的引用了。也就是说实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。  </p><h2 id="接口的加载过程"><a href="#接口的加载过程" class="headerlink" title="接口的加载过程"></a>接口的加载过程</h2><p>接口的加载过程与类加载过程稍有一些不同，针对接口需要做一些特殊说明:</p><p>接口也有初始化过程，这点与类是一致的，上面的代码都是用静态语句块”static{}”来输出初始化信息的，而接口中不能使用”static{}”语句块，但编译器仍然会为接口生成”\&lt;clinit>()”类构造器，用于初始化接口中所定义的成员变量。  </p><p>接口与类真正有所区别的是前面讲述的四种”有且仅有”需要开始初始化场景中的第三种: 当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候(如引用接口中定义的常量)才会初始化。</p>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jvm类文件的结构5-属性表集合</title>
      <link href="/2019/08/09/jvm-11/"/>
      <url>/2019/08/09/jvm-11/</url>
      <content type="html"><![CDATA[<h2 id="属性表简介"><a href="#属性表简介" class="headerlink" title="属性表简介"></a>属性表简介</h2><p>在字段表、方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。  </p><p>属性表集合的限制比较宽松，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。  </p><p>以下是虚拟机规范预定义的属性:</p><table><thead><tr><th style="text-align:center">属性名称</th><th style="text-align:center">使用位置</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">Code</td><td style="text-align:center">方法表</td><td style="text-align:center">Java代码编译成的字节码指令</td></tr><tr><td style="text-align:center">ConstantValue</td><td style="text-align:center">字段表</td><td style="text-align:center">final关键字定义的常量值</td></tr><tr><td style="text-align:center">Deprecated</td><td style="text-align:center">类、方法表、字段表</td><td style="text-align:center">被声明为deprecated的方法和字段</td></tr><tr><td style="text-align:center">Exceptions</td><td style="text-align:center">方法表</td><td style="text-align:center">方法抛出的异常</td></tr><tr><td style="text-align:center">InnerClasses</td><td style="text-align:center">类文件</td><td style="text-align:center">内部类列表</td></tr><tr><td style="text-align:center">LineNumberTable</td><td style="text-align:center">Code属性</td><td style="text-align:center">Java源码的行号与字节码指令的对应关系</td></tr><tr><td style="text-align:center">LocalVariableTable</td><td style="text-align:center">Code属性</td><td style="text-align:center">方法的局部变量描述</td></tr><tr><td style="text-align:center">SourceFile</td><td style="text-align:center">类文件</td><td style="text-align:center">源文件名称</td></tr><tr><td style="text-align:center">Synthetic</td><td style="text-align:center">类、方法表、字段表</td><td style="text-align:center">标识方法或字段为编译器自动生成的</td></tr></tbody></table><p>对于每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要说明属性值所占用的位数长度即可。  </p><p>属性表结构</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">名称</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:center">u2</td><td style="text-align:center">attribute_name_index</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">attribute_lenght</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u1</td><td style="text-align:center">info</td><td style="text-align:center">attribute_lenght</td></tr></tbody></table><h2 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h2><p>Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内。  </p><p>Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或抽象类中的方法就不存在Code属性。  </p><h3 id="Code属性表的结构"><a href="#Code属性表的结构" class="headerlink" title="Code属性表的结构"></a>Code属性表的结构</h3><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">名称</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:center">u2</td><td style="text-align:center">attribute_name_index</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u4</td><td style="text-align:center">attribute_length</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">max_stack</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">max_locals</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u4</td><td style="text-align:center">code_length</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u1</td><td style="text-align:center">code</td><td style="text-align:center">code_length</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">exception_table_length</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">exception_info</td><td style="text-align:center">exception_table</td><td style="text-align:center">exception_table_length</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">attributes_count</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">attribute_info</td><td style="text-align:center">attributes</td><td style="text-align:center">attributes_count</td></tr></tbody></table><h4 id="attribute-name-index"><a href="#attribute-name-index" class="headerlink" title="attribute_name_index"></a>attribute_name_index</h4><p>attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，常量值固定为”Code”，它代表了该属性的属性名称, attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共是6个字节，所以属性值的长度固定为整个属性表的长度减去6个字节。  </p><h4 id="max-stack"><a href="#max-stack" class="headerlink" title="max_stack"></a>max_stack</h4><p>max_stack代表了操作数栈(Operand Stacks)深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧(Frame)中的操作栈深度。  </p><h4 id="max-locals"><a href="#max-locals" class="headerlink" title="max_locals"></a>max_locals</h4><p>max_locals代表了局部变量表所需的存储空间。在这里，max_locals的单位是Slot，Slot是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean、reference和returnAddress等长度不超过32位的数据类型，每个局部变量占用1个Slot，而double和long这两种64位的数据类型则需要2个Slot来存放。<br>方法参数(包括实例方法中的隐藏参数”this”)、显式异常处理器的参数(Exception Handler Parameter, 即try-catch语句中catch块所定义的异常)、方法体中定义的局部变量都需要使用局部变量表来存放。<br>另外，并不是在方法中用到了多少个局部变量，就把这些局部变量所占的Slot之和作为max_locals的值，原因是局部变量表中的Slot可以重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的Slot就可以被其他局部变量所使用，编译器会根据变量的作用域来分类Slot并分配给各个变量使用，然后计算出max_locals的大小。  </p><h4 id="code-length-和-code"><a href="#code-length-和-code" class="headerlink" title="code_length 和 code"></a>code_length 和 code</h4><p>code_length和code用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。既然名为字节码指令，那么每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以相应地找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及参数应当如何理解。我们知道一个u1数据类型的取值范围为0x00到0xFF，对应十进制的0~255，也就是一共可以表达256条指令。  </p><p>关于code_length,还有一件值得注意的事情，虽然它是一个u4类型的长度值，理论上最大值可以达到2^32-1，但是虚拟机规范中限制了一个方法不允许超过65535条字节码指令，如果超过这个限制，Javac编译器就会拒绝编译。一般来讲，只要我们写Java代码时不是刻意去编写超长的方法，就不会超过这个最大值的限制。但是，在编译复杂的JSP文件时，可能会因为这个原因导致编译失败。  </p><p>Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码(Code,方法体里面的Java代码)和元数据(Metadata，包括类、字段、方法定义及其他信息)两部分，那么在整个Class文件里，Code属性用于描述代码，所有其他数据项目都用于描述元数据。</p><h4 id="异常表集合"><a href="#异常表集合" class="headerlink" title="异常表集合"></a>异常表集合</h4><p>异常表对于Code来说并不是必须存在的。  </p><p>异常表格式如下:  </p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">名称</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:center">u2</td><td style="text-align:center">start_pc</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">end_pc</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">handler_pc</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">catch_type</td><td style="text-align:center">1</td></tr></tbody></table><p>如果字节码从第start_pc行到第end_pc行之间(不含第end_pc行)出现了类型为catch_type或其子类的异常(catch_type为指向一个CONSTANT_Class_info型常量的索引)，则转到第handler_pc行继续处理。当catch_type的值为0时，代表任何的异常情况都需要转向到handler_pc处进行处理。  </p><p>编译器为try catch生成了三条异常表记录:  </p><ol><li><p>如果try语句块中出现属于Exception或其子类的异常，则转到catch语句块处理。  </p></li><li><p>如果try语句块中出现不属于Exception或其子类的异常，则转到finally语句块处理。  </p></li><li><p>如果catch语句块中出现任何异常，则转到finally语句块中处理。  </p></li></ol><h2 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h2><p>Exceptions属性的作用是列举出方法中可能抛出的受查异常(Checked Exceptions)，也就是方法在描述时在throws关键字后面列举的异常。  </p><p>结构如下表:</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">名称</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:center">u2</td><td style="text-align:center">attribute_name_index</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u4</td><td style="text-align:center">attribute_length</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">number_of_exceptions</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">exception_index_table</td><td style="text-align:center">number_of_exceptions</td></tr></tbody></table><p>number_of_exceptions表示方法会抛出多少个受查异常。<br>每一种受查异常使用一个exception_index_table项表示，exception_index_table是一个指向常量池中CONSTANT_Class_info型常量的索引，代表了该受查异常的类型。  </p><h2 id="LineNumberTable"><a href="#LineNumberTable" class="headerlink" title="LineNumberTable"></a>LineNumberTable</h2><p>LineNumberTable属性用于描述Java源码行号与字节码行号(字节码的偏移量)之间的对应关系。它并不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中使用-g: none 或 -g: lines选项来取消或要求生成这项信息。如果选择不生成LineNumberTable属性，对程序运行产生的最主要的影响就是在抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候无法按照源码来设置断点。  </p><h2 id="LocalVariableTable"><a href="#LocalVariableTable" class="headerlink" title="LocalVariableTable"></a>LocalVariableTable</h2><p>LocalVariableTable属性用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系，它不是运行时必需的属性，默认也不会生成到Class文件之中，可以在Javac中使用-g:none 或 -g: vars选项来取消或要求生成这项信息。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将丢失，IDE可能会使用诸如arg0、arg1之类的占位符来代替原有的参数名，这对程序运行没有影响，但是会给代码编写带来较大的不便，而且在调试期间调试器无法根据参数名称从运行上下文中获得参数值。  </p><p>在JDK 1.5引入泛型之后，LocalVariableTable属性增加了一个”姐妹属性”: LocalVariableTypeTable，这个新增的属性结构与LocalVariableTable非常相似，仅仅是把记录的字段描述符的descriptor_index替换成了字段的特征签名(Signature)，对于非泛型类型来说，描述符和特征签名能描述的信息基本是一致的，但是引入泛型后，由于描述符中泛型的参数化类型被擦除掉了，描述符就不能准确地描述泛型类型了，因此出现了LocalVariableTypeTable.</p><h2 id="SourceFile"><a href="#SourceFile" class="headerlink" title="SourceFile"></a>SourceFile</h2><p>SourceFile属性用于记录生成这个Class文件的源码文件名称。这个属性也是可选的，可以使用Javac的-g: none 或 -g: source选项来关闭或要求生成这项信息。在Java中，对于大多数的类来说，类名和文件名是一致的，但是有一些特殊情况(如内部类)例外。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错误代码所属的文件名。  </p><p>结构如下所示:  </p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">名称</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:center">u2</td><td style="text-align:center">attribute_name_index</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u4</td><td style="text-align:center">attribute_length</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">sourcefile_index</td><td style="text-align:center">1</td></tr></tbody></table><h2 id="ConstantValue"><a href="#ConstantValue" class="headerlink" title="ConstantValue"></a>ConstantValue</h2><p>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static 关键字修饰的变量(类变量) 才可以使用这项属性。<br>对于非static类型的变量(也就是实例变量)的赋值是在实例构造器\&lt;init>方法中进行的；<br>而对于类变量，则有两种方式可以选择:</p><ol><li><p>赋值在类构造器\&lt;clinit>方法中进行</p></li><li><p>使用ConstantValue属性来赋值。</p></li></ol><p>Sun Javac编译器的选择是: 如果同时使用final和static来修饰一个常量，并且这个变量的数据类型是基本类型或java.lang.String的话，就生成ConstantValue属性来进行初始化，如果这个变量没有被final修饰，或者并非基本类型及字符串，则选择在\&lt;clinit>中进行初始化。  </p><p>虽然有final关键字才更符合”ConstantValue”的语义，但虚拟机规范中并没有强制要求字段必须设置了ACC_FINAL标志， 只要求了有ConstantValue属性的字段必须设置ACC_STATIC标志，对final关键字的要求是Javac编译器自己加入的限制。</p><p>而ConstantValue的属性值则只限于基本类型和String，不过笔者不认为这是什么限制，因为此属性的属性值只是一个常量池的索引号，由于Class文件格式的常量类型中只有与基本属性和字符串相对应的字面量，所以就算ConstantValue属性想支持别的类型也无能为力。  </p><h2 id="InnerClasses"><a href="#InnerClasses" class="headerlink" title="InnerClasses"></a>InnerClasses</h2><p>InnerClasses属性用于记录内部类与宿主类之间的关联。如果一个类定义了内部类，那编译器将会为它及它所包含的内部类生成InnerClasses属性。  </p><p>属性的结构如表所示:  </p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">名称</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:center">u2</td><td style="text-align:center">attribute_name_index</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u4</td><td style="text-align:center">attribute_length</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">number_of_classes</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">inner_classes_info</td><td style="text-align:center">inner_classes</td><td style="text-align:center">number_of_classes</td></tr></tbody></table><p>数据项number_of_classes代表需要记录多少个内部类信息，每一个内部类的信息都由一个inner_classes_info表进行描述。  </p><p>inner_classes_info表的结构如下:</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">名称</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:center">u2</td><td style="text-align:center">inner_class_info_index</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">outer_class_info_index</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">inner_name_index</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">inner_class_access_flags</td><td style="text-align:center">1</td></tr></tbody></table><h3 id="inner-class-info-index-outer-class-info-index"><a href="#inner-class-info-index-outer-class-info-index" class="headerlink" title="inner_class_info_index, outer_class_info_index"></a>inner_class_info_index, outer_class_info_index</h3><p>inner_class_info_index和outer_class_info_index都是指向常量池中CONSTANT_Class_info型常量的索引，分别代表了内部类和宿主类的符号引用。  </p><h3 id="inner-name-index"><a href="#inner-name-index" class="headerlink" title="inner_name_index"></a>inner_name_index</h3><p>inner_name_index是指向常量池中CONSTANT_Utf8_info型常量的索引，代表这个内部类的名称，如果是匿名内部类，则这项值为0。</p><h3 id="inner-class-access-flags"><a href="#inner-class-access-flags" class="headerlink" title="inner_class_access_flags"></a>inner_class_access_flags</h3><p>inner_class_access_flags是内部类的访问标志，类似于类的access_flags.</p><h2 id="Deprecated及Synthetic属性"><a href="#Deprecated及Synthetic属性" class="headerlink" title="Deprecated及Synthetic属性"></a>Deprecated及Synthetic属性</h2><p>Deprecated和Synthetic两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。  </p><p>Deprecated属性用于表示某个类、字段或方法已经被程序作者定为不再推荐使用，它可以通过在代码中使用@deprecated注释进行设置。  </p><p>Synthetic属性代表此字段或方法并不是由Java源码直接产生的，而是由编译器自行添加的，在JDK1.5之后，标识一个类、字段或方法是编译器自动产生的，也可以设置它们访问标志中的ACC_SYNTHETIC标志位，其中最典型的例子就是Bridge Method。所有由非用户代码产生的类、方法及字段都应当至少设置Synthetic属性和ACC_SYNTHETIC标志位中的一项，唯一的例外是实例构造器“\&lt;init>”方法和类构造器”\&lt;clinit>“方法。  </p><p>Deprecated和Synthetic属性的结构非常简单:</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">名称</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:center">u2</td><td style="text-align:center">attribute_name_index</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u4</td><td style="text-align:center">attribute_length</td><td style="text-align:center">1</td></tr></tbody></table><p>其中attribute_length数据项的值必须为0x00000000，因为没有任何属性值需要设置。  </p>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jvm类文件的结构4-字段表集合和方法表集合</title>
      <link href="/2019/08/09/jvm-10/"/>
      <url>/2019/08/09/jvm-10/</url>
      <content type="html"><![CDATA[<h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><h2 id="字段表集合的信息"><a href="#字段表集合的信息" class="headerlink" title="字段表集合的信息"></a>字段表集合的信息</h2><p>字段表(field_info)用于描述接口或类中声明的变量。  </p><p>字段(field包括了类级变量或实例级变量，但不包括方法内部声明的变量)</p><p>Java中描述一个字段包含以下信息:  </p><ol><li><p>字段的作用域(public、pivate、 protected修饰符)</p></li><li><p>类级变量还是实例级变量(static修饰符)</p></li><li><p>可变性(final)</p></li><li><p>并发可见性(volatile修饰符，是否强制从主内存读写)</p></li><li><p>可否序列化(transient修饰符)</p></li><li><p>字段数据类型(基本类型、对象、数组)、字段名称。  </p></li></ol><p>这些信息大概可分为两类:  </p><ol><li><p>修饰符. 修饰符只有有和无两种状态，适合使用标志位表示</p></li><li><p>无法确定的信息。引用常量池中的常量来描述。  </p></li></ol><h3 id="字段表集合的结构"><a href="#字段表集合的结构" class="headerlink" title="字段表集合的结构"></a>字段表集合的结构</h3><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">名称</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:center">u2</td><td style="text-align:center">access_flags</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">name_index</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">descriptor_index</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">attributes_count</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">attribute_info</td><td style="text-align:center">attributes</td><td style="text-align:center">attributes_count</td></tr></tbody></table><h4 id="access-flags"><a href="#access-flags" class="headerlink" title="access_flags"></a>access_flags</h4><p>字段修饰符在access_flags项目中，也是以或的形式拼接各类修饰符</p><h5 id="字段访问标志"><a href="#字段访问标志" class="headerlink" title="字段访问标志"></a>字段访问标志</h5><table><thead><tr><th style="text-align:center">标志名称</th><th style="text-align:center">标志值</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">ACC_PUBLIC</td><td style="text-align:center">0x0001</td><td style="text-align:center">字段是否public</td></tr><tr><td style="text-align:center">ACC_PRIVATE</td><td style="text-align:center">0x0002</td><td style="text-align:center">字段是否private</td></tr><tr><td style="text-align:center">ACC_PROTECTED</td><td style="text-align:center">0x0004</td><td style="text-align:center">字段是否protected</td></tr><tr><td style="text-align:center">ACC_STATIC</td><td style="text-align:center">0x0008</td><td style="text-align:center">字段是否static</td></tr><tr><td style="text-align:center">ACC_FINAL</td><td style="text-align:center">0x0010</td><td style="text-align:center">字段是否final</td></tr><tr><td style="text-align:center">ACC_VOLATILE</td><td style="text-align:center">0x0040</td><td style="text-align:center">字段是否volatile</td></tr><tr><td style="text-align:center">ACC_TRANSIENT</td><td style="text-align:center">0x0080</td><td style="text-align:center">字段是否transient</td></tr><tr><td style="text-align:center">ACC_SYNTHETIC</td><td style="text-align:center">0x1000</td><td style="text-align:center">字段是否由编译器自动产生的</td></tr><tr><td style="text-align:center">ACC_ENUM</td><td style="text-align:center">0x4000</td><td style="text-align:center">字段是否enum</td></tr></tbody></table><h4 id="name-index和descriptor-index"><a href="#name-index和descriptor-index" class="headerlink" title="name_index和descriptor_index"></a>name_index和descriptor_index</h4><p>它们都是对常量池的引用，分别代表着字段的简单名称及字段和方法的描述符。</p><h5 id="全限定名、简单名称、描述符"><a href="#全限定名、简单名称、描述符" class="headerlink" title="全限定名、简单名称、描述符"></a>全限定名、简单名称、描述符</h5><h6 id="权限定名"><a href="#权限定名" class="headerlink" title="权限定名"></a>权限定名</h6><p>格式如: org/fenixsoft/clazz/TestClass。将类全名的”.”替换成了”/“，为了使连续的多个全限定名之间不产生混淆，在使用时最后会加上；  </p><h6 id="简单名称"><a href="#简单名称" class="headerlink" title="简单名称"></a>简单名称</h6><p>简单名称就是指没有类型和参数修饰的方法或字段名称，这个类中的inc()方法和m字段的简单名称分别是”inc”和”m”。  </p><h6 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h6><p>用来描述字段的数据类型、方法的参数列表(包括数量、类型以及顺序)和返回值。  </p><p>根据描述符规则，基本数据类型(byte、char、double、float、int、long、short、boolean)及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示。</p><table><thead><tr><th style="text-align:center">标识字符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">B</td><td style="text-align:center">基本类型byte</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">基本类型char</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">基本类型double</td></tr><tr><td style="text-align:center">F</td><td style="text-align:center">基本类型float</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">基本类型int</td></tr><tr><td style="text-align:center">J</td><td style="text-align:center">基本类型long</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">基本类型short</td></tr><tr><td style="text-align:center">Z</td><td style="text-align:center">基本类型boolean</td></tr><tr><td style="text-align:center">V</td><td style="text-align:center">特殊类型void</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">对象类型，如Ljava/lang/Object</td></tr></tbody></table><p>对于数组类型，每一维度将使用一个前置的”[“字符来描述  </p><p>如一个定义为”java.lang.String[][]“类型的二维数组，将被记录为: “[[Ljava/lang/String;”  </p><p>一个整型数组”int[]”将被记录为”[I”。  </p><p>用描述符描述方法时，按照先参数列表，后返回值的顺序。参数列表按照参数的严格顺序放在一组小括号”()”之内。</p><p>如方法void inc()的描述符为”()V”</p><p>方法java.lang.String toString()的描述符为”()Ljava/lang/String;”</p><p>方法int indexOf(char[] soure, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex)的描述符为”([CII[CIII)I”。  </p><h4 id="attribute-info"><a href="#attribute-info" class="headerlink" title="attribute_info"></a>attribute_info</h4><p>将在属性表中详细讲解</p><h3 id="字段表总结"><a href="#字段表总结" class="headerlink" title="字段表总结"></a>字段表总结</h3><p>字段表集合中不会列出超类或父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。  </p><p>另外，在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。  </p><h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><h2 id="方法表描述"><a href="#方法表描述" class="headerlink" title="方法表描述"></a>方法表描述</h2><p>方法表描述和字段的描述基本一致，包括了:</p><ul><li><p>访问标志(access_flags)</p></li><li><p>名称索引(name_index)</p></li><li><p>描述符索引(descriptor_index)</p></li><li><p>属性表集合(attributes)</p></li></ul><p>不同之处主要在于访问标志和属性表集合的可选项。  </p><p>方法中没有 <strong>volatile</strong> 和 <strong>transient</strong>,但是多了 <strong>synchronized</strong>、<strong>native</strong>、<strong>strictfp</strong>、<strong>abstract</strong>。如下:  </p><table><thead><tr><th style="text-align:center">标志名称</th><th style="text-align:center">标志值</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">ACC_PUBLIC</td><td style="text-align:center">0x0001</td><td style="text-align:center">方法是否为public</td></tr><tr><td style="text-align:center">ACC_PRIVATE</td><td style="text-align:center">0x0002</td><td style="text-align:center">方法是否为private</td></tr><tr><td style="text-align:center">ACC_PROTECTED</td><td style="text-align:center">0x0004</td><td style="text-align:center">方法是否为protected</td></tr><tr><td style="text-align:center">ACC_STATIC</td><td style="text-align:center">0x0008</td><td style="text-align:center">方法是否为static</td></tr><tr><td style="text-align:center">ACC_FINAL</td><td style="text-align:center">0x0010</td><td style="text-align:center">方法是否为final</td></tr><tr><td style="text-align:center">ACC_SYNCHRONIZED</td><td style="text-align:center">0x0020</td><td style="text-align:center">方法是否为synchronized</td></tr><tr><td style="text-align:center">ACC_BRIDGE</td><td style="text-align:center">0x0040</td><td style="text-align:center">方法是否为编译器产生的桥接方法</td></tr><tr><td style="text-align:center">ACC_VARARGS</td><td style="text-align:center">0x0080</td><td style="text-align:center">方法是否接受不定参数</td></tr><tr><td style="text-align:center">ACC_NATIVE</td><td style="text-align:center">0x0100</td><td style="text-align:center">方法是否为native</td></tr><tr><td style="text-align:center">ACC_ABSTRACT</td><td style="text-align:center">0x0400</td><td style="text-align:center">方法是否为abstract</td></tr><tr><td style="text-align:center">ACC_STRICT</td><td style="text-align:center">0x0800</td><td style="text-align:center">方法是否为strictfp</td></tr><tr><td style="text-align:center">ACC_SYNTHETIC</td><td style="text-align:center">0x1000</td><td style="text-align:center">方法是否为编译器自动产生的</td></tr></tbody></table><p>而方法里的Java代码，经过编译器编译成字节码指令之后，存放在方法属性表集合中的一个名为”Code”的属性里面。  </p><h3 id="方法表总结"><a href="#方法表总结" class="headerlink" title="方法表总结"></a>方法表总结</h3><p>如果父类方法在子类中没有被重写(Override)，方法表集合中就不会出现来自父类的方法信息。 但有可能会出现由编译器自动添加的方法，最典型的是类构造器”\&lt;clinit>“方法和实例构造器”\&lt;init>“方法。  </p><p>在Java语言中，要重载(Overload)一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名。<br>特征签名就是各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。<br>但是在Class文件格式之中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以共存。 也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。</p>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jvm类文件的结构3-类索引、父类索引与接口索引集合</title>
      <link href="/2019/08/09/jvm-9/"/>
      <url>/2019/08/09/jvm-9/</url>
      <content type="html"><![CDATA[<h2 id="Class文件索引简介"><a href="#Class文件索引简介" class="headerlink" title="Class文件索引简介"></a>Class文件索引简介</h2><p>类索引(this_class)和父类索引(super_class)都是一个u2类型的数据，而接口索引集合(interfaces)是一组u2类型的数据的集合。  </p><p>Class文件中由这三项数据来确定这个类的继承关系：  </p><ol><li><p>类索引用于确定这个类的全限定名。  </p></li><li><p>父类索引用于确定这个类的父类的权限定名。  </p></li><li><p>接口索引集合用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句(如果这个类本身是一个接口，则应当是extends语句)后的接口顺序从左到右排列在接口的索引集合中。  </p></li></ol><h2 id="索引的结构描述"><a href="#索引的结构描述" class="headerlink" title="索引的结构描述"></a>索引的结构描述</h2><p>类索引、父类索引和接口索引集合按顺序排列在访问标志之后。  </p><h3 id="类索引和父类索引"><a href="#类索引和父类索引" class="headerlink" title="类索引和父类索引"></a>类索引和父类索引</h3><p>类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">索引/父类索引        常量池                           常量池</span><br><span class="line">this_class  ---&gt;  CONSTANT_Class_info index----&gt;   CONSTANT_Utf8_info (记录类的全限定名)</span><br></pre></td></tr></table></figure><h3 id="接口索引集合"><a href="#接口索引集合" class="headerlink" title="接口索引集合"></a>接口索引集合</h3><p>接口索引集合，入口第一项————u2类型的数据为接口计数器(interfaces_count)，表示索引表的容量。  </p><p>如果该类没有实现任何接口，那么该计数器值为0，后面接口的索引表不再占用任何字节。</p>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jvm类文件的结构2-常量池与类访问的标志</title>
      <link href="/2019/08/08/jvm-8/"/>
      <url>/2019/08/08/jvm-8/</url>
      <content type="html"><![CDATA[<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>紧接着版本号的是常量池<br>常量池有以下几点特征：</p><ol><li><p>常量池是Class文件结构中与其他项目关联最多的数据类型</p></li><li><p>常量池是占用Class文件空间最大的数据项目之一  </p></li><li><p>常量池是Class文件中第一个出现的表类型数据项目</p></li></ol><h3 id="计数值"><a href="#计数值" class="headerlink" title="计数值"></a>计数值</h3><p>由于常量池中常量的数量是不固定的， 所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值(constant_pool_count)。与Java语言习惯不一样的是，这个容量计数是从1而不是0开始的。<br>制定Class文件格式规范时，将第0项常量空出来是有特殊考虑的：<br>某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”，就可以把索引值置为0来表示。<br>Class文件结构中只有常量池的容量计数是从1开始的，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始的。  </p><h3 id="字面量和符号引用"><a href="#字面量和符号引用" class="headerlink" title="字面量和符号引用"></a>字面量和符号引用</h3><p>常量池之中主要存放两大类常量：字面量(Literal)和符号引用(Symbolic References)。  </p><h4 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h4><p>字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。</p><h4 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h4><p>符号引用主要属于编译原理方面的概念， 包括了下面三类常量：</p><ul><li><p>类和接口的全限定名(Fully Qualified Name)</p></li><li><p>字段的名称和描述符(Descriptor)</p></li><li><p>方法的名称和描述符</p></li></ul><p>Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态连接。<br>也就是说，在Class文件中不会保存各个方法和字段的最终内存布局信息，因此这些字段和方法的符号引用不经过转换的话是无法直接被虚拟机使用的。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析并翻译到具体的内存地址之中。  </p><h3 id="常量表"><a href="#常量表" class="headerlink" title="常量表"></a>常量表</h3><p>常量池中的每一项常量都是一个表，共有11种结构各不相同的表结构数据，这11种表都有一个共同的特点，就是表开始的第一位是一个u1类型的标志位(tag，取值为1至12，缺少标志为2的数据类型)，代表当前这个常量属于哪种常量类型  </p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">标志</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">CONSTANT_Utf8_info</td><td style="text-align:center">1</td><td style="text-align:center">UTF-8编码的字符串</td></tr><tr><td style="text-align:center">CONSTANT_Integer_info</td><td style="text-align:center">3</td><td style="text-align:center">整型字面量</td></tr><tr><td style="text-align:center">CONSTANT_Float_info</td><td style="text-align:center">4</td><td style="text-align:center">浮点型字面量</td></tr><tr><td style="text-align:center">CONSTANT_Long_info</td><td style="text-align:center">5</td><td style="text-align:center">长整型字面量</td></tr><tr><td style="text-align:center">CONSTANT_Double_info</td><td style="text-align:center">6</td><td style="text-align:center">双精度浮点型字面量</td></tr><tr><td style="text-align:center">CONSTANT_Class_info</td><td style="text-align:center">7</td><td style="text-align:center">类或接口的符号引用</td></tr><tr><td style="text-align:center">CONSTANT_String_info</td><td style="text-align:center">8</td><td style="text-align:center">字符串类型字面量</td></tr><tr><td style="text-align:center">CONSTANT_Fieldref_info</td><td style="text-align:center">9</td><td style="text-align:center">字段的符号引用</td></tr><tr><td style="text-align:center">CONSTANT_Methodref_info</td><td style="text-align:center">10</td><td style="text-align:center">类中方法的符号引用</td></tr><tr><td style="text-align:center">CONSTANT_InterfaceMethodref_info</td><td style="text-align:center">11</td><td style="text-align:center">接口中方法的符号引用</td></tr><tr><td style="text-align:center">CONSTANT_NameAndType_info</td><td style="text-align:center">12</td><td style="text-align:center">字段或方法的部分符号引用</td></tr></tbody></table><h4 id="常量表的具体内容"><a href="#常量表的具体内容" class="headerlink" title="常量表的具体内容"></a>常量表的具体内容</h4><h5 id="CONSTANT-Utf8-info"><a href="#CONSTANT-Utf8-info" class="headerlink" title="CONSTANT_Utf8_info"></a>CONSTANT_Utf8_info</h5><p>|项目|类型|描述|<br>|tag|u1|值为1|<br>|length|u2|UTF-8编码的字符串占用的字节数|<br>|bytes|u1|长度为length的UTF-8编码的字符串|</p><h5 id="CONSTANT-Integer-info"><a href="#CONSTANT-Integer-info" class="headerlink" title="CONSTANT_Integer_info"></a>CONSTANT_Integer_info</h5><p>|项目|类型|描述|<br>|tag|u1|值为3|<br>|bytes|u4|按照高位在前存储的int值|</p><h5 id="CONSTANT-Float-info"><a href="#CONSTANT-Float-info" class="headerlink" title="CONSTANT_Float_info"></a>CONSTANT_Float_info</h5><p>|项目|类型|描述|<br>|tag|u1|值为4|<br>|bytes|u4|按照高位在前存储的float值|</p><h5 id="CONSTANT-Long-info"><a href="#CONSTANT-Long-info" class="headerlink" title="CONSTANT_Long_info"></a>CONSTANT_Long_info</h5><p>|项目|类型|描述|<br>|tag|u1|值为5|<br>|bytes|u8|按照高位在前存储的long值|</p><h5 id="CONSTANT-Double-info"><a href="#CONSTANT-Double-info" class="headerlink" title="CONSTANT_Double_info"></a>CONSTANT_Double_info</h5><p>|项目|类型|描述|<br>|tag|u1|值为6|<br>|bytes|u8|按照高位在前存储的double值|</p><h5 id="CONSTANT-Class-info"><a href="#CONSTANT-Class-info" class="headerlink" title="CONSTANT_Class_info"></a>CONSTANT_Class_info</h5><p>|项目|类型|描述|<br>|tag|u1|值为7|<br>|index|u2|指向全限定名常量项的索引|</p><h5 id="CONSTANT-String-info"><a href="#CONSTANT-String-info" class="headerlink" title="CONSTANT_String_info"></a>CONSTANT_String_info</h5><p>|项目|类型|描述|<br>|tag|u1|值为8|<br>|index|u2|指向字符串字面量的索引|</p><h5 id="CONSTANT-Fieldref-info"><a href="#CONSTANT-Fieldref-info" class="headerlink" title="CONSTANT_Fieldref_info"></a>CONSTANT_Fieldref_info</h5><p>|项目|类型|描述|<br>|tag|u1|值为9|<br>|index|u2|指向声明字段的类或接口描述符CONSTANT_Class_info的索引项|<br>|index|u2|指向字段描述符CONSTANT_NameAndType的索引项|</p><h5 id="CONSTANT-Methodref-info"><a href="#CONSTANT-Methodref-info" class="headerlink" title="CONSTANT_Methodref_info"></a>CONSTANT_Methodref_info</h5><p>|项目|类型|描述|<br>|tag|u1|值为10|<br>|index|u2|指向声明字段的类或接口描述符CONSTANT_Class_info的索引项|<br>|index|u2|指向字段描述符CONSTANT_NameAndType的索引项|</p><h5 id="CONSTANT-InterfaceMethodref-info"><a href="#CONSTANT-InterfaceMethodref-info" class="headerlink" title="CONSTANT_InterfaceMethodref_info"></a>CONSTANT_InterfaceMethodref_info</h5><p>|项目|类型|描述|<br>|tag|u1|值为11|<br>|index|u2|指向声明字段的类或接口描述符CONSTANT_Class_info的索引项|<br>|index|u2|指向字段描述符CONSTANT_NameAndType的索引项|</p><h5 id="CONSTANT-NameAndType-info"><a href="#CONSTANT-NameAndType-info" class="headerlink" title="CONSTANT_NameAndType_info"></a>CONSTANT_NameAndType_info</h5><p>|项目|类型|描述|<br>|tag|u1|值为12|<br>|index|u2|指向该字段或方法名称常量项的索引|<br>|index|u2|指向该字段或方法描述符常量项的索引|</p><h3 id="javap-verbose"><a href="#javap-verbose" class="headerlink" title="javap -verbose"></a>javap -verbose</h3><p>我们可以使用javap -verbose来查看一个Class文件的字节码信息。  </p><h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>常量池之后的2个字节代表访问标志(access_flags)，这个标志用于识别一些类或接口层次的访问信息，包括:  </p><ul><li><p>这个Class是类还是接口</p></li><li><p>是否定义为public类型</p></li></ul><p>….</p><p>以下是Java中的访问标志:  </p><table><thead><tr><th style="text-align:center">标志名称</th><th style="text-align:center">标志值</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">ACC_PUBLIC</td><td style="text-align:center">0x0001</td><td style="text-align:center">是否为public类型</td></tr><tr><td style="text-align:center">ACC_FINAL</td><td style="text-align:center">0x0010</td><td style="text-align:center">是否被声明为final，只有类可设置</td></tr><tr><td style="text-align:center">ACC_SUPER</td><td style="text-align:center">0x0020</td><td style="text-align:center">是否允许使用invokespecial字节码指令，JDK1.2之后编译出来的类这个标志为真</td></tr><tr><td style="text-align:center">ACC_INTERFACE</td><td style="text-align:center">0x0200</td><td style="text-align:center">标识这是一个接口</td></tr><tr><td style="text-align:center">ACC_ABSTRACT</td><td style="text-align:center">0x0400</td><td style="text-align:center">是否为abstract类型，对于接口或抽象类来说，这个值为真，其他类值为假</td></tr><tr><td style="text-align:center">ACC_SYNTHETIC</td><td style="text-align:center">0x1000</td><td style="text-align:center">标识这个类并非由用户代码产生的</td></tr><tr><td style="text-align:center">ACC_ANNOTATION</td><td style="text-align:center">0x2000</td><td style="text-align:center">标识这是一个注解</td></tr><tr><td style="text-align:center">ACC_ENUM</td><td style="text-align:center">0x4000</td><td style="text-align:center">标识这是一个枚举</td></tr></tbody></table><p>access_flags一共有32个标志位可以使用，当前只定义了其中的8个。<br>没有使用到的标志位要求一律为0。<br>这些标志位以或的方式集成到一起。</p>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jvm类文件的结构1-魔数与Class文件的版本</title>
      <link href="/2019/08/08/jvm-7/"/>
      <url>/2019/08/08/jvm-7/</url>
      <content type="html"><![CDATA[<h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><p>每个Class文件的头4个字节称为魔数(Magic Number)，它的唯一作用是用于确定这个文件是否为一个能被虚拟机接受的Class文件。<br>很多文件存储标准中都使用魔数来进行身份识别，比如图片格式，如gif或jpeg等在文件头中都存有魔数。<br>使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过而且不会引起混淆即可。<br>Class文件的魔数的获得很有”浪漫气息”，值为:  0xCAFEBABE<br>CA:202  FE:254  BA:186  BE:190</p><h2 id="Class文件的版本"><a href="#Class文件的版本" class="headerlink" title="Class文件的版本"></a>Class文件的版本</h2><p>紧接着魔数的4个字节存储的是Class文件的版本号: 第5和第6个字节的次版本号(Minor Version)，第7个和第8个字节是主版本号(Major Version)。<br>Java的版本号是从45开始的，JDK1.1之后的每个JDK大版本发布主版本号向上加1(JDK 1.0~1.1 使用了45.0~45.3的版本号)<br>高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生变化。<br>如JDK1.1能支持版本号为46.0以上的Class，而JDK1.2则能支持45.0~46.65535的Class文件。  </p>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jvm类文件的结构</title>
      <link href="/2019/08/08/jvm-6/"/>
      <url>/2019/08/08/jvm-6/</url>
      <content type="html"><![CDATA[<h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p>Class 文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部都是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。  </p><h3 id="Class类的伪结构"><a href="#Class类的伪结构" class="headerlink" title="Class类的伪结构"></a>Class类的伪结构</h3><p>Class文件格式采用一种类似于C语言结构体的伪结构来存储，这种伪结构中只有两种数据类型: <strong>无符号数</strong>和<strong>表</strong>。  </p><h4 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h4><p>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述<strong>数字</strong>、<strong>索引引用</strong>、<strong>数量值</strong>，或者按照UTF-8编码构成<strong>字符串值</strong>。  </p><h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><p>表是由多个无符号数或其他表作为数据项构成的复合数据类型，所有表都习惯性地以”_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。  </p><h4 id="Class格式"><a href="#Class格式" class="headerlink" title="Class格式"></a>Class格式</h4><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">名称</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:center">u4</td><td style="text-align:center">magic</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">minor_version</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">major_version</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">constant_pool_count</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">cp_info</td><td style="text-align:center">constant_pool</td><td style="text-align:center">constant_pool_count - 1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">access_flags</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">this_class</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">super_class</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">interfaces_count</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">interfaces</td><td style="text-align:center">interfaces_count</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">fields_count</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">field_info</td><td style="text-align:center">fields</td><td style="text-align:center">fields_count</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">methods_count</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">method_info</td><td style="text-align:center">methods</td><td style="text-align:center">methods_count</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">attributes_count</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">attribute_info</td><td style="text-align:center">attributes</td><td style="text-align:center">attributes_count</td></tr></tbody></table><p>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的集合。  </p>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jvm内存分配</title>
      <link href="/2019/08/08/jvm-5/"/>
      <url>/2019/08/08/jvm-5/</url>
      <content type="html"><![CDATA[<h3 id="jvm内存分配简介"><a href="#jvm内存分配简介" class="headerlink" title="jvm内存分配简介"></a>jvm内存分配简介</h3><p>对象的内存分配，往大方向上讲，就是在堆上分配(但也可能经过JIT编译后被拆散为标量类型并间接地在栈上分配)，对象主要分配在新生代地Eden区上，如果启动了本地线程分配缓冲，将按线程优先优先在TLAB上分配。少数情况也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。  </p><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。  </p><h4 id="Minor-GC-与-Full-GC"><a href="#Minor-GC-与-Full-GC" class="headerlink" title="Minor GC 与 Full GC"></a>Minor GC 与 Full GC</h4><ul><li><p>新生代GC(Minor GC): 指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。  </p></li><li><p>老年代GC(Major GC/Full GC): 指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC (但非绝对的，在ParallelScavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。MajorGC的速度一般会比Minor GC 慢10倍以上。</p></li></ul><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>所谓大对象就是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串及数组(笔者例子中的byte[]数组就是典型的大对象)。大对象对虚拟机的内存分配来说就是一个坏消息。(最坏的是”朝生夕灭”的”短命大对象”)，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来”安置”它们。  </p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对象年龄(Age)计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认为15岁)时，就会被晋升到老年代中。  </p><h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。  </p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC；如果不允许，则也要改为进行一次Full GC。  </p><p>新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况时(最极端的就是内存回收后新生代中所有对象都存活)，就需要老年代进行分配担保，让Survivor无法容纳的对象直接进入老年代。  </p><p>老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来，在实际完成内存回收之前是无法明确知道的，所以只好 <strong>取之前每一次回收晋升到老年代对象容量的平均大小值</strong> 作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。  </p><p>取平均值进行比较其实仍然是一种动态概率的手段，也就是说如果某次 Minor GC 存活后的对象突增，远远高于平均值的话，依然会导致担保失败(Handle Promotion Failure)。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开。  </p>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jvm垃圾收集算法</title>
      <link href="/2019/08/08/jvm-4/"/>
      <url>/2019/08/08/jvm-4/</url>
      <content type="html"><![CDATA[<h3 id="垃圾收集简介"><a href="#垃圾收集简介" class="headerlink" title="垃圾收集简介"></a>垃圾收集简介</h3><p>垃圾收集(Garbage Collection, GC),并不是Java语言的伴生产物，1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。<br>GC主要关注三个重点:  </p><ol><li><p>哪些内存需要回收  </p></li><li><p>什么时候回收  </p></li><li><p>如何回收</p></li></ol><h3 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h3><p>目前针对哪些内存需要回收这个问题，主要有两种算法:  </p><ol><li><p>引用计数算法  </p></li><li><p>根搜索算法  </p></li></ol><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>很多教科书判断对象是否存活的算法是:<br>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；<br>任何时刻计数器都为0的对象就是不可能再被使用的。<br>Java中没有选用这种算法来管理内存，最主要的原因是它很难解决对象之间的相互循环引用的问题:<br>对象 objA 和 objB 都有字段instance，赋值令objA.instance = objB 及 objB.instance = objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。  </p><h4 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h4><p>再主流的商用程序语言中(Java 和 C#，Lisp)，都是使用根搜索算法(GC Roots Tracing) 判定对象是否存活的。  </p><p>这个算法的基本思路是通过一系列名为”GC ROOT”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。  </p><h5 id="GC-Roots对象"><a href="#GC-Roots对象" class="headerlink" title="GC Roots对象"></a>GC Roots对象</h5><p>在Java 语言里，可作为GC Roots的对象包括下面几种:  </p><ul><li><p>虚拟机栈(栈帧中的本地变量表)中的引用的对象。  </p></li><li><p>方法区中的类静态属性引用的对象。  </p></li><li><p>方法区中的常量引用的对象。</p></li><li><p>本地方法栈中方JNI(即一般说的Native方法)的引用的对象。  </p></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>无论是通过引用计数算法判断对象的引用数量， 还是通过跟搜索算法判断对象的引用链是否可达，判定对象是否存活都与”引用”有关。<br>在JDK 1.2之前，Java中的引用的定义很传统: 如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。 这种定义很存粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，我们希望能描述这样一类对象:<br>当内存空间还足够时，则能保留在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。<br> 在JDK1.2之后，Java对引用的概念进行了扩充， 将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)四种，这四种引用强度依次逐渐减弱。  </p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>强引用就是指在程序代码中普遍存在的，类似”Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。  </p><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>软引用用来描述一些还有用，但并非必需的对象。对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。  </p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。</p><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>虚引用也称为幽灵引用或者欢迎引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时受到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。</p><h3 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收"></a>什么时候回收</h3><p>在根搜索算法中不可达对象，也并非是”非死不可”的，这时候它们暂时处于”缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：  </p><ol><li>如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为”没有必要执行”。<br>如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的”执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在 finalize() 方法中执行缓慢，或者发生了死循环(更极端的情况)，将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。  </li><li>finalize()方法是对像逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的一个对象建立关联即可，譬如把自己(this 关键字)赋值给某个类变量或对象的成员变量，那再第二次标记时它将被移除出”即将回收”的集合；如果这个时候对象还没有逃脱，那它将被回收。  </li></ol><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>很多人认为方法区(或者HotSpot虚拟机中的永久代) 是没有垃圾收集的。Java虚拟机规范中确实说过可以不要求虚拟机再方法区实现垃圾收集，而且再方法区进行垃圾收集的”性价比”一般比较低：<br>在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70% ~ 95%的空间，而永久代的垃圾收集效率远低于此。<br>永久代的垃圾收集主要回收两部分内容:  </p><h4 id="废弃常量"><a href="#废弃常量" class="headerlink" title="废弃常量"></a>废弃常量</h4><p>回收废弃常量与回收Java堆中的对象非常相似。以常量池中字面量的回收为例，假如一个字符串”abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做”abc”的，换句话说是没有任何String对象引用常量池中的”abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，这个”abc”常量就会被回收掉。 常量池中的其他类(接口)、方法、字段的符号引用也与此类似。  </p><h4 id="无用的类"><a href="#无用的类" class="headerlink" title="无用的类"></a>无用的类</h4><p>判定一个常量是否是”废弃常量”比较简单，而要判定一个类是否是”无用的类”的条件则相对苛刻许多。类需要同时满足下面三个条件才能算是”无用的类”：  </p><ol><li><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。  </p></li><li><p>加载该类的ClassLoader已经被回收。  </p></li><li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。  </p></li></ol><h3 id="如何回收-垃圾收集算法"><a href="#如何回收-垃圾收集算法" class="headerlink" title="如何回收(垃圾收集算法)"></a>如何回收(垃圾收集算法)</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>最基础的收集算法是”标记-清除”(Mark-Sweep)算法，如它的名字一样，算法分为”标记”和”清除”两个阶段:<br>首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是之前说明的标记判定。<br>它的主要缺点由两个:  </p><ol><li><p>效率问题，标记和清除过程的效率都不高。  </p></li><li><p>空间问题，标记清除后会产生大量不连续的内存碎片。空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。  </p></li></ol><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决效率问题，一种称为”复制”(Copying)的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收。内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半。<br>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间。每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过地Survivor地空间。<br>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1,也就是每次新生代中可用内存空间为整个新生代容量的90%(80%+10%)，只有10%的内存是会被”浪费”的。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存(这里指老年代)进行分配担保(Handle Promotion)。</p><h5 id="分配担保"><a href="#分配担保" class="headerlink" title="分配担保"></a>分配担保</h5><p>如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。  </p><h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h4><p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的机端情况，所以在老年代一般不能直接选用这种算法。  </p><p>根据老年代的特点，有人提出了另外一种”标记-整理”(Mark-Compact)算法，标记过程仍然与”标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。  </p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>当前商业虚拟机的垃圾收集都采用”分代收集”(Generational Collection)算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最合适的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要符出少量存活对象的复制成本就可以完成收集。 而老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用”标记-清理”或”标记-整理”算法来进行回收。  </p>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java运行区域</title>
      <link href="/2019/08/08/jvm-2/"/>
      <url>/2019/08/08/jvm-2/</url>
      <content type="html"><![CDATA[<h3 id="Java运行区域简介"><a href="#Java运行区域简介" class="headerlink" title="Java运行区域简介"></a>Java运行区域简介</h3><p>Java虚拟机所管理的内存将会包括以下几个运行时的数据区域:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+----------------------------------------------------------+</span><br><span class="line">|                                                          |</span><br><span class="line">|       方法区        虚拟机栈     本地方法栈              |</span><br><span class="line">|    Method Area      VM Stack   Native Method Stack       |</span><br><span class="line">|                                                          |</span><br><span class="line">|                                                          |</span><br><span class="line">|        堆              程序计数器                        |</span><br><span class="line">|       Heap       Program Counter Register                |</span><br><span class="line">|                                                          |</span><br><span class="line">+----------------------------------------------------------+</span><br><span class="line">       |  |                       |   |</span><br><span class="line">     --    --                   --     --</span><br><span class="line">      \    /                     \     /</span><br><span class="line">       \  /                       \   /</span><br><span class="line">     执行引擎         ----&gt;     本地库接口     -----&gt;   本地方法库</span><br></pre></td></tr></table></figure><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器(Program Counter Register) 是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里(<strong>仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现</strong>)，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。  </p><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(对于多核处理器来说是一个内核)只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为<strong>线程私有</strong>的内存。</p><p>如果计数器正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；  </p><p>如果正在执行的是Native方法，这个计数器值则为空(Undefined)。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。  </p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>与程序计数器一样，Java虚拟机栈(Java Virtual Machine Stacks)也是线程私有的，它的生命周期与线程相同。虚拟机描述的是Java方法执行的内存模型:  </p><p>每个方法被执行的时候都会同时创建一个栈帧(Stack Frame)用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。  </p><p>在Java虚拟机规范中，对这个区域规定了两种异常状况：  </p><ol><li><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；  </p></li><li><p>如果虚拟机栈可以动态扩展(当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈)，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</p></li></ol><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)。  </p><p>其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot)，其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈(Native Method Stacks)和虚拟机栈的区别:  </p><ol><li><p>虚拟机栈为虚拟机执行Java方法(也就是字节码)服务  </p></li><li><p>而本地方法栈则是为虚拟机使用到的Native方法服务  </p></li></ol><p>虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机(譬如Sun HotSpot虚拟机)直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>对于大多数应用来说，Java堆(Java Heap) 是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。<br>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有的对象实例以及数组都要在堆上分配</span><br></pre></td></tr></table></figure><p>但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生。所有的对象都分配在堆上也渐渐变得不是那么绝对了。  </p><p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作<strong>GC堆</strong>(Garbage Collected Heap)。  </p><p>如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为:新生代和老年代;再细致一点的有Eden空间、From Survivor空间、 To Survivor空间等。<br>从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。<br>不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好的回收内存，或者更快的分配内存。  </p><p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。<br>在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx 和-Xms控制)。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。  </p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区(Method Area)与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap(非堆)，目的应该是与Java堆区分开来。  </p><p>Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。<br>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样”永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收成绩比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。  </p><p>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池(Runtime Constant Pool)是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。  </p><p>Java虚拟机对Class文件的每一部分(自然也包括常量池)的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。  </p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p><p>既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁的使用，而且也可能导致OutOfMemoryError异常出现。<br>在JDK 1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。<br>本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存(包括RAM及SWAP区或者分页文件)的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制(包括物理上的和操作系统级的限制)，从而导致动态扩展时出现OutOfMemoryError异常。  </p>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java技术体系简介</title>
      <link href="/2019/08/08/jvm-1/"/>
      <url>/2019/08/08/jvm-1/</url>
      <content type="html"><![CDATA[<h2 id="Java技术体系简介"><a href="#Java技术体系简介" class="headerlink" title="Java技术体系简介"></a>Java技术体系简介</h2><h3 id="广义"><a href="#广义" class="headerlink" title="广义"></a>广义</h3><p>广义上讲,Clojure、JRuby、Groovy等运行在Java虚拟机上的语言及其相关的程序都属于Java技术体系的一员。</p><h3 id="传统意义"><a href="#传统意义" class="headerlink" title="传统意义"></a>传统意义</h3><p>Sun官方定义的Java技术体系包括以下几个组成部分:  </p><ul><li><p>Java程序设计语言</p></li><li><p>各种硬件平台上的Java虚拟机  </p></li><li><p>Class文件格式  </p></li><li><p>Java API类库  </p></li><li><p>来自商业机构和开源社区的第三方Java类库  </p></li></ul><p>即: <strong>Java语言</strong>, <strong>Class文件规范</strong>, <strong>各种虚拟机</strong>, <strong>API及第三方类库</strong>。</p><p>JDK = Java语言 + Java虚拟机 + Java API类库  (支持Java程序开发的最小环境)<br>JRE =            Java虚拟机 + Java SE API子集 (支持Java程序运行的最小环境)</p><h3 id="Java-SE-API子集"><a href="#Java-SE-API子集" class="headerlink" title="Java SE API子集"></a>Java SE API子集</h3><p>Java SE API子集包括:  </p><table><thead><tr><th style="text-align:center">功能</th><th style="text-align:center">类库</th></tr></thead><tbody><tr><td style="text-align:center">用户界面</td><td style="text-align:center">AWT, Swing, Java 2D</td></tr><tr><td style="text-align:center">相关技术</td><td style="text-align:center">Accessbility, Drag n Drop, Input Methods, Image I/O, Print Service, Sound</td></tr><tr><td style="text-align:center">集成库</td><td style="text-align:center">IDL, JDBC, JNDI, RMI, RMI.IIOP, Scripting</td></tr><tr><td style="text-align:center">其他基础库</td><td style="text-align:center">Beans, Intl Support, I/O, JMX, JNI, Math, Networking, Override Mechanism, Security, Serialization, Extension Mechanism, XML, JAXP</td></tr><tr><td style="text-align:center">语言和工具基础库</td><td style="text-align:center">lang and util, Collections, Concurrency Utilities, JAR, Logging, Management, Preferences API, Ref Objects, Reflection, Regular Expressions, Versioning, Zip,Instrument</td></tr><tr><td style="text-align:center">Java虚拟机</td><td style="text-align:center">Java Hotpot ClientVM, Java Hotpot Server VM</td></tr></tbody></table><h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>JRE除了完全包括Java SE API, 还包括<strong>程序发布相关组件</strong>:  </p><p>Deployment, Java WEb Start, Java Plug-in</p><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>JDK除了完全包括JRE, 还包括:  </p><ol><li><p><strong>Java语言</strong>(Java Language)</p></li><li><p><strong>工具及工具API</strong>(java, javac, javadoc, apt, jar, javap, JPDA, JConsole, Java VisualVM, Security, Int`l, RMI, IDL, Deploy, Monitoring, Troubleshoot, Scripting, JVM TI)</p></li></ol><h2 id="Java技术平台"><a href="#Java技术平台" class="headerlink" title="Java技术平台"></a>Java技术平台</h2><p>Java技术关注的重点业务领域来划分，Java技术体系可分为四个平台:</p><ol><li><p>Java Card: 支持一些Java小程序(Applets) 运行在小内存设备(如智能卡)上的平台。  </p></li><li><p>Java ME(Micro Edition): 支持Java程序运行在移动终端(手机、PDA)上的平台，对Java API有所精简, 并加入了针对移动终端的支持，这个版本以前称为J2ME。  </p></li><li><p>Java SE(Standard Edition): 支持面向桌面级应用(如Windows下的应用程序)的Java平台，提供了完整的Java核心API，这个版本以前称为J2SE。  </p></li><li><p>Java EE(Enterprise Edition): 支持使用多层架构的企业应用(如ERP、CRM应用)的Java平台，除了提供Java SE API外，还对其做了大量的扩充并提供了相关的部署支持，这个版本以前称为J2EE。  </p></li></ol>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell中的awk</title>
      <link href="/2019/08/08/shell-11/"/>
      <url>/2019/08/08/shell-11/</url>
      <content type="html"><![CDATA[<h2 id="awk工作模式简介"><a href="#awk工作模式简介" class="headerlink" title="awk工作模式简介"></a>awk工作模式简介</h2><p>awk是一个文本处理工具，主要用于处理数据并生成结果报告  </p><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;' file_name</span><br><span class="line">standard output | awk 'BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;'</span><br></pre></td></tr></table></figure><h3 id="语法格式解释"><a href="#语法格式解释" class="headerlink" title="语法格式解释"></a>语法格式解释</h3><table><thead><tr><th>语法格式</th><th>解释</th></tr></thead><tbody><tr><td>BEGIN{}</td><td>正式处理数据之前执行</td></tr><tr><td>pattern</td><td>匹配模式</td></tr><tr><td>{commands}</td><td>处理命令，可能多行</td></tr><tr><td>END{}</td><td>处理完所有匹配数据后执行</td></tr></tbody></table><h2 id="awk中的内置变量"><a href="#awk中的内置变量" class="headerlink" title="awk中的内置变量"></a>awk中的内置变量</h2><table><thead><tr><th>内置变量</th><th>含义</th></tr></thead><tbody><tr><td>$0</td><td>整行内容</td></tr><tr><td>$1-$n</td><td>当前行的第1-n个字段</td></tr><tr><td>NF</td><td>当前行的字段个数，也就是有多少列</td></tr><tr><td>NR</td><td>当前行的行号，从1开始计数</td></tr><tr><td>FNR</td><td>多文件处理时，每个文件行号单独计数，都是从0开始</td></tr><tr><td>FS</td><td>输入字段分隔符。不指定默认以空格或tab分割</td></tr><tr><td>RS</td><td>输入行分隔符。默认回车换行</td></tr><tr><td>OFS</td><td>输出字段分隔符。默认为空格</td></tr><tr><td>ORS</td><td>输出行分隔符，默认为回车换行</td></tr><tr><td>FILENAME</td><td>当前输入的文件名字</td></tr><tr><td>ARGC</td><td>命令行参数个数</td></tr><tr><td>ARGV</td><td>命令行参数数组</td></tr></tbody></table><h2 id="printf的格式说明符"><a href="#printf的格式说明符" class="headerlink" title="printf的格式说明符"></a>printf的格式说明符</h2><table><thead><tr><th>格式符</th><th>含义</th></tr></thead><tbody><tr><td>%s</td><td>打印字符串</td></tr><tr><td>%d</td><td>打印十进制数字</td></tr><tr><td>%f</td><td>打印浮点数</td></tr><tr><td>%x</td><td>打印十六进制数</td></tr><tr><td>%o</td><td>打印八进制数</td></tr><tr><td>%e</td><td>打印数学的科学计数法形式</td></tr><tr><td>%c</td><td>打印单个字符的ASCII码</td></tr><tr><td>-</td><td>左对齐</td></tr><tr><td>+</td><td>右对齐</td></tr><tr><td>#</td><td>显示8进制在前面加0，显示16进制在前面加0x</td></tr></tbody></table><h2 id="关系运算匹配"><a href="#关系运算匹配" class="headerlink" title="关系运算匹配"></a>关系运算匹配</h2><table><thead><tr><th>关系运算符</th><th>含义</th></tr></thead><tbody><tr><td>~</td><td>匹配正则表达式</td></tr><tr><td>!~</td><td>不匹配正则表达式</td></tr></tbody></table><h2 id="字符串函数对照表"><a href="#字符串函数对照表" class="headerlink" title="字符串函数对照表"></a>字符串函数对照表</h2><table><thead><tr><th>函数名</th><th>解释</th><th>函数返回值</th></tr></thead><tbody><tr><td>length(str)</td><td>计算字符串长度</td><td>整数长度值</td></tr><tr><td>index(str1, str2)</td><td>在str1中查找str2的位置</td><td>返回值为位置索引，从1计数</td></tr><tr><td>tolower(str)</td><td>转换为小写</td><td>转换后的小写字符串</td></tr><tr><td>toupper(str)</td><td>转换为大写</td><td>转换后的大写字符串</td></tr><tr><td>substr(str,m,n)</td><td>从str的m个字符开始,截取n位</td><td>截取后的子串</td></tr><tr><td>split(str, arr, fs)</td><td>按fs切割字符串，结果保存arr</td><td>切割后的子串的个数</td></tr><tr><td>match(str, RE)</td><td>在str中按照RE查找, 返回位置</td><td>返回索引位置</td></tr><tr><td>sub(RE, RepStr, str)</td><td>在str中搜索符合RE的字串,将其替换为RepStr;只替换第一个</td><td>替换的个数</td></tr><tr><td>gsub(RE, RepStr, str)</td><td>在str中搜索符合RE的字串，将其替换为RepStr;替换所有</td><td>替换的个数</td></tr></tbody></table><h2 id="awk其他选项"><a href="#awk其他选项" class="headerlink" title="awk其他选项"></a>awk其他选项</h2><table><thead><tr><th>选项</th><th>解释</th></tr></thead><tbody><tr><td>-v</td><td>参数传递</td></tr><tr><td>-f</td><td>指定脚本文件</td></tr><tr><td>-F</td><td>指定分隔符</td></tr><tr><td>-V</td><td>查看awk的版本号</td></tr></tbody></table><h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><p>假如有文本test.txt如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root     pts/1   192.168.1.100  Tue Feb 10 11:21   still logged in</span><br><span class="line">root     pts/1   192.168.1.100  Tue Feb 10 00:46 - 02:28  (01:41)</span><br><span class="line">root     pts/1   192.168.1.100  Mon Feb  9 11:41 - 18:30  (06:48)</span><br><span class="line">dmtsai   pts/1   192.168.1.100  Mon Feb  9 11:41 - 11:41  (00:00)</span><br><span class="line">root     tty1                   Fri Sep  5 14:09 - 14:10  (00:01)</span><br></pre></td></tr></table></figure><p>展示第一列:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk '&#123;print $1&#125;'</span><br></pre></td></tr></table></figure><p>显示/etc/passwd的账户(以:分隔)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | awk -F ':' '&#123;print $1&#125;'</span><br></pre></td></tr></table></figure><p>如果显示账户和账户对应的shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd | awk -F ':' '&#123;print $1"\t"$7&#125;'</span><br></pre></td></tr></table></figure><p>显示列头列尾</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd |awk  -F ':'  'BEGIN &#123;print "name,shell"&#125;  &#123;print $1","$7&#125; END &#123;print "blue,/bin/nosh"&#125;'</span><br></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name,shell</span><br><span class="line">root,/bin/bash</span><br><span class="line">daemon,/bin/sh</span><br><span class="line">bin,/bin/sh</span><br><span class="line">sys,/bin/sh</span><br><span class="line">....</span><br><span class="line">blue,/bin/nosh</span><br></pre></td></tr></table></figure><p>打印行号和列数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd |awk  -F ':'  'BEGIN &#123;count=0;print "name\t\tshell"&#125;  &#123;count=count+1;print count":"$1"\t\t"$7&#125; END &#123;print "count=", count&#125;'</span><br></pre></td></tr></table></figure><p>打印nologin的用户展示行号和列数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd |awk  -F ':'  'BEGIN &#123;count=0;print "name\t\tshell"&#125; /nologin/ &#123;count=count+1;print count":"$1"\t\t"$7&#125; END &#123;print "count=", count&#125;'</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell中的sed</title>
      <link href="/2019/08/08/shell-10/"/>
      <url>/2019/08/08/shell-10/</url>
      <content type="html"><![CDATA[<h2 id="sed简介"><a href="#sed简介" class="headerlink" title="sed简介"></a>sed简介</h2><p>sed(Stream Editor), 流编辑器。对标准输出或文件逐行进行处理。  </p><h3 id="sed的语法格式"><a href="#sed的语法格式" class="headerlink" title="sed的语法格式"></a>sed的语法格式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stdout|sed[option] "pattern command"</span><br><span class="line">sed [option] "pattern command" file</span><br></pre></td></tr></table></figure><h2 id="sed参数列表"><a href="#sed参数列表" class="headerlink" title="sed参数列表"></a>sed参数列表</h2><table><thead><tr><th>选项</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>quiet/silent</td><td>经过sed处理过的行才会被列出来</td></tr><tr><td>-e</td><td>script</td><td>直接在命令行进行sed编辑，默认选项</td></tr><tr><td>-f</td><td>script-file</td><td>直接运行script-file内的sed命令</td></tr><tr><td>-r</td><td>redxp-extended</td><td>支持扩展正则表达式</td></tr><tr><td>-i</td><td></td><td>直接编辑源文件</td></tr></tbody></table><h2 id="sed中的编辑命令"><a href="#sed中的编辑命令" class="headerlink" title="sed中的编辑命令"></a>sed中的编辑命令</h2><table><thead><tr><th>类别</th><th>编辑命令</th><th>含义</th></tr></thead><tbody><tr><td>查询</td><td>p</td><td>打印</td></tr><tr><td>增加</td><td>a</td><td>行后追加</td></tr><tr><td>增加</td><td>i</td><td>行前追加</td></tr><tr><td>增加</td><td>r</td><td>将文件内容追加到匹配行后面</td></tr><tr><td>增加</td><td>w</td><td>匹配行写入外部文件</td></tr><tr><td>删除</td><td>d</td><td>删除</td></tr><tr><td>修改</td><td>s/old/new</td><td>将行内第一个old替换为new</td></tr><tr><td>修改</td><td>s/old/new/g</td><td>将行内全部的old替换为new</td></tr><tr><td>修改</td><td>s/old/new/2g</td><td>将行内前2个old替换为new</td></tr><tr><td>修改</td><td>s/old/new/ig</td><td>将行内old全部替换为new， 忽略大小写</td></tr></tbody></table><h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><h3 id="替换-c"><a href="#替换-c" class="headerlink" title="替换(c)"></a>替换(c)</h3><h4 id="将第一行替换为shell"><a href="#将第一行替换为shell" class="headerlink" title="将第一行替换为shell"></a>将第一行替换为shell</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed '1c shell' sed.txt</span><br></pre></td></tr></table></figure><h4 id="将第1-3行替换为java"><a href="#将第1-3行替换为java" class="headerlink" title="将第1-3行替换为java"></a>将第1-3行替换为java</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed '1,3c java' sed.txt</span><br></pre></td></tr></table></figure><h4 id="嵌入正则表达式，-用-包住。替换所有包含win的行变为python"><a href="#嵌入正则表达式，-用-包住。替换所有包含win的行变为python" class="headerlink" title="嵌入正则表达式， 用 //包住。替换所有包含win的行变为python"></a>嵌入正则表达式， 用 //包住。替换所有包含win的行变为python</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed '/win/c python' sed.txt</span><br></pre></td></tr></table></figure><h3 id="删除-d"><a href="#删除-d" class="headerlink" title="删除(d)"></a>删除(d)</h3><h4 id="删除第二行"><a href="#删除第二行" class="headerlink" title="删除第二行"></a>删除第二行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed '2d' sed.txt</span><br></pre></td></tr></table></figure><h4 id="删除最后一行-表示最后一行"><a href="#删除最后一行-表示最后一行" class="headerlink" title="删除最后一行($表示最后一行)"></a>删除最后一行($表示最后一行)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed '$d' sed.txt</span><br></pre></td></tr></table></figure><h4 id="删除1-3行"><a href="#删除1-3行" class="headerlink" title="删除1-3行"></a>删除1-3行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed '1, 3d' sed.txt</span><br></pre></td></tr></table></figure><h3 id="插入-i"><a href="#插入-i" class="headerlink" title="插入(i)"></a>插入(i)</h3><h4 id="所有行之前插入"><a href="#所有行之前插入" class="headerlink" title="所有行之前插入#\"></a>所有行之前插入#\</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed 'i##' sed.txt</span><br></pre></td></tr></table></figure><h4 id="1-3行之前插入0000"><a href="#1-3行之前插入0000" class="headerlink" title="1-3行之前插入0000"></a>1-3行之前插入0000</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed '1,3i0000' sed.txt</span><br></pre></td></tr></table></figure><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><h4 id="替换文本中的每一行的第一个0-为-9"><a href="#替换文本中的每一行的第一个0-为-9" class="headerlink" title="替换文本中的每一行的第一个0 为 9"></a>替换文本中的每一行的第一个0 为 9</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed 's/0/9/' sed.txt</span><br></pre></td></tr></table></figure><h4 id="替换文本中的所有0-为-9"><a href="#替换文本中的所有0-为-9" class="headerlink" title="替换文本中的所有0 为 9"></a>替换文本中的所有0 为 9</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed 's/0/9/g' sed.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell中的grep</title>
      <link href="/2019/08/08/shell-9/"/>
      <url>/2019/08/08/shell-9/</url>
      <content type="html"><![CDATA[<h2 id="grep-和-egrep"><a href="#grep-和-egrep" class="headerlink" title="grep 和 egrep"></a>grep 和 egrep</h2><p>egrep 和 grep -E 等价， 支持扩展正则表达式  </p><h3 id="基本正则和扩展正则"><a href="#基本正则和扩展正则" class="headerlink" title="基本正则和扩展正则"></a>基本正则和扩展正则</h3><p>扩展正则表达式与基础正则表达式的唯一区别在于： ? + () {} 这几个字符  </p><p>基础正则表达式中，如果需要? + () {} 表达特殊含义， 需要将他们转义  </p><p>扩展正则表达式中，如果需要? + () {} 不表达特殊含义，需要将他们转义</p><h2 id="grep-语法格式"><a href="#grep-语法格式" class="headerlink" title="grep 语法格式"></a>grep 语法格式</h2><ul><li><p>第一种形式: grep[option][pattern][file1,file2…]</p></li><li><p>第二种形式: command | grep [option][pattern]</p></li></ul><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-v</td><td>不显示匹配行信息</td></tr><tr><td>-i</td><td>搜索时忽略大小写</td></tr><tr><td>-n</td><td>显示行号</td></tr><tr><td>-r</td><td>递归搜索</td></tr><tr><td>-E</td><td>支持扩展正则表达式</td></tr><tr><td>-F</td><td>不按正则表达式匹配，按照字符串字面意思匹配</td></tr><tr><td>-A</td><td>查看匹配行及匹配行后几行的信息</td></tr><tr><td>-B</td><td>查看匹配行及匹配行前几行的信息</td></tr></tbody></table>]]></content>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell中的find</title>
      <link href="/2019/08/08/shell-8/"/>
      <url>/2019/08/08/shell-8/</url>
      <content type="html"><![CDATA[<h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [路径] [选项] [操作]</span><br></pre></td></tr></table></figure><h2 id="选项参数对照表"><a href="#选项参数对照表" class="headerlink" title="选项参数对照表"></a>选项参数对照表</h2><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-name</td><td>根据文件名查找</td></tr><tr><td>-iname</td><td>根据文件名查找(忽略大小写)</td></tr><tr><td>-perm</td><td>根据文件权限查找</td></tr><tr><td>-prune</td><td>该选项可以排除某些查找目录</td></tr><tr><td>-user</td><td>根据文件属主查找</td></tr><tr><td>-group</td><td>根据文件属组查找</td></tr><tr><td>-mtime -n \</td><td>+n</td><td>根据文件更改时间查找</td></tr><tr><td>-nogroup</td><td>查找无有效属组的文件</td></tr><tr><td>-nouser</td><td>查找无有效属主的文件</td></tr><tr><td>-newer file1 ! file2</td><td>查找更改时间比file1新但比file2旧的文件</td></tr><tr><td>-type</td><td>按文件类型查找</td></tr><tr><td>-size -n +n</td><td>按文件大小查找</td></tr><tr><td>-mindepth n</td><td>从n级子目录开始搜索</td></tr><tr><td>-maxdepth n</td><td>最多搜索到n级子目录</td></tr></tbody></table><h2 id="type"><a href="#type" class="headerlink" title="-type"></a>-type</h2><table><thead><tr><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>f</td><td>文件</td></tr><tr><td>d</td><td>目录</td></tr><tr><td>c</td><td>字符设备文件</td></tr><tr><td>b</td><td>块设备文件</td></tr><tr><td>l</td><td>链接文件</td></tr><tr><td>p</td><td>管道文件</td></tr></tbody></table><h2 id="size"><a href="#size" class="headerlink" title="-size"></a>-size</h2><table><thead><tr><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>+n</td><td>大小大于n</td></tr><tr><td>-n</td><td>大小小于n</td></tr></tbody></table><h2 id="mtime"><a href="#mtime" class="headerlink" title="-mtime"></a>-mtime</h2><table><thead><tr><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>-time</td><td>time天以内的文件</td></tr><tr><td>+time</td><td>time天以外的文件</td></tr></tbody></table><h2 id="find-locate-whereis-which的区别"><a href="#find-locate-whereis-which的区别" class="headerlink" title="find locate whereis which的区别"></a>find locate whereis which的区别</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>在磁盘中查找对应文件</p><h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><h4 id="文件查找命令，所属软件包mlocate"><a href="#文件查找命令，所属软件包mlocate" class="headerlink" title="文件查找命令，所属软件包mlocate"></a>文件查找命令，所属软件包mlocate</h4><h4 id="不同于find命令再整块磁盘中搜索，locate命令在数据库文件中查找"><a href="#不同于find命令再整块磁盘中搜索，locate命令在数据库文件中查找" class="headerlink" title="不同于find命令再整块磁盘中搜索，locate命令在数据库文件中查找"></a>不同于find命令再整块磁盘中搜索，locate命令在数据库文件中查找</h4><ol><li>数据库文件一般每日更新，也可通过命令(updatedb)即时更新。  </li><li>用户更新/var/lib/mlocate/mlocate.db  </li><li>所使用配置文件/etc/updatedb.conf  </li><li>该任务在后台cron计划任务中定期执行</li></ol><h4 id="find是默认全部匹配，locate则是默认部分匹配"><a href="#find是默认全部匹配，locate则是默认部分匹配" class="headerlink" title="find是默认全部匹配，locate则是默认部分匹配"></a>find是默认全部匹配，locate则是默认部分匹配</h4><h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><p>只能查询二进制文件，帮助文档文件，源代码文件。</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-b</td><td>只返回二进制文件</td></tr><tr><td>-m</td><td>只返回帮助文档文件</td></tr><tr><td>-s</td><td>只返回源代码文件</td></tr></tbody></table><h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><p>仅查找二进制程序文件</p>]]></content>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell中的函数</title>
      <link href="/2019/08/08/shell-7/"/>
      <url>/2019/08/08/shell-7/</url>
      <content type="html"><![CDATA[<h2 id="函数简介"><a href="#函数简介" class="headerlink" title="函数简介"></a>函数简介</h2><p>shell中函数的定义格式如下:  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[function] funname [()]</span><br><span class="line">&#123;</span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [return int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明:  </p><ol><li><p>可以带function fun() 定义，也可以直接fun()定义，不带任何参数。  </p></li><li><p>参数返回，可以显示加: return 返回， 如果不加， 将以最后一条命令运行结果，作为返回值。  return后跟数值n(0-255)  </p></li></ol><h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">demoFun() &#123;</span><br><span class="line">    echo "Hello World!"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demoFun</span><br></pre></td></tr></table></figure><p>执行结果:  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell中的expr</title>
      <link href="/2019/08/08/shell-6/"/>
      <url>/2019/08/08/shell-6/</url>
      <content type="html"><![CDATA[<h2 id="expr简介"><a href="#expr简介" class="headerlink" title="expr简介"></a>expr简介</h2><p>expr命令是一个手工命令行计数器，用于在UNIX/LINUX下求表达式变量的值，一般用于整数值，也可用于字符串。  </p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr 表达式</span><br></pre></td></tr></table></figure><p>表达式说明:</p><ul><li><p>用空格隔开每个项</p></li><li><p>用/(反斜杠)放在shell特定的字符前面</p></li><li><p>对包含空格和其他特殊字符的字符串要用引号括起来</p></li></ul><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><h4 id="计算字符串长度"><a href="#计算字符串长度" class="headerlink" title="计算字符串长度"></a>计算字符串长度</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr length "this is a test"</span><br></pre></td></tr></table></figure><h4 id="抓取字串"><a href="#抓取字串" class="headerlink" title="抓取字串"></a>抓取字串</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr substr "this is a test" 3 5</span><br></pre></td></tr></table></figure><h4 id="抓取第一个字符串出现的位置"><a href="#抓取第一个字符串出现的位置" class="headerlink" title="抓取第一个字符串出现的位置"></a>抓取第一个字符串出现的位置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr index "sarasara" a</span><br></pre></td></tr></table></figure><h4 id="整数数学运算"><a href="#整数数学运算" class="headerlink" title="整数数学运算"></a>整数数学运算</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr 14 % 9</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell中的有类型变量</title>
      <link href="/2019/08/08/shell-5/"/>
      <url>/2019/08/08/shell-5/</url>
      <content type="html"><![CDATA[<h2 id="有类型变量"><a href="#有类型变量" class="headerlink" title="有类型变量"></a>有类型变量</h2><p>shell本身是一种弱类型语言，但是可以通过预先设置类型对变量固定类型</p><h2 id="declare-和-typeset-命令"><a href="#declare-和-typeset-命令" class="headerlink" title="declare 和 typeset 命令"></a>declare 和 typeset 命令</h2><p>shell中使用declare和typeset为变量固定类型，他们是完全等价的，大概格式为:  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare -命令 变量</span><br></pre></td></tr></table></figure><h2 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h2><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-r</td><td>将参数变为只读</td></tr><tr><td>-i</td><td>将参数设为整数</td></tr><tr><td>-a</td><td>将变量定义为数组</td></tr><tr><td>-f</td><td>显示此脚本之前定义过的所有函数及内容</td></tr><tr><td>-F</td><td>仅显示此脚本之前定义过的函数</td></tr><tr><td>-x</td><td>将脚本定义为环境变量</td></tr></tbody></table><h2 id="取消声明的变量"><a href="#取消声明的变量" class="headerlink" title="取消声明的变量"></a>取消声明的变量</h2><p>如果要取消一个变量的声明，可以将 - 替换成 + :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare +命令 变量</span><br></pre></td></tr></table></figure><h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">static=1024</span><br><span class="line">declare -r static</span><br><span class="line">static=1024</span><br></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo5.sh: line 4: static: readonly variable</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell中的数组</title>
      <link href="/2019/08/08/shell-4/"/>
      <url>/2019/08/08/shell-4/</url>
      <content type="html"><![CDATA[<h2 id="shell中的数组"><a href="#shell中的数组" class="headerlink" title="shell中的数组"></a>shell中的数组</h2><p>数组中可以存放多个值。Bash Shell只支持一维数组(不支持多维数组)，初始化时不需要定义数组大小。<br>数组元素的下标由0开始。  </p><h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><p>Shell数组用括号来表示，元素用空格符号分割开，语法格式如下:  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value1 ... valuen)</span><br></pre></td></tr></table></figure><p>也可以使用下标来定义数组:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[2]=value2</span><br></pre></td></tr></table></figure><h2 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h2><p>读取数组的一般格式是:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>&#123;array_name[index]&#125;</span><br></pre></td></tr></table></figure><h3 id="读取数组中的所有元素"><a href="#读取数组中的所有元素" class="headerlink" title="读取数组中的所有元素"></a>读取数组中的所有元素</h3><p>使用@或*可以获取数组中的所有元素，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>&#123;array_name[@]&#125;</span><br><span class="line"><span class="meta">$</span>&#123;array_name[*]&#125;</span><br></pre></td></tr></table></figure><h2 id="读取数组的长度"><a href="#读取数组的长度" class="headerlink" title="读取数组的长度"></a>读取数组的长度</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>&#123;#array_name[@]&#125;</span><br><span class="line"><span class="meta">$</span>&#123;#array_name[*]&#125;</span><br></pre></td></tr></table></figure><h2 id="删除数组"><a href="#删除数组" class="headerlink" title="删除数组"></a>删除数组</h2><p>在Shell中，使用unset关键字来删除数组元素，格式如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset array_name[index]</span><br></pre></td></tr></table></figure><p>如果不写下标，则会删除整个数组:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset array_name</span><br></pre></td></tr></table></figure><h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">array=(A B C D)</span><br><span class="line">echo $&#123;array&#125;</span><br><span class="line">echo $&#123;array[0]&#125;</span><br><span class="line">echo "the first element of array is $&#123;array[0]&#125;"</span><br><span class="line">echo $&#123;array[@]&#125;</span><br><span class="line">echo $&#123;array[*]&#125;</span><br><span class="line">echo $&#123;#array[@]&#125;</span><br><span class="line">unset array[2]</span><br><span class="line">echo $&#123;array[@]&#125;</span><br><span class="line">echo $&#123;array[2]&#125;</span><br><span class="line">echo $&#123;#array[@]&#125;</span><br><span class="line"><span class="meta">#</span> 注意array[2]被移除后，array的长度减少为3，但3的位置仍然空着，导致循环不会输出D</span><br><span class="line">for ((i=0;i&lt;$&#123;#array[@]&#125;;i++));</span><br><span class="line">do</span><br><span class="line">echo $&#123;array[i]&#125;;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">A</span><br><span class="line">the first element of array is A</span><br><span class="line">A B C D</span><br><span class="line">A B C D</span><br><span class="line">4</span><br><span class="line">A B D</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell中的循环</title>
      <link href="/2019/08/08/shell-3/"/>
      <url>/2019/08/08/shell-3/</url>
      <content type="html"><![CDATA[<h2 id="for循环的写法"><a href="#for循环的写法" class="headerlink" title="for循环的写法"></a>for循环的写法</h2><h3 id="数字型"><a href="#数字型" class="headerlink" title="数字型"></a>数字型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for ((i=1;i&lt;5;i++));</span><br><span class="line">do</span><br><span class="line">echo $i;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in $(seq 1 5)</span><br><span class="line">do</span><br><span class="line">echo $i;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in &#123;1..10&#125;</span><br><span class="line">do</span><br><span class="line">echo $i;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list="rootfs usr data data2"</span><br><span class="line">for i in $list;</span><br><span class="line">do</span><br><span class="line">echo $i is appoint;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in f1 f2 f3;</span><br><span class="line">do</span><br><span class="line">echo $i is appoint;</span><br><span class="line">done;</span><br></pre></td></tr></table></figure><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int=1</span><br><span class="line"><span class="meta">while(($</span>int &lt;=5))</span><br><span class="line">do</span><br><span class="line">echo $int</span><br><span class="line">let "int++"</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><p>猜数字游戏:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span>用脚本演示使用结束标记控制while循环实现猜1~10内的数</span><br><span class="line">echo "Please input the num (1~~10): "</span><br><span class="line">read num</span><br><span class="line">while [[ $num != 4 ]]</span><br><span class="line">do</span><br><span class="line">if [ $num -lt 4 ];then</span><br><span class="line">  echo "Too small,Try again.."</span><br><span class="line">  read num</span><br><span class="line">elif [ $num -gt 4 ];then</span><br><span class="line">  echo "Too big,Try again.."</span><br><span class="line">  read num</span><br><span class="line">else</span><br><span class="line">  exit 0</span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line">echo "Yes,you are right !!"</span><br></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Please input the num (1~~10):  </span><br><span class="line">3</span><br><span class="line">Too small,Try again..</span><br><span class="line">6</span><br><span class="line">Too big,Try again..</span><br><span class="line">4</span><br><span class="line">Yes,you are right !!</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell中的字符串</title>
      <link href="/2019/08/07/shell-2/"/>
      <url>/2019/08/07/shell-2/</url>
      <content type="html"><![CDATA[<h2 id="字符串的声明"><a href="#字符串的声明" class="headerlink" title="字符串的声明"></a>字符串的声明</h2><p>shell中的字符串可以用单引号，也可以用双引号，也可以不用引号</p><h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str='this is a string'</span><br></pre></td></tr></table></figure><p>单引号字符串的限制:</p><ul><li><p>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的  </p></li><li><p>单引号字串中不能出现单独一个的单引号(对单引号使用转义符后也不行)，但可成对出现，作为字符串拼接使用。  </p></li></ul><h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str="this is a string"</span><br></pre></td></tr></table></figure><p>双引号的优点:  </p><ul><li><p>双引号里可以有变量</p></li><li><p>双引号里可以出现转义字符</p></li></ul><h2 id="获取字符串的长度"><a href="#获取字符串的长度" class="headerlink" title="获取字符串的长度"></a>获取字符串的长度</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string="abcd"</span><br><span class="line">echo $&#123;#string&#125;</span><br></pre></td></tr></table></figure><h2 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h2><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>${string:position}</td><td>从position位置开始</td></tr><tr><td>${string:position:length}</td><td>从position位置开始,匹配长度为length</td></tr><tr><td>${string:-position}</td><td>从右边开始匹配</td></tr><tr><td>${string:(position)}</td><td>从左边开始匹配</td></tr><tr><td>expr substr $string $position $length</td><td>从position位置开始,匹配长度为length</td></tr></tbody></table><p>以下脚本将输出string 从第12位开始，5位长度的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string="Stopping by Woods on a Snowy Evening, Whose woods these are I think I know."</span><br><span class="line">echo %&#123;string:12:5&#125;</span><br></pre></td></tr></table></figure><h2 id="查找字符串"><a href="#查找字符串" class="headerlink" title="查找字符串"></a>查找字符串</h2><p>查找字符i或o的位置(哪个字母先出现就计算哪个):  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string="Stopping by Woods on a Snowy Evening, Whose woods these are I think I know."</span><br><span class="line">echo `expr index "$string" io`</span><br></pre></td></tr></table></figure><p>注意: 以上脚本 `是反引号</p><h2 id="字符串的替换"><a href="#字符串的替换" class="headerlink" title="字符串的替换"></a>字符串的替换</h2><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>${变量名#匹配规则}</td><td>从变量开头进行规则匹配,将符合最短的数据删除</td></tr><tr><td>${变量名##匹配规则</td><td>从变量开头进行规则匹配,将符合最长的数据删除</td></tr><tr><td>${变量名%匹配规则}</td><td>从变量尾部进行规则匹配,将符合最短的数据删除</td></tr><tr><td>${变量名%%匹配规则}</td><td>从变量尾部进行规则匹配，将符合最长的数据删除</td></tr><tr><td>${变量名/旧字符串/新字符串}</td><td>变量内容符合旧字符串，则第一个旧字符串会被新字符串取代</td></tr><tr><td>${变量名//旧字符串/新字符串}</td><td>变量内容符合旧字符串，则全部的旧字符串会被新字符串取代</td></tr></tbody></table><h2 id="字符串的测试"><a href="#字符串的测试" class="headerlink" title="字符串的测试"></a>字符串的测试</h2><h2 id="变量测试"><a href="#变量测试" class="headerlink" title="变量测试"></a>变量测试</h2><p>变量测试表达式可以在变量为空或没有配置时返回特定的表达式，具体操作如下:</p><table><thead><tr><th>变量配置方式</th><th>str没有配置</th><th>Str为空字符串</th><th>Str已配置且非空</th></tr></thead><tbody><tr><td>var=${str-expr}</td><td>var=expr</td><td>var=</td><td>var=$str</td></tr><tr><td>var=${str=expr}</td><td>var=expr</td><td>var=</td><td>var=$str</td></tr><tr><td>var=${str:-expr}</td><td>var=expr</td><td>var=expr</td><td>var=$str</td></tr><tr><td>var=${str:=expr</td><td>var=expr</td><td>var=expr</td><td>var=$str</td></tr><tr><td>var=${str+expr}</td><td>var=</td><td>var=expr</td><td>var=expr</td></tr><tr><td>var=${str:+expr}</td><td>var=</td><td>var=</td><td>var=expr</td></tr></tbody></table><h2 id="表达式的命令替换"><a href="#表达式的命令替换" class="headerlink" title="表达式的命令替换"></a>表达式的命令替换</h2><p>表达式如 <strong>expr</strong> 会将结果输出到控制台，如果希望作为值，需要使用命令替换语句。语法为:  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`expr`</span><br><span class="line"><span class="meta">$</span>(expr)</span><br></pre></td></tr></table></figure><h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> !bin/bash</span><br><span class="line"><span class="meta">#</span> 单引号创建字符串</span><br><span class="line">str='Two roads diverged in a yellow wood,'</span><br><span class="line">echo $str</span><br><span class="line"><span class="meta">#</span> 双引号创建字符串</span><br><span class="line">str="And sorry I could not travel both"</span><br><span class="line">echo $str</span><br><span class="line"><span class="meta">#</span> 双引号拼接字符串</span><br><span class="line">var_and="And"</span><br><span class="line">str1=$var_and" sorry I could not travel both"</span><br><span class="line">str2="$var_and be one traveler, long I stood"</span><br><span class="line">echo $str1 $str2</span><br><span class="line"><span class="meta">#</span> 单引号拼接字符串</span><br><span class="line">str1=$var_and' looked down one as far as I could'</span><br><span class="line">str2='$var_and To where it bent in the undergrowth'</span><br><span class="line">echo $str1 $str2</span><br><span class="line"><span class="meta">#</span> 获取字符串的长度</span><br><span class="line">echo $&#123;#str1&#125;</span><br><span class="line"><span class="meta">#</span> 提取子字符串</span><br><span class="line">echo $&#123;str1:11:4&#125;</span><br><span class="line"><span class="meta">#</span> 查找子字符串</span><br><span class="line">echo `expr index "$str1" Aok`</span><br><span class="line"><span class="meta">#</span> 字符串的替换</span><br><span class="line">str='Two roads diverged in a yellow wood,'</span><br><span class="line">echo $&#123;str#*o&#125;</span><br><span class="line">echo $&#123;str##*o&#125;</span><br><span class="line">echo $&#123;str%o*&#125;</span><br><span class="line">echo $&#123;str%%o*&#125;</span><br><span class="line">echo $&#123;str/w/f&#125;</span><br><span class="line">echo $&#123;str//w/f&#125;</span><br><span class="line"><span class="meta">#</span> 变量的测试</span><br><span class="line">str_empty=""</span><br><span class="line">echo '-'</span><br><span class="line">echo $&#123;str_null-null&#125;</span><br><span class="line">echo $&#123;str_empty-null&#125;</span><br><span class="line">echo $&#123;str-null&#125;</span><br><span class="line">echo '='</span><br><span class="line">echo $&#123;str_null=null&#125;</span><br><span class="line">echo $&#123;str_empty=null&#125;</span><br><span class="line">echo $&#123;str=null&#125;</span><br><span class="line">echo ':-'</span><br><span class="line">echo $&#123;str_null:-null&#125;</span><br><span class="line">echo $&#123;str_empty:-null&#125;</span><br><span class="line">echo $&#123;str:-null&#125;</span><br><span class="line">echo ':='</span><br><span class="line">echo $&#123;str_null:=null&#125;</span><br><span class="line">echo $&#123;str_empty:=null&#125;</span><br><span class="line">echo $&#123;str:=null&#125;</span><br><span class="line">echo '+'</span><br><span class="line">echo $&#123;str_null+null&#125;</span><br><span class="line">echo $&#123;str_empty+null&#125;</span><br><span class="line">echo $&#123;str+null&#125;</span><br><span class="line">echo ':+'</span><br><span class="line">echo $&#123;str_null:+null&#125;</span><br><span class="line">echo $&#123;str_empty:+null&#125;</span><br><span class="line">echo $&#123;str:+null&#125;</span><br><span class="line"><span class="meta">#</span> 命令替换</span><br><span class="line">indexOfA=`expr index "$str1" A`</span><br><span class="line">indexOfo=$(expr index "$str1" o)</span><br><span class="line">echo $indexOfA</span><br><span class="line">echo $indexOfo</span><br></pre></td></tr></table></figure><p>测试结果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Two roads diverged in a yellow wood,</span><br><span class="line">And sorry I could not travel both</span><br><span class="line">And sorry I could not travel both And be one traveler, long I stood</span><br><span class="line">And looked down one as far as I could $var_and To where it bent in the undergrowth</span><br><span class="line">37</span><br><span class="line">down</span><br><span class="line">1</span><br><span class="line">roads diverged in a yellow wood,</span><br><span class="line">d,</span><br><span class="line">Two roads diverged in a yellow wo</span><br><span class="line">Tw</span><br><span class="line">Tfo roads diverged in a yellow wood,</span><br><span class="line">Tfo roads diverged in a yellof food,</span><br><span class="line">-</span><br><span class="line">null</span><br><span class="line"></span><br><span class="line">Two roads diverged in a yellow wood,</span><br><span class="line">=</span><br><span class="line">null</span><br><span class="line"></span><br><span class="line">Two roads diverged in a yellow wood,</span><br><span class="line">:-</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">Two roads diverged in a yellow wood,</span><br><span class="line">:=</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">Two roads diverged in a yellow wood,</span><br><span class="line">+</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">:+</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">1</span><br><span class="line">6</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>shell中的变量</title>
      <link href="/2019/08/07/shell-1/"/>
      <url>/2019/08/07/shell-1/</url>
      <content type="html"><![CDATA[<h2 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h2><h3 id="基本定义方式"><a href="#基本定义方式" class="headerlink" title="基本定义方式"></a>基本定义方式</h3><p>定义shell变量时，直接使用 <strong>变量名=变量值</strong> 的格式就可以了，如下:  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell_variable="some variable"</span><br></pre></td></tr></table></figure><p>注意： <strong>变量名和等号之间不能有空格</strong>  </p><h3 id="语句中赋值"><a href="#语句中赋值" class="headerlink" title="语句中赋值"></a>语句中赋值</h3><p>变量也可以直接在语句中赋值:  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for skill in Ada Coffe Action Java:</span><br></pre></td></tr></table></figure><h3 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h3><ul><li><p>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头  </p></li><li><p>中间不能有空格，可以使用下划线(_)</p></li><li><p>不能使用标点符号</p></li><li><p>不能使用bash里的关键字</p></li></ul><h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h2><p>使用一个定义过的变量，只要在变量名前加美元符号即可，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $shell_variable</span><br><span class="line">echo $&#123;shell_variable&#125;</span><br></pre></td></tr></table></figure><p>在使用括号时加上大括号主要是为了区分变量的边界，如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for skill in Ada Coffe Action Java;</span><br><span class="line">do</span><br><span class="line">  echo "I am goot at $&#123;skill&#125;Script"</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>在这里如果不加大括号，shell将把skillScript当做变量名执行</p><h2 id="设置只读变量"><a href="#设置只读变量" class="headerlink" title="设置只读变量"></a>设置只读变量</h2><p>使用readonly命令可以将变量定义为只读变量，只读变量的值不能被改变。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myUrl="http://google.com"</span><br><span class="line">readonly myUrl</span><br></pre></td></tr></table></figure><h2 id="变量的删除"><a href="#变量的删除" class="headerlink" title="变量的删除"></a>变量的删除</h2><p>使用unset命令可以删除变量。语法:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset shell_variable</span><br></pre></td></tr></table></figure><h2 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> !/bin/bash</span><br><span class="line"><span class="meta">#</span> 声明一个变量</span><br><span class="line">shell_variable="some variable"</span><br><span class="line"><span class="meta">#</span> 使用变量的两种方式</span><br><span class="line">echo $shell_variable</span><br><span class="line">echo $&#123;shell_variable&#125;</span><br><span class="line"><span class="meta">#</span> 用语句给变量赋值</span><br><span class="line">for skill in Ada Coffe Action Java;</span><br><span class="line">do</span><br><span class="line">  echo "I am goot at $&#123;skill&#125;Script"</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span> 只读变量</span><br><span class="line">myUrl="http://www.google.com"</span><br><span class="line">readonly myUrl</span><br><span class="line"><span class="meta">#</span> 删除变量</span><br><span class="line">unset shell_variable</span><br><span class="line">echo $shell_variable</span><br></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">some variable</span><br><span class="line">some variable</span><br><span class="line">I am goot at AdaScript</span><br><span class="line">I am goot at CoffeScript</span><br><span class="line">I am goot at ActionScript</span><br><span class="line">I am goot at JavaScript</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS切换阿里yum镜像源</title>
      <link href="/2019/08/06/linux-install-6-md/"/>
      <url>/2019/08/06/linux-install-6-md/</url>
      <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><p>CentOS6记得修改对应位置</p>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> linux环境配置 </tag>
            
            <tag> yum </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS安装nginx</title>
      <link href="/2019/08/06/linux-install-5-md/"/>
      <url>/2019/08/06/linux-install-5-md/</url>
      <content type="html"><![CDATA[<h3 id="依赖项和必要组件"><a href="#依赖项和必要组件" class="headerlink" title="依赖项和必要组件"></a>依赖项和必要组件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum install -y make cmake gcc gcc-c++  </span><br><span class="line"></span><br><span class="line">yum install -y pcre pcre-devel</span><br><span class="line"></span><br><span class="line">yum install -y zlib zlib-devel</span><br><span class="line"></span><br><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure><h3 id="下载安装nginx"><a href="#下载安装nginx" class="headerlink" title="下载安装nginx"></a>下载安装nginx</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.12.2.tar.gz</span><br></pre></td></tr></table></figure><p>其他版本访问: <a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a></p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf nginx-1.12.2.tar.gz &amp;&amp; cd nginx-1.12.2</span><br></pre></td></tr></table></figure><h3 id="编译配置"><a href="#编译配置" class="headerlink" title="编译配置"></a>编译配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="创建全局命令"><a href="#创建全局命令" class="headerlink" title="创建全局命令"></a>创建全局命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx</span><br></pre></td></tr></table></figure><h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure><h3 id="重新加载配置"><a href="#重新加载配置" class="headerlink" title="重新加载配置"></a>重新加载配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> linux环境配置 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS安装Tomcat</title>
      <link href="/2019/08/06/linux-install-4-md/"/>
      <url>/2019/08/06/linux-install-4-md/</url>
      <content type="html"><![CDATA[<h3 id="下载解压tomcat"><a href="#下载解压tomcat" class="headerlink" title="下载解压tomcat"></a>下载解压tomcat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-9/v9.0.5/bin/apache-tomcat-9.0.5.tar.gz</span><br><span class="line">tar xvf apache-tomcat-9.0.5.tar.gz -C /usr/local/</span><br><span class="line">mv /usr/local/apache-tomcat-9.0.5/ /usr/local/tomcat/</span><br></pre></td></tr></table></figure><h3 id="Tomcat-目录结构说明"><a href="#Tomcat-目录结构说明" class="headerlink" title="Tomcat 目录结构说明"></a>Tomcat 目录结构说明</h3><table><thead><tr><th style="text-align:center">目录</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">bin</td><td style="text-align:center">启动命令目录</td></tr><tr><td style="text-align:center">conf</td><td style="text-align:center">配置文件目录</td></tr><tr><td style="text-align:center">lib</td><td style="text-align:center">库文件目录</td></tr><tr><td style="text-align:center">logs</td><td style="text-align:center">日志文件目录</td></tr><tr><td style="text-align:center">temp</td><td style="text-align:center">临时缓存文件</td></tr><tr><td style="text-align:center">webapps</td><td style="text-align:center">web应用目录</td></tr><tr><td style="text-align:center">work</td><td style="text-align:center">工作缓存目录</td></tr></tbody></table><h3 id="修改Tomcat环境变量"><a href="#修改Tomcat环境变量" class="headerlink" title="修改Tomcat环境变量"></a>修改Tomcat环境变量</h3><p>环境变量可以写在全局脚本中，但多个tomcat会有冲突。建议在 <strong>startup.sh</strong> 和 <strong>shutdown.sh</strong> 脚本前面加入以下内容:  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export TOMCAT_HOME=/usr/local/tomcat</span><br><span class="line">export CATALINA_HOME=/usr/local/tomcat</span><br><span class="line">export CLASS_PATH=$JAVA_HOME/bin/lib:$JAVA_HOME/jre/lib:$JAVA_HOME/lib/tool.jar</span><br><span class="line">export PATH=$PATH:/usr/local/java/bin:/usr/local/tomcat/bin</span><br></pre></td></tr></table></figure><h3 id="启动Tomcat"><a href="#启动Tomcat" class="headerlink" title="启动Tomcat"></a>启动Tomcat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/tomcat/bin/startup.sh</span><br></pre></td></tr></table></figure><h3 id="查看进程状态"><a href="#查看进程状态" class="headerlink" title="查看进程状态"></a>查看进程状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep 'tomcat' | grep -v grep</span><br></pre></td></tr></table></figure><h3 id="关闭tomcat"><a href="#关闭tomcat" class="headerlink" title="关闭tomcat"></a>关闭tomcat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/tomcat/bin/shutdown.sh</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 pid</span><br></pre></td></tr></table></figure><p>pid是查看进程状态中查找出来的。</p>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> linux环境配置 </tag>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS7安装Java</title>
      <link href="/2019/08/06/linux-install-3-md/"/>
      <url>/2019/08/06/linux-install-3-md/</url>
      <content type="html"><![CDATA[<h3 id="下载Java"><a href="#下载Java" class="headerlink" title="下载Java"></a>下载Java</h3><ol><li><p>访问 <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a>  </p></li><li><p>点击 <strong>Downloads</strong> , <strong>Accept License Agreement</strong>  </p></li><li><p>选择 <strong>Linux x64</strong> , <strong>jdk-***-x64.tar.gz</strong>  </p></li><li><p>下载途中暂停, 复制下载链接。  </p></li></ol><h3 id="安装Java"><a href="#安装Java" class="headerlink" title="安装Java"></a>安装Java</h3><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">mkdir Java</span><br><span class="line">cd Java</span><br></pre></td></tr></table></figure><p>此时将刚才的链接 wget 到Linux服务器上。  </p><h4 id="解压文件"><a href="#解压文件" class="headerlink" title="解压文件"></a>解压文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf jdk-\*\*\*-x64.tar.gz</span><br></pre></td></tr></table></figure><h4 id="重命名目录"><a href="#重命名目录" class="headerlink" title="重命名目录"></a>重命名目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv jdk1.8.0_171 jdk1.8</span><br></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><h4 id="添加系统环境变量"><a href="#添加系统环境变量" class="headerlink" title="添加系统环境变量"></a>添加系统环境变量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/java/jdk1.8</span><br><span class="line">JRE_HOME=/usr/local/java/jdk1.8/jre</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br><span class="line">export JAVA_HOME JRE_HOME PATH CLASSPATH</span><br></pre></td></tr></table></figure><h4 id="读取新的配置"><a href="#读取新的配置" class="headerlink" title="读取新的配置"></a>读取新的配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h4 id="查看java版本"><a href="#查看java版本" class="headerlink" title="查看java版本"></a>查看java版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> linux </tag>
            
            <tag> linux环境配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>修改MySQL默认密码策略</title>
      <link href="/2019/08/06/linux-install-2-md/"/>
      <url>/2019/08/06/linux-install-2-md/</url>
      <content type="html"><![CDATA[<h3 id="修改密码策略"><a href="#修改密码策略" class="headerlink" title="修改密码策略"></a>修改密码策略</h3><h4 id="validate-password-policy"><a href="#validate-password-policy" class="headerlink" title="validate_password_policy"></a>validate_password_policy</h4><p>控制validate_password验证策略<br>0: LOW 1: MEDIUM 2:STRONG</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> validate_password_policy = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="validate-password-length"><a href="#validate-password-length" class="headerlink" title="validate_password_length"></a>validate_password_length</h4><p>密码长度的最小值(这个值最小是4)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> validate_password_length = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><h4 id="validate-password-number-count"><a href="#validate-password-number-count" class="headerlink" title="validate_password_number_count"></a>validate_password_number_count</h4><p>密码中数字的最小个数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> validate_password_number_count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="validate-password-mixed-case-count"><a href="#validate-password-mixed-case-count" class="headerlink" title="validate_password_mixed_case_count"></a>validate_password_mixed_case_count</h4><p>密码中大小写的最小个数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> validate_password_mixed_case_count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="validate-password-special-char-count"><a href="#validate-password-special-char-count" class="headerlink" title="validate_password_special_char_count"></a>validate_password_special_char_count</h4><p>密码中特殊字符的最小个数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> validate_password_special_char_count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="validate-password-dictionary-file"><a href="#validate-password-dictionary-file" class="headerlink" title="validate_password_dictionary_file"></a>validate_password_dictionary_file</h4><p>字典文件</p><h3 id="策略解释"><a href="#策略解释" class="headerlink" title="策略解释"></a>策略解释</h3><h4 id="LOW"><a href="#LOW" class="headerlink" title="LOW"></a>LOW</h4><p>校验级别最低，只校验密码长度，只要长度跟validate_password_length一样即可，默认长度是8位。  </p><h4 id="MEDIUM"><a href="#MEDIUM" class="headerlink" title="MEDIUM"></a>MEDIUM</h4><p>除了校验LOW的内容，还要校验数字个数，大小写个数，特殊字符个数。  </p><h4 id="STRONG"><a href="#STRONG" class="headerlink" title="STRONG"></a>STRONG</h4><p>除了校验MEDIUM的内容，还要校验密码中任意连续4个或以上的字符不得是字典中的单词。  </p>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos7 安装MySQL</title>
      <link href="/2019/08/06/linux-install-1-md/"/>
      <url>/2019/08/06/linux-install-1-md/</url>
      <content type="html"><![CDATA[<h3 id="下载MySQL源安装包"><a href="#下载MySQL源安装包" class="headerlink" title="下载MySQL源安装包"></a>下载MySQL源安装包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure><h3 id="安装MySQL源"><a href="#安装MySQL源" class="headerlink" title="安装MySQL源"></a>安装MySQL源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum localinstall mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure><h3 id="检查MySQL源是否安装成功"><a href="#检查MySQL源是否安装成功" class="headerlink" title="检查MySQL源是否安装成功"></a>检查MySQL源是否安装成功</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist enabled | grep "mysql.*-community.*"</span><br></pre></td></tr></table></figure><h3 id="修改源，改变默认安装的MySQL版本"><a href="#修改源，改变默认安装的MySQL版本" class="headerlink" title="修改源，改变默认安装的MySQL版本"></a>修改源，改变默认安装的MySQL版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/mysql-community.repo</span><br></pre></td></tr></table></figure><p>如果要使用5.6，就将5.6下方的 <strong>enabled=1</strong> ，其他的设为 <strong>enabled=0</strong> 。</p><h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql-community-server</span><br></pre></td></tr></table></figure><h3 id="启动MySQL服务"><a href="#启动MySQL服务" class="headerlink" title="启动MySQL服务"></a>启动MySQL服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure><h3 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable mysqld</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><h3 id="修改本地登录密码"><a href="#修改本地登录密码" class="headerlink" title="修改本地登录密码"></a>修改本地登录密码</h3><h4 id="查看MySQL密码"><a href="#查看MySQL密码" class="headerlink" title="查看MySQL密码"></a>查看MySQL密码</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep 'temporary password' /var/log/mysqld.log</span><br></pre></td></tr></table></figure><h4 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">'root'</span>@<span class="string">'localhost'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'MyNewPass1!'</span>;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> <span class="keyword">FOR</span> <span class="string">'root'</span>@<span class="string">'localhost'</span>=<span class="keyword">password</span>(<span class="string">'MyNewPass1!'</span>);</span><br></pre></td></tr></table></figure><p>或 5.7以上的版本使用:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> mysql.user <span class="keyword">set</span> authentication_string=<span class="keyword">password</span>(<span class="string">'MyNewPass1!'</span>)<span class="keyword">where</span> <span class="keyword">user</span>=<span class="string">'root'</span> ;</span><br></pre></td></tr></table></figure><h4 id="检查密码"><a href="#检查密码" class="headerlink" title="检查密码"></a>检查密码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'%password%'</span>;</span><br></pre></td></tr></table></figure><h3 id="添加远程登录用户"><a href="#添加远程登录用户" class="headerlink" title="添加远程登录用户"></a>添加远程登录用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> ALL <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'REMOTE_USER'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'MyNewPassword2!'</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> MySQL </tag>
            
            <tag> linux环境配置 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>springboot[2]mysql的配置及JPA的使用</title>
      <link href="/2019/07/23/springboot-2/"/>
      <url>/2019/07/23/springboot-2/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="mysql的配置"><a href="#mysql的配置" class="headerlink" title="mysql的配置"></a>mysql的配置</h3><p>首先在maven中引入依赖:  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在配置文件中配置:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://127.0.0.1/database_name?characterEncoding=utf-8&amp;useSSL=false</span></span><br></pre></td></tr></table></figure><h3 id="JPA的使用"><a href="#JPA的使用" class="headerlink" title="JPA的使用"></a>JPA的使用</h3><h4 id="基础配置使用"><a href="#基础配置使用" class="headerlink" title="基础配置使用"></a>基础配置使用</h4><p>首先在maven中引入依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在配置文件中设置(打印sql):  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jpa:</span><br><span class="line">  show-sql: true</span><br></pre></td></tr></table></figure><p>新建entity包并创建文件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DynamicUpdate</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductCategory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Integer categoryId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String categoryName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer categoryType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果类名和表名的关系不是驼峰转下划线的关系的话，我们可以使用@Table注解来配置表名:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Table</span>(name = <span class="string">"t_product_category"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductCategory</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建repository包并创建Repository接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductCategoryRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">ProductCategory</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;ProductCategory&gt; <span class="title">findByCategoryTypeIn</span><span class="params">(List&lt;Integer&gt; categoryTypeList)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DynamicUpdate注解说明"><a href="#DynamicUpdate注解说明" class="headerlink" title="DynamicUpdate注解说明"></a>DynamicUpdate注解说明</h4><p>在实际业务场景中，我们经常会从数据库中查出一条数据，对其做一些修改后再更新数据库，如果我们更新时将原来的update_time传入，就会使数据库默认的update_time失效。<br>这时我们可以为entity类加上DynamicUpdate注解自动更新数据库时间。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DynamicUpdate</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductCategory</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><p>我们可以写一个测试类来测试表的增删改查:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductCategoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductCategoryRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findOneTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProductCategory one = repository.findById(<span class="number">1</span>).orElse(<span class="keyword">null</span>);</span><br><span class="line">        Assert.assertNotNull(one);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProductCategory productCategory = <span class="keyword">new</span> ProductCategory();</span><br><span class="line">        productCategory.setCategoryName(<span class="string">"女生最爱"</span>);</span><br><span class="line">        productCategory.setCategoryType(<span class="number">3</span>);</span><br><span class="line">        repository.save(productCategory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProductCategory productCategory = <span class="keyword">new</span> ProductCategory();</span><br><span class="line">        productCategory.setCategoryId(<span class="number">2</span>);</span><br><span class="line">        productCategory.setCategoryName(<span class="string">"男生最爱"</span>);</span><br><span class="line">        productCategory.setCategoryType(<span class="number">3</span>);</span><br><span class="line">        repository.save(productCategory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findByCategoryTypeInList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        List&lt;ProductCategory&gt; productCategories = repository.findByCategoryTypeIn(list);</span><br><span class="line">        Assert.assertNotEquals(productCategories.size(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><p><strong>如果编辑器报错</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Inferred type &apos;S&apos; for type parameter &apos;S&apos; is not within its bound;</span><br></pre></td></tr></table></figure><p>这是由于使用SpringBoot是2版本但直接调用了find方法如下:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProductCategory one = repository.findById(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这在SpringBoot 2.X中已经不允许了。  </p><ol><li><p>将版本换回1.5.4。  </p></li><li><p>写成以下形式:  </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProductCategory one = repository.findById(<span class="number">1</span>).orElse(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p><strong>如果编辑器报错</strong>:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Table &apos;sell.hibernate_sequence&apos; doesn&apos;t exist</span><br></pre></td></tr></table></figure><p>如果我们使用以下写法就会报错，这也是因为SpringBoot2.X使用了hibernate5导致的。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GeneratedValue</span></span><br></pre></td></tr></table></figure><ol><li><p>版本切换  </p></li><li><p>写成如下形式:  </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>springboot[1]logback的使用与配置</title>
      <link href="/2019/07/10/springboot-1/"/>
      <url>/2019/07/10/springboot-1/</url>
      <content type="html"><![CDATA[<a id="more"></a><h3 id="日志框架的作用"><a href="#日志框架的作用" class="headerlink" title="日志框架的作用"></a>日志框架的作用</h3><ul><li>定制输出目标<br>可以选择输出到控制台或文件等  </li><li>定制输出格式<br>可以为输出内容配置公用的格式  </li><li>携带上下文信息<br>可以携带类信息，时间信息等上下文信息  </li><li>运行时选择性输出<br>可以只输出部分等级，部分类的日志  </li><li>灵活的配置<br>可以选择按天滚动等  </li><li>优异的性能<br>System.out.println会添加synchronized方法锁，会极大地影响系统性能  </li></ul><h3 id="logback所需jar包"><a href="#logback所需jar包" class="headerlink" title="logback所需jar包"></a>logback所需jar包</h3><p>springboot在spring-boot-starter-web中内嵌了logback的模块,所以不用额外引用包.若不使用springboot,需要导入如下两个包:  </p><ol><li><p>logback-core-xxx.jar  </p></li><li><p>logback-classic-xxx.jar  </p></li></ol><p>包的依赖关系可以使用如下指令来查看:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn dependency:tree</span><br></pre></td></tr></table></figure><h3 id="Spring-Test中使用Logback"><a href="#Spring-Test中使用Logback" class="headerlink" title="Spring Test中使用Logback"></a>Spring Test中使用Logback</h3><p>普通引入:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(LoggerTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"debug..."</span>); <span class="comment">// 系统默认的日志级别是info.这里不会打印</span></span><br><span class="line">        logger.info(<span class="string">"info..."</span>);</span><br><span class="line">        logger.error(<span class="string">"error..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lombok简化引入:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"debug..."</span>);</span><br><span class="line">        log.info(<span class="string">"info..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h3><p>在resources目录下新建logback-spring.xml就可以对日志进行配置了。日志基本内容如下:  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 控制台输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"consoleLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %-5level [%thread]%c %M %L: %m%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- INFO及WARN等级输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"fileInfoLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表示忽略ERROR等级的输出 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--滚动策略(按时间滚动,默认按天滚动)--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--输出路径--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>./log/info-%d.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ERROR等级输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"fileErrorLog"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表示输出ERROR等级及以上的日志文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span></span><br><span class="line">                %msg%n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--滚动策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--路径--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>./log/error-%d.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"consoleLog"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"fileInfoLog"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"fileErrorLog"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="常用pattern说明"><a href="#常用pattern说明" class="headerlink" title="常用pattern说明"></a>常用pattern说明</h4><table><thead><tr><th>pattern</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td>%d{pattern}</td><td style="text-align:center">日期</td></tr><tr><td>%m 或 %msg</td><td style="text-align:center">信息</td></tr><tr><td>%c{length}</td><td style="text-align:center">logger名,默认输出全路径,当length大于路径长度输出全路径,length为0只输出类名,否则输出路径首字母及类名</td></tr><tr><td>%M</td><td style="text-align:center">method</td></tr><tr><td>%L</td><td style="text-align:center">行号</td></tr><tr><td>%thread</td><td style="text-align:center">线程名称</td></tr><tr><td>%-5level</td><td style="text-align:center">等级</td></tr><tr><td>%n</td><td style="text-align:center">换行</td></tr></tbody></table>]]></content>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
